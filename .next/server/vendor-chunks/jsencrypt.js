/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsencrypt";
exports.ids = ["vendor-chunks/jsencrypt"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsencrypt/bin/jsencrypt.js":
/*!*************************************************!*\
  !*** ./node_modules/jsencrypt/bin/jsencrypt.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./lib/JSEncrypt.js\":\n/*!**************************!*\\\n  !*** ./lib/JSEncrypt.js ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"JSEncrypt\\\": () => (/* binding */ JSEncrypt)\\n/* harmony export */ });\\n/* harmony import */ var _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/jsbn/base64 */ \\\"./lib/lib/jsbn/base64.js\\\");\\n/* harmony import */ var _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JSEncryptRSAKey */ \\\"./lib/JSEncryptRSAKey.js\\\");\\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \\\"./node_modules/process/browser.js\\\");\\nvar _a;\\n\\n\\nvar version = typeof process !== 'undefined'\\n    ? (_a = process.env) === null || _a === void 0 ? void 0 : \\\"3.3.2\\\"\\n    : undefined;\\n/**\\n *\\n * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour\\n * possible parameters are:\\n * - default_key_size        {number}  default: 1024 the key size in bit\\n * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent\\n * - log                     {boolean} default: false whether log warn/error or not\\n * @constructor\\n */\\nvar JSEncrypt = /** @class */ (function () {\\n    function JSEncrypt(options) {\\n        if (options === void 0) { options = {}; }\\n        options = options || {};\\n        this.default_key_size = options.default_key_size\\n            ? parseInt(options.default_key_size, 10)\\n            : 1024;\\n        this.default_public_exponent = options.default_public_exponent || \\\"010001\\\"; // 65537 default openssl public exponent for rsa key type\\n        this.log = options.log || false;\\n        // The private and public key.\\n        this.key = null;\\n    }\\n    /**\\n     * Method to set the rsa key parameter (one method is enough to set both the public\\n     * and the private key, since the private key contains the public key paramenters)\\n     * Log a warning if logs are enabled\\n     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)\\n     * @public\\n     */\\n    JSEncrypt.prototype.setKey = function (key) {\\n        if (this.log && this.key) {\\n            console.warn(\\\"A key was already set, overriding existing.\\\");\\n        }\\n        this.key = new _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__.JSEncryptRSAKey(key);\\n    };\\n    /**\\n     * Proxy method for setKey, for api compatibility\\n     * @see setKey\\n     * @public\\n     */\\n    JSEncrypt.prototype.setPrivateKey = function (privkey) {\\n        // Create the key.\\n        this.setKey(privkey);\\n    };\\n    /**\\n     * Proxy method for setKey, for api compatibility\\n     * @see setKey\\n     * @public\\n     */\\n    JSEncrypt.prototype.setPublicKey = function (pubkey) {\\n        // Sets the public key.\\n        this.setKey(pubkey);\\n    };\\n    /**\\n     * Proxy method for RSAKey object's decrypt, decrypt the string using the private\\n     * components of the rsa key object. Note that if the object was not set will be created\\n     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\\n     * @param {string} str base64 encoded crypted string to decrypt\\n     * @return {string} the decrypted string\\n     * @public\\n     */\\n    JSEncrypt.prototype.decrypt = function (str) {\\n        // Return the decrypted string.\\n        try {\\n            return this.getKey().decrypt((0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.b64tohex)(str));\\n        }\\n        catch (ex) {\\n            return false;\\n        }\\n    };\\n    /**\\n     * Proxy method for RSAKey object's encrypt, encrypt the string using the public\\n     * components of the rsa key object. Note that if the object was not set will be created\\n     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\\n     * @param {string} str the string to encrypt\\n     * @return {string} the encrypted string encoded in base64\\n     * @public\\n     */\\n    JSEncrypt.prototype.encrypt = function (str) {\\n        // Return the encrypted string.\\n        try {\\n            return (0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getKey().encrypt(str));\\n        }\\n        catch (ex) {\\n            return false;\\n        }\\n    };\\n    /**\\n     * Proxy method for RSAKey object's sign.\\n     * @param {string} str the string to sign\\n     * @param {function} digestMethod hash method\\n     * @param {string} digestName the name of the hash algorithm\\n     * @return {string} the signature encoded in base64\\n     * @public\\n     */\\n    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {\\n        // return the RSA signature of 'str' in 'hex' format.\\n        try {\\n            return (0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getKey().sign(str, digestMethod, digestName));\\n        }\\n        catch (ex) {\\n            return false;\\n        }\\n    };\\n    /**\\n     * Proxy method for RSAKey object's verify.\\n     * @param {string} str the string to verify\\n     * @param {string} signature the signature encoded in base64 to compare the string to\\n     * @param {function} digestMethod hash method\\n     * @return {boolean} whether the data and signature match\\n     * @public\\n     */\\n    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {\\n        // Return the decrypted 'digest' of the signature.\\n        try {\\n            return this.getKey().verify(str, (0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.b64tohex)(signature), digestMethod);\\n        }\\n        catch (ex) {\\n            return false;\\n        }\\n    };\\n    /**\\n     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object\\n     * will be created and returned\\n     * @param {callback} [cb] the callback to be called if we want the key to be generated\\n     * in an async fashion\\n     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object\\n     * @public\\n     */\\n    JSEncrypt.prototype.getKey = function (cb) {\\n        // Only create new if it does not exist.\\n        if (!this.key) {\\n            // Get a new private key.\\n            this.key = new _JSEncryptRSAKey__WEBPACK_IMPORTED_MODULE_1__.JSEncryptRSAKey();\\n            if (cb && {}.toString.call(cb) === \\\"[object Function]\\\") {\\n                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);\\n                return;\\n            }\\n            // Generate the key.\\n            this.key.generate(this.default_key_size, this.default_public_exponent);\\n        }\\n        return this.key;\\n    };\\n    /**\\n     * Returns the pem encoded representation of the private key\\n     * If the key doesn't exists a new key will be created\\n     * @returns {string} pem encoded representation of the private key WITH header and footer\\n     * @public\\n     */\\n    JSEncrypt.prototype.getPrivateKey = function () {\\n        // Return the private representation of this key.\\n        return this.getKey().getPrivateKey();\\n    };\\n    /**\\n     * Returns the pem encoded representation of the private key\\n     * If the key doesn't exists a new key will be created\\n     * @returns {string} pem encoded representation of the private key WITHOUT header and footer\\n     * @public\\n     */\\n    JSEncrypt.prototype.getPrivateKeyB64 = function () {\\n        // Return the private representation of this key.\\n        return this.getKey().getPrivateBaseKeyB64();\\n    };\\n    /**\\n     * Returns the pem encoded representation of the public key\\n     * If the key doesn't exists a new key will be created\\n     * @returns {string} pem encoded representation of the public key WITH header and footer\\n     * @public\\n     */\\n    JSEncrypt.prototype.getPublicKey = function () {\\n        // Return the private representation of this key.\\n        return this.getKey().getPublicKey();\\n    };\\n    /**\\n     * Returns the pem encoded representation of the public key\\n     * If the key doesn't exists a new key will be created\\n     * @returns {string} pem encoded representation of the public key WITHOUT header and footer\\n     * @public\\n     */\\n    JSEncrypt.prototype.getPublicKeyB64 = function () {\\n        // Return the private representation of this key.\\n        return this.getKey().getPublicBaseKeyB64();\\n    };\\n    JSEncrypt.version = version;\\n    return JSEncrypt;\\n}());\\n\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/JSEncrypt.js?\");\n\n/***/ }),\n\n/***/ \"./lib/JSEncryptRSAKey.js\":\n/*!********************************!*\\\n  !*** ./lib/JSEncryptRSAKey.js ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"JSEncryptRSAKey\\\": () => (/* binding */ JSEncryptRSAKey)\\n/* harmony export */ });\\n/* harmony import */ var _lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/jsbn/base64 */ \\\"./lib/lib/jsbn/base64.js\\\");\\n/* harmony import */ var _lib_asn1js_hex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/asn1js/hex */ \\\"./lib/lib/asn1js/hex.js\\\");\\n/* harmony import */ var _lib_asn1js_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/asn1js/base64 */ \\\"./lib/lib/asn1js/base64.js\\\");\\n/* harmony import */ var _lib_asn1js_asn1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/asn1js/asn1 */ \\\"./lib/lib/asn1js/asn1.js\\\");\\n/* harmony import */ var _lib_jsbn_rsa__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/jsbn/rsa */ \\\"./lib/lib/jsbn/rsa.js\\\");\\n/* harmony import */ var _lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/jsbn/jsbn */ \\\"./lib/lib/jsbn/jsbn.js\\\");\\n/* harmony import */ var _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/jsrsasign/asn1-1.0 */ \\\"./lib/lib/jsrsasign/asn1-1.0.js\\\");\\nvar __extends = (undefined && undefined.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.\\n * This object is just a decorator for parsing the key parameter\\n * @param {string|Object} key - The key in string format, or an object containing\\n * the parameters needed to build a RSAKey object.\\n * @constructor\\n */\\nvar JSEncryptRSAKey = /** @class */ (function (_super) {\\n    __extends(JSEncryptRSAKey, _super);\\n    function JSEncryptRSAKey(key) {\\n        var _this = _super.call(this) || this;\\n        // Call the super constructor.\\n        //  RSAKey.call(this);\\n        // If a key key was provided.\\n        if (key) {\\n            // If this is a string...\\n            if (typeof key === \\\"string\\\") {\\n                _this.parseKey(key);\\n            }\\n            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||\\n                JSEncryptRSAKey.hasPublicKeyProperty(key)) {\\n                // Set the values for the key.\\n                _this.parsePropertiesFrom(key);\\n            }\\n        }\\n        return _this;\\n    }\\n    /**\\n     * Method to parse a pem encoded string containing both a public or private key.\\n     * The method will translate the pem encoded string in a der encoded string and\\n     * will parse private key and public key parameters. This method accepts public key\\n     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).\\n     *\\n     * @todo Check how many rsa formats use the same format of pkcs #1.\\n     *\\n     * The format is defined as:\\n     * PublicKeyInfo ::= SEQUENCE {\\n     *   algorithm       AlgorithmIdentifier,\\n     *   PublicKey       BIT STRING\\n     * }\\n     * Where AlgorithmIdentifier is:\\n     * AlgorithmIdentifier ::= SEQUENCE {\\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\\n     * }\\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\\n     * RSAPublicKey ::= SEQUENCE {\\n     *   modulus           INTEGER,  -- n\\n     *   publicExponent    INTEGER   -- e\\n     * }\\n     * it's possible to examine the structure of the keys obtained from openssl using\\n     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/\\n     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer\\n     * @private\\n     */\\n    JSEncryptRSAKey.prototype.parseKey = function (pem) {\\n        try {\\n            var modulus = 0;\\n            var public_exponent = 0;\\n            var reHex = /^\\\\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\\\\s*)+$/;\\n            var der = reHex.test(pem) ? _lib_asn1js_hex__WEBPACK_IMPORTED_MODULE_1__.Hex.decode(pem) : _lib_asn1js_base64__WEBPACK_IMPORTED_MODULE_2__.Base64.unarmor(pem);\\n            var asn1 = _lib_asn1js_asn1__WEBPACK_IMPORTED_MODULE_3__.ASN1.decode(der);\\n            // Fixes a bug with OpenSSL 1.0+ private keys\\n            if (asn1.sub.length === 3) {\\n                asn1 = asn1.sub[2].sub[0];\\n            }\\n            if (asn1.sub.length === 9) {\\n                // Parse the private key.\\n                modulus = asn1.sub[1].getHexStringValue(); // bigint\\n                this.n = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(modulus, 16);\\n                public_exponent = asn1.sub[2].getHexStringValue(); // int\\n                this.e = parseInt(public_exponent, 16);\\n                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint\\n                this.d = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(private_exponent, 16);\\n                var prime1 = asn1.sub[4].getHexStringValue(); // bigint\\n                this.p = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(prime1, 16);\\n                var prime2 = asn1.sub[5].getHexStringValue(); // bigint\\n                this.q = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(prime2, 16);\\n                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint\\n                this.dmp1 = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(exponent1, 16);\\n                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint\\n                this.dmq1 = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(exponent2, 16);\\n                var coefficient = asn1.sub[8].getHexStringValue(); // bigint\\n                this.coeff = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(coefficient, 16);\\n            }\\n            else if (asn1.sub.length === 2) {\\n                if (asn1.sub[0].sub) {\\n                    // Parse ASN.1 SubjectPublicKeyInfo type as defined by X.509\\n                    var bit_string = asn1.sub[1];\\n                    var sequence = bit_string.sub[0];\\n                    modulus = sequence.sub[0].getHexStringValue();\\n                    this.n = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(modulus, 16);\\n                    public_exponent = sequence.sub[1].getHexStringValue();\\n                    this.e = parseInt(public_exponent, 16);\\n                }\\n                else {\\n                    // Parse ASN.1 RSAPublicKey type as defined by PKCS #1\\n                    modulus = asn1.sub[0].getHexStringValue();\\n                    this.n = (0,_lib_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_5__.parseBigInt)(modulus, 16);\\n                    public_exponent = asn1.sub[1].getHexStringValue();\\n                    this.e = parseInt(public_exponent, 16);\\n                }\\n            }\\n            else {\\n                return false;\\n            }\\n            return true;\\n        }\\n        catch (ex) {\\n            return false;\\n        }\\n    };\\n    /**\\n     * Translate rsa parameters in a hex encoded string representing the rsa key.\\n     *\\n     * The translation follow the ASN.1 notation :\\n     * RSAPrivateKey ::= SEQUENCE {\\n     *   version           Version,\\n     *   modulus           INTEGER,  -- n\\n     *   publicExponent    INTEGER,  -- e\\n     *   privateExponent   INTEGER,  -- d\\n     *   prime1            INTEGER,  -- p\\n     *   prime2            INTEGER,  -- q\\n     *   exponent1         INTEGER,  -- d mod (p1)\\n     *   exponent2         INTEGER,  -- d mod (q-1)\\n     *   coefficient       INTEGER,  -- (inverse of q) mod p\\n     * }\\n     * @returns {string}  DER Encoded String representing the rsa private key\\n     * @private\\n     */\\n    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {\\n        var options = {\\n            array: [\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: 0 }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.n }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: this.e }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.d }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.p }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.q }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.dmp1 }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.dmq1 }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.coeff }),\\n            ],\\n        };\\n        var seq = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence(options);\\n        return seq.getEncodedHex();\\n    };\\n    /**\\n     * base64 (pem) encoded version of the DER encoded representation\\n     * @returns {string} pem encoded representation without header and footer\\n     * @public\\n     */\\n    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {\\n        return (0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getPrivateBaseKey());\\n    };\\n    /**\\n     * Translate rsa parameters in a hex encoded string representing the rsa public key.\\n     * The representation follow the ASN.1 notation :\\n     * PublicKeyInfo ::= SEQUENCE {\\n     *   algorithm       AlgorithmIdentifier,\\n     *   PublicKey       BIT STRING\\n     * }\\n     * Where AlgorithmIdentifier is:\\n     * AlgorithmIdentifier ::= SEQUENCE {\\n     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm\\n     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)\\n     * }\\n     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING\\n     * RSAPublicKey ::= SEQUENCE {\\n     *   modulus           INTEGER,  -- n\\n     *   publicExponent    INTEGER   -- e\\n     * }\\n     * @returns {string} DER Encoded String representing the rsa public key\\n     * @private\\n     */\\n    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {\\n        var first_sequence = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({\\n            array: [\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERObjectIdentifier({ oid: \\\"1.2.840.113549.1.1.1\\\" }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERNull(),\\n            ],\\n        });\\n        var second_sequence = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({\\n            array: [\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ bigint: this.n }),\\n                new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERInteger({ int: this.e }),\\n            ],\\n        });\\n        var bit_string = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERBitString({\\n            hex: \\\"00\\\" + second_sequence.getEncodedHex(),\\n        });\\n        var seq = new _lib_jsrsasign_asn1_1_0__WEBPACK_IMPORTED_MODULE_6__.KJUR.asn1.DERSequence({\\n            array: [first_sequence, bit_string],\\n        });\\n        return seq.getEncodedHex();\\n    };\\n    /**\\n     * base64 (pem) encoded version of the DER encoded representation\\n     * @returns {string} pem encoded representation without header and footer\\n     * @public\\n     */\\n    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {\\n        return (0,_lib_jsbn_base64__WEBPACK_IMPORTED_MODULE_0__.hex2b64)(this.getPublicBaseKey());\\n    };\\n    /**\\n     * wrap the string in block of width chars. The default value for rsa keys is 64\\n     * characters.\\n     * @param {string} str the pem encoded string without header and footer\\n     * @param {Number} [width=64] - the length the string has to be wrapped at\\n     * @returns {string}\\n     * @private\\n     */\\n    JSEncryptRSAKey.wordwrap = function (str, width) {\\n        width = width || 64;\\n        if (!str) {\\n            return str;\\n        }\\n        var regex = \\\"(.{1,\\\" + width + \\\"})( +|$\\\\n?)|(.{1,\\\" + width + \\\"})\\\";\\n        return str.match(RegExp(regex, \\\"g\\\")).join(\\\"\\\\n\\\");\\n    };\\n    /**\\n     * Retrieve the pem encoded private key\\n     * @returns {string} the pem encoded private key with header/footer\\n     * @public\\n     */\\n    JSEncryptRSAKey.prototype.getPrivateKey = function () {\\n        var key = \\\"-----BEGIN RSA PRIVATE KEY-----\\\\n\\\";\\n        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + \\\"\\\\n\\\";\\n        key += \\\"-----END RSA PRIVATE KEY-----\\\";\\n        return key;\\n    };\\n    /**\\n     * Retrieve the pem encoded public key\\n     * @returns {string} the pem encoded public key with header/footer\\n     * @public\\n     */\\n    JSEncryptRSAKey.prototype.getPublicKey = function () {\\n        var key = \\\"-----BEGIN PUBLIC KEY-----\\\\n\\\";\\n        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + \\\"\\\\n\\\";\\n        key += \\\"-----END PUBLIC KEY-----\\\";\\n        return key;\\n    };\\n    /**\\n     * Check if the object contains the necessary parameters to populate the rsa modulus\\n     * and public exponent parameters.\\n     * @param {Object} [obj={}] - An object that may contain the two public key\\n     * parameters\\n     * @returns {boolean} true if the object contains both the modulus and the public exponent\\n     * properties (n and e)\\n     * @todo check for types of n and e. N should be a parseable bigInt object, E should\\n     * be a parseable integer number\\n     * @private\\n     */\\n    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {\\n        obj = obj || {};\\n        return obj.hasOwnProperty(\\\"n\\\") && obj.hasOwnProperty(\\\"e\\\");\\n    };\\n    /**\\n     * Check if the object contains ALL the parameters of an RSA key.\\n     * @param {Object} [obj={}] - An object that may contain nine rsa key\\n     * parameters\\n     * @returns {boolean} true if the object contains all the parameters needed\\n     * @todo check for types of the parameters all the parameters but the public exponent\\n     * should be parseable bigint objects, the public exponent should be a parseable integer number\\n     * @private\\n     */\\n    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {\\n        obj = obj || {};\\n        return (obj.hasOwnProperty(\\\"n\\\") &&\\n            obj.hasOwnProperty(\\\"e\\\") &&\\n            obj.hasOwnProperty(\\\"d\\\") &&\\n            obj.hasOwnProperty(\\\"p\\\") &&\\n            obj.hasOwnProperty(\\\"q\\\") &&\\n            obj.hasOwnProperty(\\\"dmp1\\\") &&\\n            obj.hasOwnProperty(\\\"dmq1\\\") &&\\n            obj.hasOwnProperty(\\\"coeff\\\"));\\n    };\\n    /**\\n     * Parse the properties of obj in the current rsa object. Obj should AT LEAST\\n     * include the modulus and public exponent (n, e) parameters.\\n     * @param {Object} obj - the object containing rsa parameters\\n     * @private\\n     */\\n    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {\\n        this.n = obj.n;\\n        this.e = obj.e;\\n        if (obj.hasOwnProperty(\\\"d\\\")) {\\n            this.d = obj.d;\\n            this.p = obj.p;\\n            this.q = obj.q;\\n            this.dmp1 = obj.dmp1;\\n            this.dmq1 = obj.dmq1;\\n            this.coeff = obj.coeff;\\n        }\\n    };\\n    return JSEncryptRSAKey;\\n}(_lib_jsbn_rsa__WEBPACK_IMPORTED_MODULE_4__.RSAKey));\\n\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/JSEncryptRSAKey.js?\");\n\n/***/ }),\n\n/***/ \"./lib/index.js\":\n/*!**********************!*\\\n  !*** ./lib/index.js ***!\n  \\**********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"JSEncrypt\\\": () => (/* reexport safe */ _JSEncrypt__WEBPACK_IMPORTED_MODULE_0__.JSEncrypt),\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _JSEncrypt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JSEncrypt */ \\\"./lib/JSEncrypt.js\\\");\\n\\n\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_JSEncrypt__WEBPACK_IMPORTED_MODULE_0__.JSEncrypt);\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/index.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/asn1js/asn1.js\":\n/*!********************************!*\\\n  !*** ./lib/lib/asn1js/asn1.js ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"ASN1\\\": () => (/* binding */ ASN1),\\n/* harmony export */   \\\"ASN1Tag\\\": () => (/* binding */ ASN1Tag),\\n/* harmony export */   \\\"Stream\\\": () => (/* binding */ Stream)\\n/* harmony export */ });\\n/* harmony import */ var _int10__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./int10 */ \\\"./lib/lib/asn1js/int10.js\\\");\\n// ASN.1 JavaScript decoder\\n// Copyright (c) 2008-2014 Lapo Luchini <lapo@lapo.it>\\n// Permission to use, copy, modify, and/or distribute this software for any\\n// purpose with or without fee is hereby granted, provided that the above\\n// copyright notice and this permission notice appear in all copies.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\\n/*global oids */\\n\\nvar ellipsis = \\\"\\\\u2026\\\";\\nvar reTimeS = /^(\\\\d\\\\d)(0[1-9]|1[0-2])(0[1-9]|[12]\\\\d|3[01])([01]\\\\d|2[0-3])(?:([0-5]\\\\d)(?:([0-5]\\\\d)(?:[.,](\\\\d{1,3}))?)?)?(Z|[-+](?:[0]\\\\d|1[0-2])([0-5]\\\\d)?)?$/;\\nvar reTimeL = /^(\\\\d\\\\d\\\\d\\\\d)(0[1-9]|1[0-2])(0[1-9]|[12]\\\\d|3[01])([01]\\\\d|2[0-3])(?:([0-5]\\\\d)(?:([0-5]\\\\d)(?:[.,](\\\\d{1,3}))?)?)?(Z|[-+](?:[0]\\\\d|1[0-2])([0-5]\\\\d)?)?$/;\\nfunction stringCut(str, len) {\\n    if (str.length > len) {\\n        str = str.substring(0, len) + ellipsis;\\n    }\\n    return str;\\n}\\nvar Stream = /** @class */ (function () {\\n    function Stream(enc, pos) {\\n        this.hexDigits = \\\"0123456789ABCDEF\\\";\\n        if (enc instanceof Stream) {\\n            this.enc = enc.enc;\\n            this.pos = enc.pos;\\n        }\\n        else {\\n            // enc should be an array or a binary string\\n            this.enc = enc;\\n            this.pos = pos;\\n        }\\n    }\\n    Stream.prototype.get = function (pos) {\\n        if (pos === undefined) {\\n            pos = this.pos++;\\n        }\\n        if (pos >= this.enc.length) {\\n            throw new Error(\\\"Requesting byte offset \\\".concat(pos, \\\" on a stream of length \\\").concat(this.enc.length));\\n        }\\n        return (\\\"string\\\" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];\\n    };\\n    Stream.prototype.hexByte = function (b) {\\n        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);\\n    };\\n    Stream.prototype.hexDump = function (start, end, raw) {\\n        var s = \\\"\\\";\\n        for (var i = start; i < end; ++i) {\\n            s += this.hexByte(this.get(i));\\n            if (raw !== true) {\\n                switch (i & 0xF) {\\n                    case 0x7:\\n                        s += \\\"  \\\";\\n                        break;\\n                    case 0xF:\\n                        s += \\\"\\\\n\\\";\\n                        break;\\n                    default:\\n                        s += \\\" \\\";\\n                }\\n            }\\n        }\\n        return s;\\n    };\\n    Stream.prototype.isASCII = function (start, end) {\\n        for (var i = start; i < end; ++i) {\\n            var c = this.get(i);\\n            if (c < 32 || c > 176) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    };\\n    Stream.prototype.parseStringISO = function (start, end) {\\n        var s = \\\"\\\";\\n        for (var i = start; i < end; ++i) {\\n            s += String.fromCharCode(this.get(i));\\n        }\\n        return s;\\n    };\\n    Stream.prototype.parseStringUTF = function (start, end) {\\n        var s = \\\"\\\";\\n        for (var i = start; i < end;) {\\n            var c = this.get(i++);\\n            if (c < 128) {\\n                s += String.fromCharCode(c);\\n            }\\n            else if ((c > 191) && (c < 224)) {\\n                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));\\n            }\\n            else {\\n                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));\\n            }\\n        }\\n        return s;\\n    };\\n    Stream.prototype.parseStringBMP = function (start, end) {\\n        var str = \\\"\\\";\\n        var hi;\\n        var lo;\\n        for (var i = start; i < end;) {\\n            hi = this.get(i++);\\n            lo = this.get(i++);\\n            str += String.fromCharCode((hi << 8) | lo);\\n        }\\n        return str;\\n    };\\n    Stream.prototype.parseTime = function (start, end, shortYear) {\\n        var s = this.parseStringISO(start, end);\\n        var m = (shortYear ? reTimeS : reTimeL).exec(s);\\n        if (!m) {\\n            return \\\"Unrecognized time: \\\" + s;\\n        }\\n        if (shortYear) {\\n            // to avoid querying the timer, use the fixed range [1970, 2069]\\n            // it will conform with ITU X.400 [-10, +40] sliding window until 2030\\n            m[1] = +m[1];\\n            m[1] += (+m[1] < 70) ? 2000 : 1900;\\n        }\\n        s = m[1] + \\\"-\\\" + m[2] + \\\"-\\\" + m[3] + \\\" \\\" + m[4];\\n        if (m[5]) {\\n            s += \\\":\\\" + m[5];\\n            if (m[6]) {\\n                s += \\\":\\\" + m[6];\\n                if (m[7]) {\\n                    s += \\\".\\\" + m[7];\\n                }\\n            }\\n        }\\n        if (m[8]) {\\n            s += \\\" UTC\\\";\\n            if (m[8] != \\\"Z\\\") {\\n                s += m[8];\\n                if (m[9]) {\\n                    s += \\\":\\\" + m[9];\\n                }\\n            }\\n        }\\n        return s;\\n    };\\n    Stream.prototype.parseInteger = function (start, end) {\\n        var v = this.get(start);\\n        var neg = (v > 127);\\n        var pad = neg ? 255 : 0;\\n        var len;\\n        var s = \\\"\\\";\\n        // skip unuseful bits (not allowed in DER)\\n        while (v == pad && ++start < end) {\\n            v = this.get(start);\\n        }\\n        len = end - start;\\n        if (len === 0) {\\n            return neg ? -1 : 0;\\n        }\\n        // show bit length of huge integers\\n        if (len > 4) {\\n            s = v;\\n            len <<= 3;\\n            while (((+s ^ pad) & 0x80) == 0) {\\n                s = +s << 1;\\n                --len;\\n            }\\n            s = \\\"(\\\" + len + \\\" bit)\\\\n\\\";\\n        }\\n        // decode the integer\\n        if (neg) {\\n            v = v - 256;\\n        }\\n        var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10(v);\\n        for (var i = start + 1; i < end; ++i) {\\n            n.mulAdd(256, this.get(i));\\n        }\\n        return s + n.toString();\\n    };\\n    Stream.prototype.parseBitString = function (start, end, maxLength) {\\n        var unusedBit = this.get(start);\\n        var lenBit = ((end - start - 1) << 3) - unusedBit;\\n        var intro = \\\"(\\\" + lenBit + \\\" bit)\\\\n\\\";\\n        var s = \\\"\\\";\\n        for (var i = start + 1; i < end; ++i) {\\n            var b = this.get(i);\\n            var skip = (i == end - 1) ? unusedBit : 0;\\n            for (var j = 7; j >= skip; --j) {\\n                s += (b >> j) & 1 ? \\\"1\\\" : \\\"0\\\";\\n            }\\n            if (s.length > maxLength) {\\n                return intro + stringCut(s, maxLength);\\n            }\\n        }\\n        return intro + s;\\n    };\\n    Stream.prototype.parseOctetString = function (start, end, maxLength) {\\n        if (this.isASCII(start, end)) {\\n            return stringCut(this.parseStringISO(start, end), maxLength);\\n        }\\n        var len = end - start;\\n        var s = \\\"(\\\" + len + \\\" byte)\\\\n\\\";\\n        maxLength /= 2; // we work in bytes\\n        if (len > maxLength) {\\n            end = start + maxLength;\\n        }\\n        for (var i = start; i < end; ++i) {\\n            s += this.hexByte(this.get(i));\\n        }\\n        if (len > maxLength) {\\n            s += ellipsis;\\n        }\\n        return s;\\n    };\\n    Stream.prototype.parseOID = function (start, end, maxLength) {\\n        var s = \\\"\\\";\\n        var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();\\n        var bits = 0;\\n        for (var i = start; i < end; ++i) {\\n            var v = this.get(i);\\n            n.mulAdd(128, v & 0x7F);\\n            bits += 7;\\n            if (!(v & 0x80)) { // finished\\n                if (s === \\\"\\\") {\\n                    n = n.simplify();\\n                    if (n instanceof _int10__WEBPACK_IMPORTED_MODULE_0__.Int10) {\\n                        n.sub(80);\\n                        s = \\\"2.\\\" + n.toString();\\n                    }\\n                    else {\\n                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;\\n                        s = m + \\\".\\\" + (n - m * 40);\\n                    }\\n                }\\n                else {\\n                    s += \\\".\\\" + n.toString();\\n                }\\n                if (s.length > maxLength) {\\n                    return stringCut(s, maxLength);\\n                }\\n                n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();\\n                bits = 0;\\n            }\\n        }\\n        if (bits > 0) {\\n            s += \\\".incomplete\\\";\\n        }\\n        return s;\\n    };\\n    return Stream;\\n}());\\n\\nvar ASN1 = /** @class */ (function () {\\n    function ASN1(stream, header, length, tag, sub) {\\n        if (!(tag instanceof ASN1Tag)) {\\n            throw new Error(\\\"Invalid tag value.\\\");\\n        }\\n        this.stream = stream;\\n        this.header = header;\\n        this.length = length;\\n        this.tag = tag;\\n        this.sub = sub;\\n    }\\n    ASN1.prototype.typeName = function () {\\n        switch (this.tag.tagClass) {\\n            case 0: // universal\\n                switch (this.tag.tagNumber) {\\n                    case 0x00:\\n                        return \\\"EOC\\\";\\n                    case 0x01:\\n                        return \\\"BOOLEAN\\\";\\n                    case 0x02:\\n                        return \\\"INTEGER\\\";\\n                    case 0x03:\\n                        return \\\"BIT_STRING\\\";\\n                    case 0x04:\\n                        return \\\"OCTET_STRING\\\";\\n                    case 0x05:\\n                        return \\\"NULL\\\";\\n                    case 0x06:\\n                        return \\\"OBJECT_IDENTIFIER\\\";\\n                    case 0x07:\\n                        return \\\"ObjectDescriptor\\\";\\n                    case 0x08:\\n                        return \\\"EXTERNAL\\\";\\n                    case 0x09:\\n                        return \\\"REAL\\\";\\n                    case 0x0A:\\n                        return \\\"ENUMERATED\\\";\\n                    case 0x0B:\\n                        return \\\"EMBEDDED_PDV\\\";\\n                    case 0x0C:\\n                        return \\\"UTF8String\\\";\\n                    case 0x10:\\n                        return \\\"SEQUENCE\\\";\\n                    case 0x11:\\n                        return \\\"SET\\\";\\n                    case 0x12:\\n                        return \\\"NumericString\\\";\\n                    case 0x13:\\n                        return \\\"PrintableString\\\"; // ASCII subset\\n                    case 0x14:\\n                        return \\\"TeletexString\\\"; // aka T61String\\n                    case 0x15:\\n                        return \\\"VideotexString\\\";\\n                    case 0x16:\\n                        return \\\"IA5String\\\"; // ASCII\\n                    case 0x17:\\n                        return \\\"UTCTime\\\";\\n                    case 0x18:\\n                        return \\\"GeneralizedTime\\\";\\n                    case 0x19:\\n                        return \\\"GraphicString\\\";\\n                    case 0x1A:\\n                        return \\\"VisibleString\\\"; // ASCII subset\\n                    case 0x1B:\\n                        return \\\"GeneralString\\\";\\n                    case 0x1C:\\n                        return \\\"UniversalString\\\";\\n                    case 0x1E:\\n                        return \\\"BMPString\\\";\\n                }\\n                return \\\"Universal_\\\" + this.tag.tagNumber.toString();\\n            case 1:\\n                return \\\"Application_\\\" + this.tag.tagNumber.toString();\\n            case 2:\\n                return \\\"[\\\" + this.tag.tagNumber.toString() + \\\"]\\\"; // Context\\n            case 3:\\n                return \\\"Private_\\\" + this.tag.tagNumber.toString();\\n        }\\n    };\\n    ASN1.prototype.content = function (maxLength) {\\n        if (this.tag === undefined) {\\n            return null;\\n        }\\n        if (maxLength === undefined) {\\n            maxLength = Infinity;\\n        }\\n        var content = this.posContent();\\n        var len = Math.abs(this.length);\\n        if (!this.tag.isUniversal()) {\\n            if (this.sub !== null) {\\n                return \\\"(\\\" + this.sub.length + \\\" elem)\\\";\\n            }\\n            return this.stream.parseOctetString(content, content + len, maxLength);\\n        }\\n        switch (this.tag.tagNumber) {\\n            case 0x01: // BOOLEAN\\n                return (this.stream.get(content) === 0) ? \\\"false\\\" : \\\"true\\\";\\n            case 0x02: // INTEGER\\n                return this.stream.parseInteger(content, content + len);\\n            case 0x03: // BIT_STRING\\n                return this.sub ? \\\"(\\\" + this.sub.length + \\\" elem)\\\" :\\n                    this.stream.parseBitString(content, content + len, maxLength);\\n            case 0x04: // OCTET_STRING\\n                return this.sub ? \\\"(\\\" + this.sub.length + \\\" elem)\\\" :\\n                    this.stream.parseOctetString(content, content + len, maxLength);\\n            // case 0x05: // NULL\\n            case 0x06: // OBJECT_IDENTIFIER\\n                return this.stream.parseOID(content, content + len, maxLength);\\n            // case 0x07: // ObjectDescriptor\\n            // case 0x08: // EXTERNAL\\n            // case 0x09: // REAL\\n            // case 0x0A: // ENUMERATED\\n            // case 0x0B: // EMBEDDED_PDV\\n            case 0x10: // SEQUENCE\\n            case 0x11: // SET\\n                if (this.sub !== null) {\\n                    return \\\"(\\\" + this.sub.length + \\\" elem)\\\";\\n                }\\n                else {\\n                    return \\\"(no elem)\\\";\\n                }\\n            case 0x0C: // UTF8String\\n                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);\\n            case 0x12: // NumericString\\n            case 0x13: // PrintableString\\n            case 0x14: // TeletexString\\n            case 0x15: // VideotexString\\n            case 0x16: // IA5String\\n            // case 0x19: // GraphicString\\n            case 0x1A: // VisibleString\\n                // case 0x1B: // GeneralString\\n                // case 0x1C: // UniversalString\\n                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);\\n            case 0x1E: // BMPString\\n                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);\\n            case 0x17: // UTCTime\\n            case 0x18: // GeneralizedTime\\n                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));\\n        }\\n        return null;\\n    };\\n    ASN1.prototype.toString = function () {\\n        return this.typeName() + \\\"@\\\" + this.stream.pos + \\\"[header:\\\" + this.header + \\\",length:\\\" + this.length + \\\",sub:\\\" + ((this.sub === null) ? \\\"null\\\" : this.sub.length) + \\\"]\\\";\\n    };\\n    ASN1.prototype.toPrettyString = function (indent) {\\n        if (indent === undefined) {\\n            indent = \\\"\\\";\\n        }\\n        var s = indent + this.typeName() + \\\" @\\\" + this.stream.pos;\\n        if (this.length >= 0) {\\n            s += \\\"+\\\";\\n        }\\n        s += this.length;\\n        if (this.tag.tagConstructed) {\\n            s += \\\" (constructed)\\\";\\n        }\\n        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {\\n            s += \\\" (encapsulates)\\\";\\n        }\\n        s += \\\"\\\\n\\\";\\n        if (this.sub !== null) {\\n            indent += \\\"  \\\";\\n            for (var i = 0, max = this.sub.length; i < max; ++i) {\\n                s += this.sub[i].toPrettyString(indent);\\n            }\\n        }\\n        return s;\\n    };\\n    ASN1.prototype.posStart = function () {\\n        return this.stream.pos;\\n    };\\n    ASN1.prototype.posContent = function () {\\n        return this.stream.pos + this.header;\\n    };\\n    ASN1.prototype.posEnd = function () {\\n        return this.stream.pos + this.header + Math.abs(this.length);\\n    };\\n    ASN1.prototype.toHexString = function () {\\n        return this.stream.hexDump(this.posStart(), this.posEnd(), true);\\n    };\\n    ASN1.decodeLength = function (stream) {\\n        var buf = stream.get();\\n        var len = buf & 0x7F;\\n        if (len == buf) {\\n            return len;\\n        }\\n        // no reason to use Int10, as it would be a huge buffer anyways\\n        if (len > 6) {\\n            throw new Error(\\\"Length over 48 bits not supported at position \\\" + (stream.pos - 1));\\n        }\\n        if (len === 0) {\\n            return null;\\n        } // undefined\\n        buf = 0;\\n        for (var i = 0; i < len; ++i) {\\n            buf = (buf * 256) + stream.get();\\n        }\\n        return buf;\\n    };\\n    /**\\n     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element\\n     * @returns {string}\\n     * @public\\n     */\\n    ASN1.prototype.getHexStringValue = function () {\\n        var hexString = this.toHexString();\\n        var offset = this.header * 2;\\n        var length = this.length * 2;\\n        return hexString.substr(offset, length);\\n    };\\n    ASN1.decode = function (str) {\\n        var stream;\\n        if (!(str instanceof Stream)) {\\n            stream = new Stream(str, 0);\\n        }\\n        else {\\n            stream = str;\\n        }\\n        var streamStart = new Stream(stream);\\n        var tag = new ASN1Tag(stream);\\n        var len = ASN1.decodeLength(stream);\\n        var start = stream.pos;\\n        var header = start - streamStart.pos;\\n        var sub = null;\\n        var getSub = function () {\\n            var ret = [];\\n            if (len !== null) {\\n                // definite length\\n                var end = start + len;\\n                while (stream.pos < end) {\\n                    ret[ret.length] = ASN1.decode(stream);\\n                }\\n                if (stream.pos != end) {\\n                    throw new Error(\\\"Content size is not correct for container starting at offset \\\" + start);\\n                }\\n            }\\n            else {\\n                // undefined length\\n                try {\\n                    for (;;) {\\n                        var s = ASN1.decode(stream);\\n                        if (s.tag.isEOC()) {\\n                            break;\\n                        }\\n                        ret[ret.length] = s;\\n                    }\\n                    len = start - stream.pos; // undefined lengths are represented as negative values\\n                }\\n                catch (e) {\\n                    throw new Error(\\\"Exception while decoding undefined length content: \\\" + e);\\n                }\\n            }\\n            return ret;\\n        };\\n        if (tag.tagConstructed) {\\n            // must have valid content\\n            sub = getSub();\\n        }\\n        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {\\n            // sometimes BitString and OctetString are used to encapsulate ASN.1\\n            try {\\n                if (tag.tagNumber == 0x03) {\\n                    if (stream.get() != 0) {\\n                        throw new Error(\\\"BIT STRINGs with unused bits cannot encapsulate.\\\");\\n                    }\\n                }\\n                sub = getSub();\\n                for (var i = 0; i < sub.length; ++i) {\\n                    if (sub[i].tag.isEOC()) {\\n                        throw new Error(\\\"EOC is not supposed to be actual content.\\\");\\n                    }\\n                }\\n            }\\n            catch (e) {\\n                // but silently ignore when they don't\\n                sub = null;\\n            }\\n        }\\n        if (sub === null) {\\n            if (len === null) {\\n                throw new Error(\\\"We can't skip over an invalid tag with undefined length at offset \\\" + start);\\n            }\\n            stream.pos = start + Math.abs(len);\\n        }\\n        return new ASN1(streamStart, header, len, tag, sub);\\n    };\\n    return ASN1;\\n}());\\n\\nvar ASN1Tag = /** @class */ (function () {\\n    function ASN1Tag(stream) {\\n        var buf = stream.get();\\n        this.tagClass = buf >> 6;\\n        this.tagConstructed = ((buf & 0x20) !== 0);\\n        this.tagNumber = buf & 0x1F;\\n        if (this.tagNumber == 0x1F) { // long tag\\n            var n = new _int10__WEBPACK_IMPORTED_MODULE_0__.Int10();\\n            do {\\n                buf = stream.get();\\n                n.mulAdd(128, buf & 0x7F);\\n            } while (buf & 0x80);\\n            this.tagNumber = n.simplify();\\n        }\\n    }\\n    ASN1Tag.prototype.isUniversal = function () {\\n        return this.tagClass === 0x00;\\n    };\\n    ASN1Tag.prototype.isEOC = function () {\\n        return this.tagClass === 0x00 && this.tagNumber === 0x00;\\n    };\\n    return ASN1Tag;\\n}());\\n\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/asn1js/asn1.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/asn1js/base64.js\":\n/*!**********************************!*\\\n  !*** ./lib/lib/asn1js/base64.js ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Base64\\\": () => (/* binding */ Base64)\\n/* harmony export */ });\\n// Base64 JavaScript decoder\\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\\n// Permission to use, copy, modify, and/or distribute this software for any\\n// purpose with or without fee is hereby granted, provided that the above\\n// copyright notice and this permission notice appear in all copies.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\\nvar decoder;\\nvar Base64 = {\\n    decode: function (a) {\\n        var i;\\n        if (decoder === undefined) {\\n            var b64 = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n            var ignore = \\\"= \\\\f\\\\n\\\\r\\\\t\\\\u00A0\\\\u2028\\\\u2029\\\";\\n            decoder = Object.create(null);\\n            for (i = 0; i < 64; ++i) {\\n                decoder[b64.charAt(i)] = i;\\n            }\\n            decoder['-'] = 62; //+\\n            decoder['_'] = 63; //-\\n            for (i = 0; i < ignore.length; ++i) {\\n                decoder[ignore.charAt(i)] = -1;\\n            }\\n        }\\n        var out = [];\\n        var bits = 0;\\n        var char_count = 0;\\n        for (i = 0; i < a.length; ++i) {\\n            var c = a.charAt(i);\\n            if (c == \\\"=\\\") {\\n                break;\\n            }\\n            c = decoder[c];\\n            if (c == -1) {\\n                continue;\\n            }\\n            if (c === undefined) {\\n                throw new Error(\\\"Illegal character at offset \\\" + i);\\n            }\\n            bits |= c;\\n            if (++char_count >= 4) {\\n                out[out.length] = (bits >> 16);\\n                out[out.length] = (bits >> 8) & 0xFF;\\n                out[out.length] = bits & 0xFF;\\n                bits = 0;\\n                char_count = 0;\\n            }\\n            else {\\n                bits <<= 6;\\n            }\\n        }\\n        switch (char_count) {\\n            case 1:\\n                throw new Error(\\\"Base64 encoding incomplete: at least 2 bits missing\\\");\\n            case 2:\\n                out[out.length] = (bits >> 10);\\n                break;\\n            case 3:\\n                out[out.length] = (bits >> 16);\\n                out[out.length] = (bits >> 8) & 0xFF;\\n                break;\\n        }\\n        return out;\\n    },\\n    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\\\\/=\\\\s]+)-----END [^-]+-----|begin-base64[^\\\\n]+\\\\n([A-Za-z0-9+\\\\/=\\\\s]+)====/,\\n    unarmor: function (a) {\\n        var m = Base64.re.exec(a);\\n        if (m) {\\n            if (m[1]) {\\n                a = m[1];\\n            }\\n            else if (m[2]) {\\n                a = m[2];\\n            }\\n            else {\\n                throw new Error(\\\"RegExp out of sync\\\");\\n            }\\n        }\\n        return Base64.decode(a);\\n    }\\n};\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/asn1js/base64.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/asn1js/hex.js\":\n/*!*******************************!*\\\n  !*** ./lib/lib/asn1js/hex.js ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Hex\\\": () => (/* binding */ Hex)\\n/* harmony export */ });\\n// Hex JavaScript decoder\\n// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>\\n// Permission to use, copy, modify, and/or distribute this software for any\\n// purpose with or without fee is hereby granted, provided that the above\\n// copyright notice and this permission notice appear in all copies.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\\nvar decoder;\\nvar Hex = {\\n    decode: function (a) {\\n        var i;\\n        if (decoder === undefined) {\\n            var hex = \\\"0123456789ABCDEF\\\";\\n            var ignore = \\\" \\\\f\\\\n\\\\r\\\\t\\\\u00A0\\\\u2028\\\\u2029\\\";\\n            decoder = {};\\n            for (i = 0; i < 16; ++i) {\\n                decoder[hex.charAt(i)] = i;\\n            }\\n            hex = hex.toLowerCase();\\n            for (i = 10; i < 16; ++i) {\\n                decoder[hex.charAt(i)] = i;\\n            }\\n            for (i = 0; i < ignore.length; ++i) {\\n                decoder[ignore.charAt(i)] = -1;\\n            }\\n        }\\n        var out = [];\\n        var bits = 0;\\n        var char_count = 0;\\n        for (i = 0; i < a.length; ++i) {\\n            var c = a.charAt(i);\\n            if (c == \\\"=\\\") {\\n                break;\\n            }\\n            c = decoder[c];\\n            if (c == -1) {\\n                continue;\\n            }\\n            if (c === undefined) {\\n                throw new Error(\\\"Illegal character at offset \\\" + i);\\n            }\\n            bits |= c;\\n            if (++char_count >= 2) {\\n                out[out.length] = bits;\\n                bits = 0;\\n                char_count = 0;\\n            }\\n            else {\\n                bits <<= 4;\\n            }\\n        }\\n        if (char_count) {\\n            throw new Error(\\\"Hex encoding incomplete: 4 bits missing\\\");\\n        }\\n        return out;\\n    }\\n};\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/asn1js/hex.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/asn1js/int10.js\":\n/*!*********************************!*\\\n  !*** ./lib/lib/asn1js/int10.js ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Int10\\\": () => (/* binding */ Int10)\\n/* harmony export */ });\\n// Big integer base-10 printing library\\n// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>\\n// Permission to use, copy, modify, and/or distribute this software for any\\n// purpose with or without fee is hereby granted, provided that the above\\n// copyright notice and this permission notice appear in all copies.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\\n/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */\\nvar max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256\\nvar Int10 = /** @class */ (function () {\\n    function Int10(value) {\\n        this.buf = [+value || 0];\\n    }\\n    Int10.prototype.mulAdd = function (m, c) {\\n        // assert(m <= 256)\\n        var b = this.buf;\\n        var l = b.length;\\n        var i;\\n        var t;\\n        for (i = 0; i < l; ++i) {\\n            t = b[i] * m + c;\\n            if (t < max) {\\n                c = 0;\\n            }\\n            else {\\n                c = 0 | (t / max);\\n                t -= c * max;\\n            }\\n            b[i] = t;\\n        }\\n        if (c > 0) {\\n            b[i] = c;\\n        }\\n    };\\n    Int10.prototype.sub = function (c) {\\n        // assert(m <= 256)\\n        var b = this.buf;\\n        var l = b.length;\\n        var i;\\n        var t;\\n        for (i = 0; i < l; ++i) {\\n            t = b[i] - c;\\n            if (t < 0) {\\n                t += max;\\n                c = 1;\\n            }\\n            else {\\n                c = 0;\\n            }\\n            b[i] = t;\\n        }\\n        while (b[b.length - 1] === 0) {\\n            b.pop();\\n        }\\n    };\\n    Int10.prototype.toString = function (base) {\\n        if ((base || 10) != 10) {\\n            throw new Error(\\\"only base 10 is supported\\\");\\n        }\\n        var b = this.buf;\\n        var s = b[b.length - 1].toString();\\n        for (var i = b.length - 2; i >= 0; --i) {\\n            s += (max + b[i]).toString().substring(1);\\n        }\\n        return s;\\n    };\\n    Int10.prototype.valueOf = function () {\\n        var b = this.buf;\\n        var v = 0;\\n        for (var i = b.length - 1; i >= 0; --i) {\\n            v = v * max + b[i];\\n        }\\n        return v;\\n    };\\n    Int10.prototype.simplify = function () {\\n        var b = this.buf;\\n        return (b.length == 1) ? b[0] : this;\\n    };\\n    return Int10;\\n}());\\n\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/asn1js/int10.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/base64.js\":\n/*!********************************!*\\\n  !*** ./lib/lib/jsbn/base64.js ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"b64toBA\\\": () => (/* binding */ b64toBA),\\n/* harmony export */   \\\"b64tohex\\\": () => (/* binding */ b64tohex),\\n/* harmony export */   \\\"hex2b64\\\": () => (/* binding */ hex2b64)\\n/* harmony export */ });\\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \\\"./lib/lib/jsbn/util.js\\\");\\n\\nvar b64map = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\nvar b64pad = \\\"=\\\";\\nfunction hex2b64(h) {\\n    var i;\\n    var c;\\n    var ret = \\\"\\\";\\n    for (i = 0; i + 3 <= h.length; i += 3) {\\n        c = parseInt(h.substring(i, i + 3), 16);\\n        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\\n    }\\n    if (i + 1 == h.length) {\\n        c = parseInt(h.substring(i, i + 1), 16);\\n        ret += b64map.charAt(c << 2);\\n    }\\n    else if (i + 2 == h.length) {\\n        c = parseInt(h.substring(i, i + 2), 16);\\n        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\\n    }\\n    while ((ret.length & 3) > 0) {\\n        ret += b64pad;\\n    }\\n    return ret;\\n}\\n// convert a base64 string to hex\\nfunction b64tohex(s) {\\n    var ret = \\\"\\\";\\n    var i;\\n    var k = 0; // b64 state, 0-3\\n    var slop = 0;\\n    for (i = 0; i < s.length; ++i) {\\n        if (s.charAt(i) == b64pad) {\\n            break;\\n        }\\n        var v = b64map.indexOf(s.charAt(i));\\n        if (v < 0) {\\n            continue;\\n        }\\n        if (k == 0) {\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v >> 2);\\n            slop = v & 3;\\n            k = 1;\\n        }\\n        else if (k == 1) {\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)((slop << 2) | (v >> 4));\\n            slop = v & 0xf;\\n            k = 2;\\n        }\\n        else if (k == 2) {\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop);\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v >> 2);\\n            slop = v & 3;\\n            k = 3;\\n        }\\n        else {\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)((slop << 2) | (v >> 4));\\n            ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(v & 0xf);\\n            k = 0;\\n        }\\n    }\\n    if (k == 1) {\\n        ret += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(slop << 2);\\n    }\\n    return ret;\\n}\\n// convert a base64 string to a byte/number array\\nfunction b64toBA(s) {\\n    // piggyback on b64tohex for now, optimize later\\n    var h = b64tohex(s);\\n    var i;\\n    var a = [];\\n    for (i = 0; 2 * i < h.length; ++i) {\\n        a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);\\n    }\\n    return a;\\n}\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/base64.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/jsbn.js\":\n/*!******************************!*\\\n  !*** ./lib/lib/jsbn/jsbn.js ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"BigInteger\\\": () => (/* binding */ BigInteger),\\n/* harmony export */   \\\"intAt\\\": () => (/* binding */ intAt),\\n/* harmony export */   \\\"nbi\\\": () => (/* binding */ nbi),\\n/* harmony export */   \\\"nbits\\\": () => (/* binding */ nbits),\\n/* harmony export */   \\\"nbv\\\": () => (/* binding */ nbv),\\n/* harmony export */   \\\"parseBigInt\\\": () => (/* binding */ parseBigInt)\\n/* harmony export */ });\\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \\\"./lib/lib/jsbn/util.js\\\");\\n// Copyright (c) 2005  Tom Wu\\n// All Rights Reserved.\\n// See \\\"LICENSE\\\" for details.\\n// Basic JavaScript BN library - subset useful for RSA encryption.\\n\\n// Bits per digit\\nvar dbits;\\n// JavaScript engine analysis\\nvar canary = 0xdeadbeefcafe;\\nvar j_lm = ((canary & 0xffffff) == 0xefcafe);\\n//#region\\nvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\\n//#endregion\\n// (public) Constructor\\nvar BigInteger = /** @class */ (function () {\\n    function BigInteger(a, b, c) {\\n        if (a != null) {\\n            if (\\\"number\\\" == typeof a) {\\n                this.fromNumber(a, b, c);\\n            }\\n            else if (b == null && \\\"string\\\" != typeof a) {\\n                this.fromString(a, 256);\\n            }\\n            else {\\n                this.fromString(a, b);\\n            }\\n        }\\n    }\\n    //#region PUBLIC\\n    // BigInteger.prototype.toString = bnToString;\\n    // (public) return string representation in given radix\\n    BigInteger.prototype.toString = function (b) {\\n        if (this.s < 0) {\\n            return \\\"-\\\" + this.negate().toString(b);\\n        }\\n        var k;\\n        if (b == 16) {\\n            k = 4;\\n        }\\n        else if (b == 8) {\\n            k = 3;\\n        }\\n        else if (b == 2) {\\n            k = 1;\\n        }\\n        else if (b == 32) {\\n            k = 5;\\n        }\\n        else if (b == 4) {\\n            k = 2;\\n        }\\n        else {\\n            return this.toRadix(b);\\n        }\\n        var km = (1 << k) - 1;\\n        var d;\\n        var m = false;\\n        var r = \\\"\\\";\\n        var i = this.t;\\n        var p = this.DB - (i * this.DB) % k;\\n        if (i-- > 0) {\\n            if (p < this.DB && (d = this[i] >> p) > 0) {\\n                m = true;\\n                r = (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(d);\\n            }\\n            while (i >= 0) {\\n                if (p < k) {\\n                    d = (this[i] & ((1 << p) - 1)) << (k - p);\\n                    d |= this[--i] >> (p += this.DB - k);\\n                }\\n                else {\\n                    d = (this[i] >> (p -= k)) & km;\\n                    if (p <= 0) {\\n                        p += this.DB;\\n                        --i;\\n                    }\\n                }\\n                if (d > 0) {\\n                    m = true;\\n                }\\n                if (m) {\\n                    r += (0,_util__WEBPACK_IMPORTED_MODULE_0__.int2char)(d);\\n                }\\n            }\\n        }\\n        return m ? r : \\\"0\\\";\\n    };\\n    // BigInteger.prototype.negate = bnNegate;\\n    // (public) -this\\n    BigInteger.prototype.negate = function () {\\n        var r = nbi();\\n        BigInteger.ZERO.subTo(this, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.abs = bnAbs;\\n    // (public) |this|\\n    BigInteger.prototype.abs = function () {\\n        return (this.s < 0) ? this.negate() : this;\\n    };\\n    // BigInteger.prototype.compareTo = bnCompareTo;\\n    // (public) return + if this > a, - if this < a, 0 if equal\\n    BigInteger.prototype.compareTo = function (a) {\\n        var r = this.s - a.s;\\n        if (r != 0) {\\n            return r;\\n        }\\n        var i = this.t;\\n        r = i - a.t;\\n        if (r != 0) {\\n            return (this.s < 0) ? -r : r;\\n        }\\n        while (--i >= 0) {\\n            if ((r = this[i] - a[i]) != 0) {\\n                return r;\\n            }\\n        }\\n        return 0;\\n    };\\n    // BigInteger.prototype.bitLength = bnBitLength;\\n    // (public) return the number of bits in \\\"this\\\"\\n    BigInteger.prototype.bitLength = function () {\\n        if (this.t <= 0) {\\n            return 0;\\n        }\\n        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\\n    };\\n    // BigInteger.prototype.mod = bnMod;\\n    // (public) this mod a\\n    BigInteger.prototype.mod = function (a) {\\n        var r = nbi();\\n        this.abs().divRemTo(a, null, r);\\n        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {\\n            a.subTo(r, r);\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.modPowInt = bnModPowInt;\\n    // (public) this^e % m, 0 <= e < 2^32\\n    BigInteger.prototype.modPowInt = function (e, m) {\\n        var z;\\n        if (e < 256 || m.isEven()) {\\n            z = new Classic(m);\\n        }\\n        else {\\n            z = new Montgomery(m);\\n        }\\n        return this.exp(e, z);\\n    };\\n    // BigInteger.prototype.clone = bnClone;\\n    // (public)\\n    BigInteger.prototype.clone = function () {\\n        var r = nbi();\\n        this.copyTo(r);\\n        return r;\\n    };\\n    // BigInteger.prototype.intValue = bnIntValue;\\n    // (public) return value as integer\\n    BigInteger.prototype.intValue = function () {\\n        if (this.s < 0) {\\n            if (this.t == 1) {\\n                return this[0] - this.DV;\\n            }\\n            else if (this.t == 0) {\\n                return -1;\\n            }\\n        }\\n        else if (this.t == 1) {\\n            return this[0];\\n        }\\n        else if (this.t == 0) {\\n            return 0;\\n        }\\n        // assumes 16 < DB < 32\\n        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\\n    };\\n    // BigInteger.prototype.byteValue = bnByteValue;\\n    // (public) return value as byte\\n    BigInteger.prototype.byteValue = function () {\\n        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\\n    };\\n    // BigInteger.prototype.shortValue = bnShortValue;\\n    // (public) return value as short (assumes DB>=16)\\n    BigInteger.prototype.shortValue = function () {\\n        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\\n    };\\n    // BigInteger.prototype.signum = bnSigNum;\\n    // (public) 0 if this == 0, 1 if this > 0\\n    BigInteger.prototype.signum = function () {\\n        if (this.s < 0) {\\n            return -1;\\n        }\\n        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {\\n            return 0;\\n        }\\n        else {\\n            return 1;\\n        }\\n    };\\n    // BigInteger.prototype.toByteArray = bnToByteArray;\\n    // (public) convert to bigendian byte array\\n    BigInteger.prototype.toByteArray = function () {\\n        var i = this.t;\\n        var r = [];\\n        r[0] = this.s;\\n        var p = this.DB - (i * this.DB) % 8;\\n        var d;\\n        var k = 0;\\n        if (i-- > 0) {\\n            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {\\n                r[k++] = d | (this.s << (this.DB - p));\\n            }\\n            while (i >= 0) {\\n                if (p < 8) {\\n                    d = (this[i] & ((1 << p) - 1)) << (8 - p);\\n                    d |= this[--i] >> (p += this.DB - 8);\\n                }\\n                else {\\n                    d = (this[i] >> (p -= 8)) & 0xff;\\n                    if (p <= 0) {\\n                        p += this.DB;\\n                        --i;\\n                    }\\n                }\\n                if ((d & 0x80) != 0) {\\n                    d |= -256;\\n                }\\n                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {\\n                    ++k;\\n                }\\n                if (k > 0 || d != this.s) {\\n                    r[k++] = d;\\n                }\\n            }\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.equals = bnEquals;\\n    BigInteger.prototype.equals = function (a) {\\n        return (this.compareTo(a) == 0);\\n    };\\n    // BigInteger.prototype.min = bnMin;\\n    BigInteger.prototype.min = function (a) {\\n        return (this.compareTo(a) < 0) ? this : a;\\n    };\\n    // BigInteger.prototype.max = bnMax;\\n    BigInteger.prototype.max = function (a) {\\n        return (this.compareTo(a) > 0) ? this : a;\\n    };\\n    // BigInteger.prototype.and = bnAnd;\\n    BigInteger.prototype.and = function (a) {\\n        var r = nbi();\\n        this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_and, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.or = bnOr;\\n    BigInteger.prototype.or = function (a) {\\n        var r = nbi();\\n        this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_or, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.xor = bnXor;\\n    BigInteger.prototype.xor = function (a) {\\n        var r = nbi();\\n        this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_xor, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.andNot = bnAndNot;\\n    BigInteger.prototype.andNot = function (a) {\\n        var r = nbi();\\n        this.bitwiseTo(a, _util__WEBPACK_IMPORTED_MODULE_0__.op_andnot, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.not = bnNot;\\n    // (public) ~this\\n    BigInteger.prototype.not = function () {\\n        var r = nbi();\\n        for (var i = 0; i < this.t; ++i) {\\n            r[i] = this.DM & ~this[i];\\n        }\\n        r.t = this.t;\\n        r.s = ~this.s;\\n        return r;\\n    };\\n    // BigInteger.prototype.shiftLeft = bnShiftLeft;\\n    // (public) this << n\\n    BigInteger.prototype.shiftLeft = function (n) {\\n        var r = nbi();\\n        if (n < 0) {\\n            this.rShiftTo(-n, r);\\n        }\\n        else {\\n            this.lShiftTo(n, r);\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.shiftRight = bnShiftRight;\\n    // (public) this >> n\\n    BigInteger.prototype.shiftRight = function (n) {\\n        var r = nbi();\\n        if (n < 0) {\\n            this.lShiftTo(-n, r);\\n        }\\n        else {\\n            this.rShiftTo(n, r);\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\\n    // (public) returns index of lowest 1-bit (or -1 if none)\\n    BigInteger.prototype.getLowestSetBit = function () {\\n        for (var i = 0; i < this.t; ++i) {\\n            if (this[i] != 0) {\\n                return i * this.DB + (0,_util__WEBPACK_IMPORTED_MODULE_0__.lbit)(this[i]);\\n            }\\n        }\\n        if (this.s < 0) {\\n            return this.t * this.DB;\\n        }\\n        return -1;\\n    };\\n    // BigInteger.prototype.bitCount = bnBitCount;\\n    // (public) return number of set bits\\n    BigInteger.prototype.bitCount = function () {\\n        var r = 0;\\n        var x = this.s & this.DM;\\n        for (var i = 0; i < this.t; ++i) {\\n            r += (0,_util__WEBPACK_IMPORTED_MODULE_0__.cbit)(this[i] ^ x);\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.testBit = bnTestBit;\\n    // (public) true iff nth bit is set\\n    BigInteger.prototype.testBit = function (n) {\\n        var j = Math.floor(n / this.DB);\\n        if (j >= this.t) {\\n            return (this.s != 0);\\n        }\\n        return ((this[j] & (1 << (n % this.DB))) != 0);\\n    };\\n    // BigInteger.prototype.setBit = bnSetBit;\\n    // (public) this | (1<<n)\\n    BigInteger.prototype.setBit = function (n) {\\n        return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_or);\\n    };\\n    // BigInteger.prototype.clearBit = bnClearBit;\\n    // (public) this & ~(1<<n)\\n    BigInteger.prototype.clearBit = function (n) {\\n        return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_andnot);\\n    };\\n    // BigInteger.prototype.flipBit = bnFlipBit;\\n    // (public) this ^ (1<<n)\\n    BigInteger.prototype.flipBit = function (n) {\\n        return this.changeBit(n, _util__WEBPACK_IMPORTED_MODULE_0__.op_xor);\\n    };\\n    // BigInteger.prototype.add = bnAdd;\\n    // (public) this + a\\n    BigInteger.prototype.add = function (a) {\\n        var r = nbi();\\n        this.addTo(a, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.subtract = bnSubtract;\\n    // (public) this - a\\n    BigInteger.prototype.subtract = function (a) {\\n        var r = nbi();\\n        this.subTo(a, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.multiply = bnMultiply;\\n    // (public) this * a\\n    BigInteger.prototype.multiply = function (a) {\\n        var r = nbi();\\n        this.multiplyTo(a, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.divide = bnDivide;\\n    // (public) this / a\\n    BigInteger.prototype.divide = function (a) {\\n        var r = nbi();\\n        this.divRemTo(a, r, null);\\n        return r;\\n    };\\n    // BigInteger.prototype.remainder = bnRemainder;\\n    // (public) this % a\\n    BigInteger.prototype.remainder = function (a) {\\n        var r = nbi();\\n        this.divRemTo(a, null, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\\n    // (public) [this/a,this%a]\\n    BigInteger.prototype.divideAndRemainder = function (a) {\\n        var q = nbi();\\n        var r = nbi();\\n        this.divRemTo(a, q, r);\\n        return [q, r];\\n    };\\n    // BigInteger.prototype.modPow = bnModPow;\\n    // (public) this^e % m (HAC 14.85)\\n    BigInteger.prototype.modPow = function (e, m) {\\n        var i = e.bitLength();\\n        var k;\\n        var r = nbv(1);\\n        var z;\\n        if (i <= 0) {\\n            return r;\\n        }\\n        else if (i < 18) {\\n            k = 1;\\n        }\\n        else if (i < 48) {\\n            k = 3;\\n        }\\n        else if (i < 144) {\\n            k = 4;\\n        }\\n        else if (i < 768) {\\n            k = 5;\\n        }\\n        else {\\n            k = 6;\\n        }\\n        if (i < 8) {\\n            z = new Classic(m);\\n        }\\n        else if (m.isEven()) {\\n            z = new Barrett(m);\\n        }\\n        else {\\n            z = new Montgomery(m);\\n        }\\n        // precomputation\\n        var g = [];\\n        var n = 3;\\n        var k1 = k - 1;\\n        var km = (1 << k) - 1;\\n        g[1] = z.convert(this);\\n        if (k > 1) {\\n            var g2 = nbi();\\n            z.sqrTo(g[1], g2);\\n            while (n <= km) {\\n                g[n] = nbi();\\n                z.mulTo(g2, g[n - 2], g[n]);\\n                n += 2;\\n            }\\n        }\\n        var j = e.t - 1;\\n        var w;\\n        var is1 = true;\\n        var r2 = nbi();\\n        var t;\\n        i = nbits(e[j]) - 1;\\n        while (j >= 0) {\\n            if (i >= k1) {\\n                w = (e[j] >> (i - k1)) & km;\\n            }\\n            else {\\n                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\\n                if (j > 0) {\\n                    w |= e[j - 1] >> (this.DB + i - k1);\\n                }\\n            }\\n            n = k;\\n            while ((w & 1) == 0) {\\n                w >>= 1;\\n                --n;\\n            }\\n            if ((i -= n) < 0) {\\n                i += this.DB;\\n                --j;\\n            }\\n            if (is1) { // ret == 1, don't bother squaring or multiplying it\\n                g[w].copyTo(r);\\n                is1 = false;\\n            }\\n            else {\\n                while (n > 1) {\\n                    z.sqrTo(r, r2);\\n                    z.sqrTo(r2, r);\\n                    n -= 2;\\n                }\\n                if (n > 0) {\\n                    z.sqrTo(r, r2);\\n                }\\n                else {\\n                    t = r;\\n                    r = r2;\\n                    r2 = t;\\n                }\\n                z.mulTo(r2, g[w], r);\\n            }\\n            while (j >= 0 && (e[j] & (1 << i)) == 0) {\\n                z.sqrTo(r, r2);\\n                t = r;\\n                r = r2;\\n                r2 = t;\\n                if (--i < 0) {\\n                    i = this.DB - 1;\\n                    --j;\\n                }\\n            }\\n        }\\n        return z.revert(r);\\n    };\\n    // BigInteger.prototype.modInverse = bnModInverse;\\n    // (public) 1/this % m (HAC 14.61)\\n    BigInteger.prototype.modInverse = function (m) {\\n        var ac = m.isEven();\\n        if ((this.isEven() && ac) || m.signum() == 0) {\\n            return BigInteger.ZERO;\\n        }\\n        var u = m.clone();\\n        var v = this.clone();\\n        var a = nbv(1);\\n        var b = nbv(0);\\n        var c = nbv(0);\\n        var d = nbv(1);\\n        while (u.signum() != 0) {\\n            while (u.isEven()) {\\n                u.rShiftTo(1, u);\\n                if (ac) {\\n                    if (!a.isEven() || !b.isEven()) {\\n                        a.addTo(this, a);\\n                        b.subTo(m, b);\\n                    }\\n                    a.rShiftTo(1, a);\\n                }\\n                else if (!b.isEven()) {\\n                    b.subTo(m, b);\\n                }\\n                b.rShiftTo(1, b);\\n            }\\n            while (v.isEven()) {\\n                v.rShiftTo(1, v);\\n                if (ac) {\\n                    if (!c.isEven() || !d.isEven()) {\\n                        c.addTo(this, c);\\n                        d.subTo(m, d);\\n                    }\\n                    c.rShiftTo(1, c);\\n                }\\n                else if (!d.isEven()) {\\n                    d.subTo(m, d);\\n                }\\n                d.rShiftTo(1, d);\\n            }\\n            if (u.compareTo(v) >= 0) {\\n                u.subTo(v, u);\\n                if (ac) {\\n                    a.subTo(c, a);\\n                }\\n                b.subTo(d, b);\\n            }\\n            else {\\n                v.subTo(u, v);\\n                if (ac) {\\n                    c.subTo(a, c);\\n                }\\n                d.subTo(b, d);\\n            }\\n        }\\n        if (v.compareTo(BigInteger.ONE) != 0) {\\n            return BigInteger.ZERO;\\n        }\\n        if (d.compareTo(m) >= 0) {\\n            return d.subtract(m);\\n        }\\n        if (d.signum() < 0) {\\n            d.addTo(m, d);\\n        }\\n        else {\\n            return d;\\n        }\\n        if (d.signum() < 0) {\\n            return d.add(m);\\n        }\\n        else {\\n            return d;\\n        }\\n    };\\n    // BigInteger.prototype.pow = bnPow;\\n    // (public) this^e\\n    BigInteger.prototype.pow = function (e) {\\n        return this.exp(e, new NullExp());\\n    };\\n    // BigInteger.prototype.gcd = bnGCD;\\n    // (public) gcd(this,a) (HAC 14.54)\\n    BigInteger.prototype.gcd = function (a) {\\n        var x = (this.s < 0) ? this.negate() : this.clone();\\n        var y = (a.s < 0) ? a.negate() : a.clone();\\n        if (x.compareTo(y) < 0) {\\n            var t = x;\\n            x = y;\\n            y = t;\\n        }\\n        var i = x.getLowestSetBit();\\n        var g = y.getLowestSetBit();\\n        if (g < 0) {\\n            return x;\\n        }\\n        if (i < g) {\\n            g = i;\\n        }\\n        if (g > 0) {\\n            x.rShiftTo(g, x);\\n            y.rShiftTo(g, y);\\n        }\\n        while (x.signum() > 0) {\\n            if ((i = x.getLowestSetBit()) > 0) {\\n                x.rShiftTo(i, x);\\n            }\\n            if ((i = y.getLowestSetBit()) > 0) {\\n                y.rShiftTo(i, y);\\n            }\\n            if (x.compareTo(y) >= 0) {\\n                x.subTo(y, x);\\n                x.rShiftTo(1, x);\\n            }\\n            else {\\n                y.subTo(x, y);\\n                y.rShiftTo(1, y);\\n            }\\n        }\\n        if (g > 0) {\\n            y.lShiftTo(g, y);\\n        }\\n        return y;\\n    };\\n    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\\n    // (public) test primality with certainty >= 1-.5^t\\n    BigInteger.prototype.isProbablePrime = function (t) {\\n        var i;\\n        var x = this.abs();\\n        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {\\n            for (i = 0; i < lowprimes.length; ++i) {\\n                if (x[0] == lowprimes[i]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        if (x.isEven()) {\\n            return false;\\n        }\\n        i = 1;\\n        while (i < lowprimes.length) {\\n            var m = lowprimes[i];\\n            var j = i + 1;\\n            while (j < lowprimes.length && m < lplim) {\\n                m *= lowprimes[j++];\\n            }\\n            m = x.modInt(m);\\n            while (i < j) {\\n                if (m % lowprimes[i++] == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return x.millerRabin(t);\\n    };\\n    //#endregion PUBLIC\\n    //#region PROTECTED\\n    // BigInteger.prototype.copyTo = bnpCopyTo;\\n    // (protected) copy this to r\\n    BigInteger.prototype.copyTo = function (r) {\\n        for (var i = this.t - 1; i >= 0; --i) {\\n            r[i] = this[i];\\n        }\\n        r.t = this.t;\\n        r.s = this.s;\\n    };\\n    // BigInteger.prototype.fromInt = bnpFromInt;\\n    // (protected) set from integer value x, -DV <= x < DV\\n    BigInteger.prototype.fromInt = function (x) {\\n        this.t = 1;\\n        this.s = (x < 0) ? -1 : 0;\\n        if (x > 0) {\\n            this[0] = x;\\n        }\\n        else if (x < -1) {\\n            this[0] = x + this.DV;\\n        }\\n        else {\\n            this.t = 0;\\n        }\\n    };\\n    // BigInteger.prototype.fromString = bnpFromString;\\n    // (protected) set from string and radix\\n    BigInteger.prototype.fromString = function (s, b) {\\n        var k;\\n        if (b == 16) {\\n            k = 4;\\n        }\\n        else if (b == 8) {\\n            k = 3;\\n        }\\n        else if (b == 256) {\\n            k = 8;\\n            /* byte array */\\n        }\\n        else if (b == 2) {\\n            k = 1;\\n        }\\n        else if (b == 32) {\\n            k = 5;\\n        }\\n        else if (b == 4) {\\n            k = 2;\\n        }\\n        else {\\n            this.fromRadix(s, b);\\n            return;\\n        }\\n        this.t = 0;\\n        this.s = 0;\\n        var i = s.length;\\n        var mi = false;\\n        var sh = 0;\\n        while (--i >= 0) {\\n            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);\\n            if (x < 0) {\\n                if (s.charAt(i) == \\\"-\\\") {\\n                    mi = true;\\n                }\\n                continue;\\n            }\\n            mi = false;\\n            if (sh == 0) {\\n                this[this.t++] = x;\\n            }\\n            else if (sh + k > this.DB) {\\n                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\\n                this[this.t++] = (x >> (this.DB - sh));\\n            }\\n            else {\\n                this[this.t - 1] |= x << sh;\\n            }\\n            sh += k;\\n            if (sh >= this.DB) {\\n                sh -= this.DB;\\n            }\\n        }\\n        if (k == 8 && ((+s[0]) & 0x80) != 0) {\\n            this.s = -1;\\n            if (sh > 0) {\\n                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\\n            }\\n        }\\n        this.clamp();\\n        if (mi) {\\n            BigInteger.ZERO.subTo(this, this);\\n        }\\n    };\\n    // BigInteger.prototype.clamp = bnpClamp;\\n    // (protected) clamp off excess high words\\n    BigInteger.prototype.clamp = function () {\\n        var c = this.s & this.DM;\\n        while (this.t > 0 && this[this.t - 1] == c) {\\n            --this.t;\\n        }\\n    };\\n    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\\n    // (protected) r = this << n*DB\\n    BigInteger.prototype.dlShiftTo = function (n, r) {\\n        var i;\\n        for (i = this.t - 1; i >= 0; --i) {\\n            r[i + n] = this[i];\\n        }\\n        for (i = n - 1; i >= 0; --i) {\\n            r[i] = 0;\\n        }\\n        r.t = this.t + n;\\n        r.s = this.s;\\n    };\\n    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;\\n    // (protected) r = this >> n*DB\\n    BigInteger.prototype.drShiftTo = function (n, r) {\\n        for (var i = n; i < this.t; ++i) {\\n            r[i - n] = this[i];\\n        }\\n        r.t = Math.max(this.t - n, 0);\\n        r.s = this.s;\\n    };\\n    // BigInteger.prototype.lShiftTo = bnpLShiftTo;\\n    // (protected) r = this << n\\n    BigInteger.prototype.lShiftTo = function (n, r) {\\n        var bs = n % this.DB;\\n        var cbs = this.DB - bs;\\n        var bm = (1 << cbs) - 1;\\n        var ds = Math.floor(n / this.DB);\\n        var c = (this.s << bs) & this.DM;\\n        for (var i = this.t - 1; i >= 0; --i) {\\n            r[i + ds + 1] = (this[i] >> cbs) | c;\\n            c = (this[i] & bm) << bs;\\n        }\\n        for (var i = ds - 1; i >= 0; --i) {\\n            r[i] = 0;\\n        }\\n        r[ds] = c;\\n        r.t = this.t + ds + 1;\\n        r.s = this.s;\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.rShiftTo = bnpRShiftTo;\\n    // (protected) r = this >> n\\n    BigInteger.prototype.rShiftTo = function (n, r) {\\n        r.s = this.s;\\n        var ds = Math.floor(n / this.DB);\\n        if (ds >= this.t) {\\n            r.t = 0;\\n            return;\\n        }\\n        var bs = n % this.DB;\\n        var cbs = this.DB - bs;\\n        var bm = (1 << bs) - 1;\\n        r[0] = this[ds] >> bs;\\n        for (var i = ds + 1; i < this.t; ++i) {\\n            r[i - ds - 1] |= (this[i] & bm) << cbs;\\n            r[i - ds] = this[i] >> bs;\\n        }\\n        if (bs > 0) {\\n            r[this.t - ds - 1] |= (this.s & bm) << cbs;\\n        }\\n        r.t = this.t - ds;\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.subTo = bnpSubTo;\\n    // (protected) r = this - a\\n    BigInteger.prototype.subTo = function (a, r) {\\n        var i = 0;\\n        var c = 0;\\n        var m = Math.min(a.t, this.t);\\n        while (i < m) {\\n            c += this[i] - a[i];\\n            r[i++] = c & this.DM;\\n            c >>= this.DB;\\n        }\\n        if (a.t < this.t) {\\n            c -= a.s;\\n            while (i < this.t) {\\n                c += this[i];\\n                r[i++] = c & this.DM;\\n                c >>= this.DB;\\n            }\\n            c += this.s;\\n        }\\n        else {\\n            c += this.s;\\n            while (i < a.t) {\\n                c -= a[i];\\n                r[i++] = c & this.DM;\\n                c >>= this.DB;\\n            }\\n            c -= a.s;\\n        }\\n        r.s = (c < 0) ? -1 : 0;\\n        if (c < -1) {\\n            r[i++] = this.DV + c;\\n        }\\n        else if (c > 0) {\\n            r[i++] = c;\\n        }\\n        r.t = i;\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;\\n    // (protected) r = this * a, r != this,a (HAC 14.12)\\n    // \\\"this\\\" should be the larger one if appropriate.\\n    BigInteger.prototype.multiplyTo = function (a, r) {\\n        var x = this.abs();\\n        var y = a.abs();\\n        var i = x.t;\\n        r.t = i + y.t;\\n        while (--i >= 0) {\\n            r[i] = 0;\\n        }\\n        for (i = 0; i < y.t; ++i) {\\n            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\\n        }\\n        r.s = 0;\\n        r.clamp();\\n        if (this.s != a.s) {\\n            BigInteger.ZERO.subTo(r, r);\\n        }\\n    };\\n    // BigInteger.prototype.squareTo = bnpSquareTo;\\n    // (protected) r = this^2, r != this (HAC 14.16)\\n    BigInteger.prototype.squareTo = function (r) {\\n        var x = this.abs();\\n        var i = r.t = 2 * x.t;\\n        while (--i >= 0) {\\n            r[i] = 0;\\n        }\\n        for (i = 0; i < x.t - 1; ++i) {\\n            var c = x.am(i, x[i], r, 2 * i, 0, 1);\\n            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\\n                r[i + x.t] -= x.DV;\\n                r[i + x.t + 1] = 1;\\n            }\\n        }\\n        if (r.t > 0) {\\n            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\\n        }\\n        r.s = 0;\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.divRemTo = bnpDivRemTo;\\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\\n    // r != q, this != m.  q or r may be null.\\n    BigInteger.prototype.divRemTo = function (m, q, r) {\\n        var pm = m.abs();\\n        if (pm.t <= 0) {\\n            return;\\n        }\\n        var pt = this.abs();\\n        if (pt.t < pm.t) {\\n            if (q != null) {\\n                q.fromInt(0);\\n            }\\n            if (r != null) {\\n                this.copyTo(r);\\n            }\\n            return;\\n        }\\n        if (r == null) {\\n            r = nbi();\\n        }\\n        var y = nbi();\\n        var ts = this.s;\\n        var ms = m.s;\\n        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\\n        if (nsh > 0) {\\n            pm.lShiftTo(nsh, y);\\n            pt.lShiftTo(nsh, r);\\n        }\\n        else {\\n            pm.copyTo(y);\\n            pt.copyTo(r);\\n        }\\n        var ys = y.t;\\n        var y0 = y[ys - 1];\\n        if (y0 == 0) {\\n            return;\\n        }\\n        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\\n        var d1 = this.FV / yt;\\n        var d2 = (1 << this.F1) / yt;\\n        var e = 1 << this.F2;\\n        var i = r.t;\\n        var j = i - ys;\\n        var t = (q == null) ? nbi() : q;\\n        y.dlShiftTo(j, t);\\n        if (r.compareTo(t) >= 0) {\\n            r[r.t++] = 1;\\n            r.subTo(t, r);\\n        }\\n        BigInteger.ONE.dlShiftTo(ys, t);\\n        t.subTo(y, y); // \\\"negative\\\" y so we can replace sub with am later\\n        while (y.t < ys) {\\n            y[y.t++] = 0;\\n        }\\n        while (--j >= 0) {\\n            // Estimate quotient digit\\n            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\\n            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out\\n                y.dlShiftTo(j, t);\\n                r.subTo(t, r);\\n                while (r[i] < --qd) {\\n                    r.subTo(t, r);\\n                }\\n            }\\n        }\\n        if (q != null) {\\n            r.drShiftTo(ys, q);\\n            if (ts != ms) {\\n                BigInteger.ZERO.subTo(q, q);\\n            }\\n        }\\n        r.t = ys;\\n        r.clamp();\\n        if (nsh > 0) {\\n            r.rShiftTo(nsh, r);\\n        } // Denormalize remainder\\n        if (ts < 0) {\\n            BigInteger.ZERO.subTo(r, r);\\n        }\\n    };\\n    // BigInteger.prototype.invDigit = bnpInvDigit;\\n    // (protected) return \\\"-1/this % 2^DB\\\"; useful for Mont. reduction\\n    // justification:\\n    //         xy == 1 (mod m)\\n    //         xy =  1+km\\n    //   xy(2-xy) = (1+km)(1-km)\\n    // x[y(2-xy)] = 1-k^2m^2\\n    // x[y(2-xy)] == 1 (mod m^2)\\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\\n    // JS multiply \\\"overflows\\\" differently from C/C++, so care is needed here.\\n    BigInteger.prototype.invDigit = function () {\\n        if (this.t < 1) {\\n            return 0;\\n        }\\n        var x = this[0];\\n        if ((x & 1) == 0) {\\n            return 0;\\n        }\\n        var y = x & 3; // y == 1/x mod 2^2\\n        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\\n        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\\n        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\\n        // last step - calculate inverse mod DV directly;\\n        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\\n        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\\n        // we really want the negative inverse, and -DV < y < DV\\n        return (y > 0) ? this.DV - y : -y;\\n    };\\n    // BigInteger.prototype.isEven = bnpIsEven;\\n    // (protected) true iff this is even\\n    BigInteger.prototype.isEven = function () {\\n        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\\n    };\\n    // BigInteger.prototype.exp = bnpExp;\\n    // (protected) this^e, e < 2^32, doing sqr and mul with \\\"r\\\" (HAC 14.79)\\n    BigInteger.prototype.exp = function (e, z) {\\n        if (e > 0xffffffff || e < 1) {\\n            return BigInteger.ONE;\\n        }\\n        var r = nbi();\\n        var r2 = nbi();\\n        var g = z.convert(this);\\n        var i = nbits(e) - 1;\\n        g.copyTo(r);\\n        while (--i >= 0) {\\n            z.sqrTo(r, r2);\\n            if ((e & (1 << i)) > 0) {\\n                z.mulTo(r2, g, r);\\n            }\\n            else {\\n                var t = r;\\n                r = r2;\\n                r2 = t;\\n            }\\n        }\\n        return z.revert(r);\\n    };\\n    // BigInteger.prototype.chunkSize = bnpChunkSize;\\n    // (protected) return x s.t. r^x < DV\\n    BigInteger.prototype.chunkSize = function (r) {\\n        return Math.floor(Math.LN2 * this.DB / Math.log(r));\\n    };\\n    // BigInteger.prototype.toRadix = bnpToRadix;\\n    // (protected) convert to radix string\\n    BigInteger.prototype.toRadix = function (b) {\\n        if (b == null) {\\n            b = 10;\\n        }\\n        if (this.signum() == 0 || b < 2 || b > 36) {\\n            return \\\"0\\\";\\n        }\\n        var cs = this.chunkSize(b);\\n        var a = Math.pow(b, cs);\\n        var d = nbv(a);\\n        var y = nbi();\\n        var z = nbi();\\n        var r = \\\"\\\";\\n        this.divRemTo(d, y, z);\\n        while (y.signum() > 0) {\\n            r = (a + z.intValue()).toString(b).substr(1) + r;\\n            y.divRemTo(d, y, z);\\n        }\\n        return z.intValue().toString(b) + r;\\n    };\\n    // BigInteger.prototype.fromRadix = bnpFromRadix;\\n    // (protected) convert from radix string\\n    BigInteger.prototype.fromRadix = function (s, b) {\\n        this.fromInt(0);\\n        if (b == null) {\\n            b = 10;\\n        }\\n        var cs = this.chunkSize(b);\\n        var d = Math.pow(b, cs);\\n        var mi = false;\\n        var j = 0;\\n        var w = 0;\\n        for (var i = 0; i < s.length; ++i) {\\n            var x = intAt(s, i);\\n            if (x < 0) {\\n                if (s.charAt(i) == \\\"-\\\" && this.signum() == 0) {\\n                    mi = true;\\n                }\\n                continue;\\n            }\\n            w = b * w + x;\\n            if (++j >= cs) {\\n                this.dMultiply(d);\\n                this.dAddOffset(w, 0);\\n                j = 0;\\n                w = 0;\\n            }\\n        }\\n        if (j > 0) {\\n            this.dMultiply(Math.pow(b, j));\\n            this.dAddOffset(w, 0);\\n        }\\n        if (mi) {\\n            BigInteger.ZERO.subTo(this, this);\\n        }\\n    };\\n    // BigInteger.prototype.fromNumber = bnpFromNumber;\\n    // (protected) alternate constructor\\n    BigInteger.prototype.fromNumber = function (a, b, c) {\\n        if (\\\"number\\\" == typeof b) {\\n            // new BigInteger(int,int,RNG)\\n            if (a < 2) {\\n                this.fromInt(1);\\n            }\\n            else {\\n                this.fromNumber(a, c);\\n                if (!this.testBit(a - 1)) {\\n                    // force MSB set\\n                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), _util__WEBPACK_IMPORTED_MODULE_0__.op_or, this);\\n                }\\n                if (this.isEven()) {\\n                    this.dAddOffset(1, 0);\\n                } // force odd\\n                while (!this.isProbablePrime(b)) {\\n                    this.dAddOffset(2, 0);\\n                    if (this.bitLength() > a) {\\n                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\\n                    }\\n                }\\n            }\\n        }\\n        else {\\n            // new BigInteger(int,RNG)\\n            var x = [];\\n            var t = a & 7;\\n            x.length = (a >> 3) + 1;\\n            b.nextBytes(x);\\n            if (t > 0) {\\n                x[0] &= ((1 << t) - 1);\\n            }\\n            else {\\n                x[0] = 0;\\n            }\\n            this.fromString(x, 256);\\n        }\\n    };\\n    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\\n    // (protected) r = this op a (bitwise)\\n    BigInteger.prototype.bitwiseTo = function (a, op, r) {\\n        var i;\\n        var f;\\n        var m = Math.min(a.t, this.t);\\n        for (i = 0; i < m; ++i) {\\n            r[i] = op(this[i], a[i]);\\n        }\\n        if (a.t < this.t) {\\n            f = a.s & this.DM;\\n            for (i = m; i < this.t; ++i) {\\n                r[i] = op(this[i], f);\\n            }\\n            r.t = this.t;\\n        }\\n        else {\\n            f = this.s & this.DM;\\n            for (i = m; i < a.t; ++i) {\\n                r[i] = op(f, a[i]);\\n            }\\n            r.t = a.t;\\n        }\\n        r.s = op(this.s, a.s);\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.changeBit = bnpChangeBit;\\n    // (protected) this op (1<<n)\\n    BigInteger.prototype.changeBit = function (n, op) {\\n        var r = BigInteger.ONE.shiftLeft(n);\\n        this.bitwiseTo(r, op, r);\\n        return r;\\n    };\\n    // BigInteger.prototype.addTo = bnpAddTo;\\n    // (protected) r = this + a\\n    BigInteger.prototype.addTo = function (a, r) {\\n        var i = 0;\\n        var c = 0;\\n        var m = Math.min(a.t, this.t);\\n        while (i < m) {\\n            c += this[i] + a[i];\\n            r[i++] = c & this.DM;\\n            c >>= this.DB;\\n        }\\n        if (a.t < this.t) {\\n            c += a.s;\\n            while (i < this.t) {\\n                c += this[i];\\n                r[i++] = c & this.DM;\\n                c >>= this.DB;\\n            }\\n            c += this.s;\\n        }\\n        else {\\n            c += this.s;\\n            while (i < a.t) {\\n                c += a[i];\\n                r[i++] = c & this.DM;\\n                c >>= this.DB;\\n            }\\n            c += a.s;\\n        }\\n        r.s = (c < 0) ? -1 : 0;\\n        if (c > 0) {\\n            r[i++] = c;\\n        }\\n        else if (c < -1) {\\n            r[i++] = this.DV + c;\\n        }\\n        r.t = i;\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.dMultiply = bnpDMultiply;\\n    // (protected) this *= n, this >= 0, 1 < n < DV\\n    BigInteger.prototype.dMultiply = function (n) {\\n        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\\n        ++this.t;\\n        this.clamp();\\n    };\\n    // BigInteger.prototype.dAddOffset = bnpDAddOffset;\\n    // (protected) this += n << w words, this >= 0\\n    BigInteger.prototype.dAddOffset = function (n, w) {\\n        if (n == 0) {\\n            return;\\n        }\\n        while (this.t <= w) {\\n            this[this.t++] = 0;\\n        }\\n        this[w] += n;\\n        while (this[w] >= this.DV) {\\n            this[w] -= this.DV;\\n            if (++w >= this.t) {\\n                this[this.t++] = 0;\\n            }\\n            ++this[w];\\n        }\\n    };\\n    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\\n    // (protected) r = lower n words of \\\"this * a\\\", a.t <= n\\n    // \\\"this\\\" should be the larger one if appropriate.\\n    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {\\n        var i = Math.min(this.t + a.t, n);\\n        r.s = 0; // assumes a,this >= 0\\n        r.t = i;\\n        while (i > 0) {\\n            r[--i] = 0;\\n        }\\n        for (var j = r.t - this.t; i < j; ++i) {\\n            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\\n        }\\n        for (var j = Math.min(a.t, n); i < j; ++i) {\\n            this.am(0, a[i], r, i, 0, n - i);\\n        }\\n        r.clamp();\\n    };\\n    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\\n    // (protected) r = \\\"this * a\\\" without lower n words, n > 0\\n    // \\\"this\\\" should be the larger one if appropriate.\\n    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {\\n        --n;\\n        var i = r.t = this.t + a.t - n;\\n        r.s = 0; // assumes a,this >= 0\\n        while (--i >= 0) {\\n            r[i] = 0;\\n        }\\n        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {\\n            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\\n        }\\n        r.clamp();\\n        r.drShiftTo(1, r);\\n    };\\n    // BigInteger.prototype.modInt = bnpModInt;\\n    // (protected) this % n, n < 2^26\\n    BigInteger.prototype.modInt = function (n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        var d = this.DV % n;\\n        var r = (this.s < 0) ? n - 1 : 0;\\n        if (this.t > 0) {\\n            if (d == 0) {\\n                r = this[0] % n;\\n            }\\n            else {\\n                for (var i = this.t - 1; i >= 0; --i) {\\n                    r = (d * r + this[i]) % n;\\n                }\\n            }\\n        }\\n        return r;\\n    };\\n    // BigInteger.prototype.millerRabin = bnpMillerRabin;\\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\\n    BigInteger.prototype.millerRabin = function (t) {\\n        var n1 = this.subtract(BigInteger.ONE);\\n        var k = n1.getLowestSetBit();\\n        if (k <= 0) {\\n            return false;\\n        }\\n        var r = n1.shiftRight(k);\\n        t = (t + 1) >> 1;\\n        if (t > lowprimes.length) {\\n            t = lowprimes.length;\\n        }\\n        var a = nbi();\\n        for (var i = 0; i < t; ++i) {\\n            // Pick bases at random, instead of starting at 2\\n            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\\n            var y = a.modPow(r, this);\\n            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\\n                var j = 1;\\n                while (j++ < k && y.compareTo(n1) != 0) {\\n                    y = y.modPowInt(2, this);\\n                    if (y.compareTo(BigInteger.ONE) == 0) {\\n                        return false;\\n                    }\\n                }\\n                if (y.compareTo(n1) != 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    };\\n    // BigInteger.prototype.square = bnSquare;\\n    // (public) this^2\\n    BigInteger.prototype.square = function () {\\n        var r = nbi();\\n        this.squareTo(r);\\n        return r;\\n    };\\n    //#region ASYNC\\n    // Public API method\\n    BigInteger.prototype.gcda = function (a, callback) {\\n        var x = (this.s < 0) ? this.negate() : this.clone();\\n        var y = (a.s < 0) ? a.negate() : a.clone();\\n        if (x.compareTo(y) < 0) {\\n            var t = x;\\n            x = y;\\n            y = t;\\n        }\\n        var i = x.getLowestSetBit();\\n        var g = y.getLowestSetBit();\\n        if (g < 0) {\\n            callback(x);\\n            return;\\n        }\\n        if (i < g) {\\n            g = i;\\n        }\\n        if (g > 0) {\\n            x.rShiftTo(g, x);\\n            y.rShiftTo(g, y);\\n        }\\n        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.\\n        var gcda1 = function () {\\n            if ((i = x.getLowestSetBit()) > 0) {\\n                x.rShiftTo(i, x);\\n            }\\n            if ((i = y.getLowestSetBit()) > 0) {\\n                y.rShiftTo(i, y);\\n            }\\n            if (x.compareTo(y) >= 0) {\\n                x.subTo(y, x);\\n                x.rShiftTo(1, x);\\n            }\\n            else {\\n                y.subTo(x, y);\\n                y.rShiftTo(1, y);\\n            }\\n            if (!(x.signum() > 0)) {\\n                if (g > 0) {\\n                    y.lShiftTo(g, y);\\n                }\\n                setTimeout(function () { callback(y); }, 0); // escape\\n            }\\n            else {\\n                setTimeout(gcda1, 0);\\n            }\\n        };\\n        setTimeout(gcda1, 10);\\n    };\\n    // (protected) alternate constructor\\n    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {\\n        if (\\\"number\\\" == typeof b) {\\n            if (a < 2) {\\n                this.fromInt(1);\\n            }\\n            else {\\n                this.fromNumber(a, c);\\n                if (!this.testBit(a - 1)) {\\n                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), _util__WEBPACK_IMPORTED_MODULE_0__.op_or, this);\\n                }\\n                if (this.isEven()) {\\n                    this.dAddOffset(1, 0);\\n                }\\n                var bnp_1 = this;\\n                var bnpfn1_1 = function () {\\n                    bnp_1.dAddOffset(2, 0);\\n                    if (bnp_1.bitLength() > a) {\\n                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);\\n                    }\\n                    if (bnp_1.isProbablePrime(b)) {\\n                        setTimeout(function () { callback(); }, 0); // escape\\n                    }\\n                    else {\\n                        setTimeout(bnpfn1_1, 0);\\n                    }\\n                };\\n                setTimeout(bnpfn1_1, 0);\\n            }\\n        }\\n        else {\\n            var x = [];\\n            var t = a & 7;\\n            x.length = (a >> 3) + 1;\\n            b.nextBytes(x);\\n            if (t > 0) {\\n                x[0] &= ((1 << t) - 1);\\n            }\\n            else {\\n                x[0] = 0;\\n            }\\n            this.fromString(x, 256);\\n        }\\n    };\\n    return BigInteger;\\n}());\\n\\n//#region REDUCERS\\n//#region NullExp\\nvar NullExp = /** @class */ (function () {\\n    function NullExp() {\\n    }\\n    // NullExp.prototype.convert = nNop;\\n    NullExp.prototype.convert = function (x) {\\n        return x;\\n    };\\n    // NullExp.prototype.revert = nNop;\\n    NullExp.prototype.revert = function (x) {\\n        return x;\\n    };\\n    // NullExp.prototype.mulTo = nMulTo;\\n    NullExp.prototype.mulTo = function (x, y, r) {\\n        x.multiplyTo(y, r);\\n    };\\n    // NullExp.prototype.sqrTo = nSqrTo;\\n    NullExp.prototype.sqrTo = function (x, r) {\\n        x.squareTo(r);\\n    };\\n    return NullExp;\\n}());\\n// Modular reduction using \\\"classic\\\" algorithm\\nvar Classic = /** @class */ (function () {\\n    function Classic(m) {\\n        this.m = m;\\n    }\\n    // Classic.prototype.convert = cConvert;\\n    Classic.prototype.convert = function (x) {\\n        if (x.s < 0 || x.compareTo(this.m) >= 0) {\\n            return x.mod(this.m);\\n        }\\n        else {\\n            return x;\\n        }\\n    };\\n    // Classic.prototype.revert = cRevert;\\n    Classic.prototype.revert = function (x) {\\n        return x;\\n    };\\n    // Classic.prototype.reduce = cReduce;\\n    Classic.prototype.reduce = function (x) {\\n        x.divRemTo(this.m, null, x);\\n    };\\n    // Classic.prototype.mulTo = cMulTo;\\n    Classic.prototype.mulTo = function (x, y, r) {\\n        x.multiplyTo(y, r);\\n        this.reduce(r);\\n    };\\n    // Classic.prototype.sqrTo = cSqrTo;\\n    Classic.prototype.sqrTo = function (x, r) {\\n        x.squareTo(r);\\n        this.reduce(r);\\n    };\\n    return Classic;\\n}());\\n//#endregion\\n//#region Montgomery\\n// Montgomery reduction\\nvar Montgomery = /** @class */ (function () {\\n    function Montgomery(m) {\\n        this.m = m;\\n        this.mp = m.invDigit();\\n        this.mpl = this.mp & 0x7fff;\\n        this.mph = this.mp >> 15;\\n        this.um = (1 << (m.DB - 15)) - 1;\\n        this.mt2 = 2 * m.t;\\n    }\\n    // Montgomery.prototype.convert = montConvert;\\n    // xR mod m\\n    Montgomery.prototype.convert = function (x) {\\n        var r = nbi();\\n        x.abs().dlShiftTo(this.m.t, r);\\n        r.divRemTo(this.m, null, r);\\n        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {\\n            this.m.subTo(r, r);\\n        }\\n        return r;\\n    };\\n    // Montgomery.prototype.revert = montRevert;\\n    // x/R mod m\\n    Montgomery.prototype.revert = function (x) {\\n        var r = nbi();\\n        x.copyTo(r);\\n        this.reduce(r);\\n        return r;\\n    };\\n    // Montgomery.prototype.reduce = montReduce;\\n    // x = x/R mod m (HAC 14.32)\\n    Montgomery.prototype.reduce = function (x) {\\n        while (x.t <= this.mt2) {\\n            // pad x so am has enough room later\\n            x[x.t++] = 0;\\n        }\\n        for (var i = 0; i < this.m.t; ++i) {\\n            // faster way of calculating u0 = x[i]*mp mod DV\\n            var j = x[i] & 0x7fff;\\n            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\\n            // use am to combine the multiply-shift-add into one call\\n            j = i + this.m.t;\\n            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\\n            // propagate carry\\n            while (x[j] >= x.DV) {\\n                x[j] -= x.DV;\\n                x[++j]++;\\n            }\\n        }\\n        x.clamp();\\n        x.drShiftTo(this.m.t, x);\\n        if (x.compareTo(this.m) >= 0) {\\n            x.subTo(this.m, x);\\n        }\\n    };\\n    // Montgomery.prototype.mulTo = montMulTo;\\n    // r = \\\"xy/R mod m\\\"; x,y != r\\n    Montgomery.prototype.mulTo = function (x, y, r) {\\n        x.multiplyTo(y, r);\\n        this.reduce(r);\\n    };\\n    // Montgomery.prototype.sqrTo = montSqrTo;\\n    // r = \\\"x^2/R mod m\\\"; x != r\\n    Montgomery.prototype.sqrTo = function (x, r) {\\n        x.squareTo(r);\\n        this.reduce(r);\\n    };\\n    return Montgomery;\\n}());\\n//#endregion Montgomery\\n//#region Barrett\\n// Barrett modular reduction\\nvar Barrett = /** @class */ (function () {\\n    function Barrett(m) {\\n        this.m = m;\\n        // setup Barrett\\n        this.r2 = nbi();\\n        this.q3 = nbi();\\n        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\\n        this.mu = this.r2.divide(m);\\n    }\\n    // Barrett.prototype.convert = barrettConvert;\\n    Barrett.prototype.convert = function (x) {\\n        if (x.s < 0 || x.t > 2 * this.m.t) {\\n            return x.mod(this.m);\\n        }\\n        else if (x.compareTo(this.m) < 0) {\\n            return x;\\n        }\\n        else {\\n            var r = nbi();\\n            x.copyTo(r);\\n            this.reduce(r);\\n            return r;\\n        }\\n    };\\n    // Barrett.prototype.revert = barrettRevert;\\n    Barrett.prototype.revert = function (x) {\\n        return x;\\n    };\\n    // Barrett.prototype.reduce = barrettReduce;\\n    // x = x mod m (HAC 14.42)\\n    Barrett.prototype.reduce = function (x) {\\n        x.drShiftTo(this.m.t - 1, this.r2);\\n        if (x.t > this.m.t + 1) {\\n            x.t = this.m.t + 1;\\n            x.clamp();\\n        }\\n        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\\n        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\\n        while (x.compareTo(this.r2) < 0) {\\n            x.dAddOffset(1, this.m.t + 1);\\n        }\\n        x.subTo(this.r2, x);\\n        while (x.compareTo(this.m) >= 0) {\\n            x.subTo(this.m, x);\\n        }\\n    };\\n    // Barrett.prototype.mulTo = barrettMulTo;\\n    // r = x*y mod m; x,y != r\\n    Barrett.prototype.mulTo = function (x, y, r) {\\n        x.multiplyTo(y, r);\\n        this.reduce(r);\\n    };\\n    // Barrett.prototype.sqrTo = barrettSqrTo;\\n    // r = x^2 mod m; x != r\\n    Barrett.prototype.sqrTo = function (x, r) {\\n        x.squareTo(r);\\n        this.reduce(r);\\n    };\\n    return Barrett;\\n}());\\n//#endregion\\n//#endregion REDUCERS\\n// return new, unset BigInteger\\nfunction nbi() { return new BigInteger(null); }\\nfunction parseBigInt(str, r) {\\n    return new BigInteger(str, r);\\n}\\n// am: Compute w_j += (x*this_i), propagate carries,\\n// c is initial carry, returns final carry.\\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\\n// We need to select the fastest one that works in this environment.\\nvar inBrowser = typeof navigator !== \\\"undefined\\\";\\nif (inBrowser && j_lm && (navigator.appName == \\\"Microsoft Internet Explorer\\\")) {\\n    // am2 avoids a big mult-and-extract completely.\\n    // Max digit bits should be <= 30 because we do bitwise ops\\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\\n    BigInteger.prototype.am = function am2(i, x, w, j, c, n) {\\n        var xl = x & 0x7fff;\\n        var xh = x >> 15;\\n        while (--n >= 0) {\\n            var l = this[i] & 0x7fff;\\n            var h = this[i++] >> 15;\\n            var m = xh * l + h * xl;\\n            l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\\n            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\\n            w[j++] = l & 0x3fffffff;\\n        }\\n        return c;\\n    };\\n    dbits = 30;\\n}\\nelse if (inBrowser && j_lm && (navigator.appName != \\\"Netscape\\\")) {\\n    // am1: use a single mult and divide to get the high bits,\\n    // max digit bits should be 26 because\\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\\n    BigInteger.prototype.am = function am1(i, x, w, j, c, n) {\\n        while (--n >= 0) {\\n            var v = x * this[i++] + w[j] + c;\\n            c = Math.floor(v / 0x4000000);\\n            w[j++] = v & 0x3ffffff;\\n        }\\n        return c;\\n    };\\n    dbits = 26;\\n}\\nelse { // Mozilla/Netscape seems to prefer am3\\n    // Alternately, set max digit bits to 28 since some\\n    // browsers slow down when dealing with 32-bit numbers.\\n    BigInteger.prototype.am = function am3(i, x, w, j, c, n) {\\n        var xl = x & 0x3fff;\\n        var xh = x >> 14;\\n        while (--n >= 0) {\\n            var l = this[i] & 0x3fff;\\n            var h = this[i++] >> 14;\\n            var m = xh * l + h * xl;\\n            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\\n            c = (l >> 28) + (m >> 14) + xh * h;\\n            w[j++] = l & 0xfffffff;\\n        }\\n        return c;\\n    };\\n    dbits = 28;\\n}\\nBigInteger.prototype.DB = dbits;\\nBigInteger.prototype.DM = ((1 << dbits) - 1);\\nBigInteger.prototype.DV = (1 << dbits);\\nvar BI_FP = 52;\\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\\nBigInteger.prototype.F1 = BI_FP - dbits;\\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\\n// Digit conversions\\nvar BI_RC = [];\\nvar rr;\\nvar vv;\\nrr = \\\"0\\\".charCodeAt(0);\\nfor (vv = 0; vv <= 9; ++vv) {\\n    BI_RC[rr++] = vv;\\n}\\nrr = \\\"a\\\".charCodeAt(0);\\nfor (vv = 10; vv < 36; ++vv) {\\n    BI_RC[rr++] = vv;\\n}\\nrr = \\\"A\\\".charCodeAt(0);\\nfor (vv = 10; vv < 36; ++vv) {\\n    BI_RC[rr++] = vv;\\n}\\nfunction intAt(s, i) {\\n    var c = BI_RC[s.charCodeAt(i)];\\n    return (c == null) ? -1 : c;\\n}\\n// return bigint initialized to value\\nfunction nbv(i) {\\n    var r = nbi();\\n    r.fromInt(i);\\n    return r;\\n}\\n// returns bit length of the integer x\\nfunction nbits(x) {\\n    var r = 1;\\n    var t;\\n    if ((t = x >>> 16) != 0) {\\n        x = t;\\n        r += 16;\\n    }\\n    if ((t = x >> 8) != 0) {\\n        x = t;\\n        r += 8;\\n    }\\n    if ((t = x >> 4) != 0) {\\n        x = t;\\n        r += 4;\\n    }\\n    if ((t = x >> 2) != 0) {\\n        x = t;\\n        r += 2;\\n    }\\n    if ((t = x >> 1) != 0) {\\n        x = t;\\n        r += 1;\\n    }\\n    return r;\\n}\\n// \\\"constants\\\"\\nBigInteger.ZERO = nbv(0);\\nBigInteger.ONE = nbv(1);\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/jsbn.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/prng4.js\":\n/*!*******************************!*\\\n  !*** ./lib/lib/jsbn/prng4.js ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Arcfour\\\": () => (/* binding */ Arcfour),\\n/* harmony export */   \\\"prng_newstate\\\": () => (/* binding */ prng_newstate),\\n/* harmony export */   \\\"rng_psize\\\": () => (/* binding */ rng_psize)\\n/* harmony export */ });\\n// prng4.js - uses Arcfour as a PRNG\\nvar Arcfour = /** @class */ (function () {\\n    function Arcfour() {\\n        this.i = 0;\\n        this.j = 0;\\n        this.S = [];\\n    }\\n    // Arcfour.prototype.init = ARC4init;\\n    // Initialize arcfour context from key, an array of ints, each from [0..255]\\n    Arcfour.prototype.init = function (key) {\\n        var i;\\n        var j;\\n        var t;\\n        for (i = 0; i < 256; ++i) {\\n            this.S[i] = i;\\n        }\\n        j = 0;\\n        for (i = 0; i < 256; ++i) {\\n            j = (j + this.S[i] + key[i % key.length]) & 255;\\n            t = this.S[i];\\n            this.S[i] = this.S[j];\\n            this.S[j] = t;\\n        }\\n        this.i = 0;\\n        this.j = 0;\\n    };\\n    // Arcfour.prototype.next = ARC4next;\\n    Arcfour.prototype.next = function () {\\n        var t;\\n        this.i = (this.i + 1) & 255;\\n        this.j = (this.j + this.S[this.i]) & 255;\\n        t = this.S[this.i];\\n        this.S[this.i] = this.S[this.j];\\n        this.S[this.j] = t;\\n        return this.S[(t + this.S[this.i]) & 255];\\n    };\\n    return Arcfour;\\n}());\\n\\n// Plug in your RNG constructor here\\nfunction prng_newstate() {\\n    return new Arcfour();\\n}\\n// Pool size must be a multiple of 4 and greater than 32.\\n// An array of bytes the size of the pool will be passed to init()\\nvar rng_psize = 256;\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/prng4.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/rng.js\":\n/*!*****************************!*\\\n  !*** ./lib/lib/jsbn/rng.js ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"SecureRandom\\\": () => (/* binding */ SecureRandom)\\n/* harmony export */ });\\n/* harmony import */ var _prng4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prng4 */ \\\"./lib/lib/jsbn/prng4.js\\\");\\n// Random number generator - requires a PRNG backend, e.g. prng4.js\\n\\nvar rng_state;\\nvar rng_pool = null;\\nvar rng_pptr;\\n// Initialize the pool with junk if needed.\\nif (rng_pool == null) {\\n    rng_pool = [];\\n    rng_pptr = 0;\\n    var t = void 0;\\n    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\\n        // Extract entropy (2048 bits) from RNG if available\\n        var z = new Uint32Array(256);\\n        window.crypto.getRandomValues(z);\\n        for (t = 0; t < z.length; ++t) {\\n            rng_pool[rng_pptr++] = z[t] & 255;\\n        }\\n    }\\n    // Use mouse events for entropy, if we do not have enough entropy by the time\\n    // we need it, entropy will be generated by Math.random.\\n    var count = 0;\\n    var onMouseMoveListener_1 = function (ev) {\\n        count = count || 0;\\n        if (count >= 256 || rng_pptr >= _prng4__WEBPACK_IMPORTED_MODULE_0__.rng_psize) {\\n            if (window.removeEventListener) {\\n                window.removeEventListener(\\\"mousemove\\\", onMouseMoveListener_1, false);\\n            }\\n            else if (window.detachEvent) {\\n                window.detachEvent(\\\"onmousemove\\\", onMouseMoveListener_1);\\n            }\\n            return;\\n        }\\n        try {\\n            var mouseCoordinates = ev.x + ev.y;\\n            rng_pool[rng_pptr++] = mouseCoordinates & 255;\\n            count += 1;\\n        }\\n        catch (e) {\\n            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\\n        }\\n    };\\n    if (typeof window !== 'undefined') {\\n        if (window.addEventListener) {\\n            window.addEventListener(\\\"mousemove\\\", onMouseMoveListener_1, false);\\n        }\\n        else if (window.attachEvent) {\\n            window.attachEvent(\\\"onmousemove\\\", onMouseMoveListener_1);\\n        }\\n    }\\n}\\nfunction rng_get_byte() {\\n    if (rng_state == null) {\\n        rng_state = (0,_prng4__WEBPACK_IMPORTED_MODULE_0__.prng_newstate)();\\n        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\\n        while (rng_pptr < _prng4__WEBPACK_IMPORTED_MODULE_0__.rng_psize) {\\n            var random = Math.floor(65536 * Math.random());\\n            rng_pool[rng_pptr++] = random & 255;\\n        }\\n        rng_state.init(rng_pool);\\n        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\\n            rng_pool[rng_pptr] = 0;\\n        }\\n        rng_pptr = 0;\\n    }\\n    // TODO: allow reseeding after first request\\n    return rng_state.next();\\n}\\nvar SecureRandom = /** @class */ (function () {\\n    function SecureRandom() {\\n    }\\n    SecureRandom.prototype.nextBytes = function (ba) {\\n        for (var i = 0; i < ba.length; ++i) {\\n            ba[i] = rng_get_byte();\\n        }\\n    };\\n    return SecureRandom;\\n}());\\n\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/rng.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/rsa.js\":\n/*!*****************************!*\\\n  !*** ./lib/lib/jsbn/rsa.js ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"RSAKey\\\": () => (/* binding */ RSAKey)\\n/* harmony export */ });\\n/* harmony import */ var _jsbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsbn */ \\\"./lib/lib/jsbn/jsbn.js\\\");\\n/* harmony import */ var _rng__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng */ \\\"./lib/lib/jsbn/rng.js\\\");\\n// Depends on jsbn.js and rng.js\\n// Version 1.1: support utf-8 encoding in pkcs1pad2\\n// convert a (hex) string to a bignum object\\n\\n\\n// function linebrk(s,n) {\\n//   var ret = \\\"\\\";\\n//   var i = 0;\\n//   while(i + n < s.length) {\\n//     ret += s.substring(i,i+n) + \\\"\\\\n\\\";\\n//     i += n;\\n//   }\\n//   return ret + s.substring(i,s.length);\\n// }\\n// function byte2Hex(b) {\\n//   if(b < 0x10)\\n//     return \\\"0\\\" + b.toString(16);\\n//   else\\n//     return b.toString(16);\\n// }\\nfunction pkcs1pad1(s, n) {\\n    if (n < s.length + 22) {\\n        console.error(\\\"Message too long for RSA\\\");\\n        return null;\\n    }\\n    var len = n - s.length - 6;\\n    var filler = \\\"\\\";\\n    for (var f = 0; f < len; f += 2) {\\n        filler += \\\"ff\\\";\\n    }\\n    var m = \\\"0001\\\" + filler + \\\"00\\\" + s;\\n    return (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(m, 16);\\n}\\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\\nfunction pkcs1pad2(s, n) {\\n    if (n < s.length + 11) { // TODO: fix for utf-8\\n        console.error(\\\"Message too long for RSA\\\");\\n        return null;\\n    }\\n    var ba = [];\\n    var i = s.length - 1;\\n    while (i >= 0 && n > 0) {\\n        var c = s.charCodeAt(i--);\\n        if (c < 128) { // encode using utf-8\\n            ba[--n] = c;\\n        }\\n        else if ((c > 127) && (c < 2048)) {\\n            ba[--n] = (c & 63) | 128;\\n            ba[--n] = (c >> 6) | 192;\\n        }\\n        else {\\n            ba[--n] = (c & 63) | 128;\\n            ba[--n] = ((c >> 6) & 63) | 128;\\n            ba[--n] = (c >> 12) | 224;\\n        }\\n    }\\n    ba[--n] = 0;\\n    var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();\\n    var x = [];\\n    while (n > 2) { // random non-zero pad\\n        x[0] = 0;\\n        while (x[0] == 0) {\\n            rng.nextBytes(x);\\n        }\\n        ba[--n] = x[0];\\n    }\\n    ba[--n] = 2;\\n    ba[--n] = 0;\\n    return new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(ba);\\n}\\n// \\\"empty\\\" RSA key constructor\\nvar RSAKey = /** @class */ (function () {\\n    function RSAKey() {\\n        this.n = null;\\n        this.e = 0;\\n        this.d = null;\\n        this.p = null;\\n        this.q = null;\\n        this.dmp1 = null;\\n        this.dmq1 = null;\\n        this.coeff = null;\\n    }\\n    //#region PROTECTED\\n    // protected\\n    // RSAKey.prototype.doPublic = RSADoPublic;\\n    // Perform raw public operation on \\\"x\\\": return x^e (mod n)\\n    RSAKey.prototype.doPublic = function (x) {\\n        return x.modPowInt(this.e, this.n);\\n    };\\n    // RSAKey.prototype.doPrivate = RSADoPrivate;\\n    // Perform raw private operation on \\\"x\\\": return x^d (mod n)\\n    RSAKey.prototype.doPrivate = function (x) {\\n        if (this.p == null || this.q == null) {\\n            return x.modPow(this.d, this.n);\\n        }\\n        // TODO: re-calculate any missing CRT params\\n        var xp = x.mod(this.p).modPow(this.dmp1, this.p);\\n        var xq = x.mod(this.q).modPow(this.dmq1, this.q);\\n        while (xp.compareTo(xq) < 0) {\\n            xp = xp.add(this.p);\\n        }\\n        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\\n    };\\n    //#endregion PROTECTED\\n    //#region PUBLIC\\n    // RSAKey.prototype.setPublic = RSASetPublic;\\n    // Set the public key fields N and e from hex strings\\n    RSAKey.prototype.setPublic = function (N, E) {\\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\\n            this.n = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);\\n            this.e = parseInt(E, 16);\\n        }\\n        else {\\n            console.error(\\\"Invalid RSA public key\\\");\\n        }\\n    };\\n    // RSAKey.prototype.encrypt = RSAEncrypt;\\n    // Return the PKCS#1 RSA encryption of \\\"text\\\" as an even-length hex string\\n    RSAKey.prototype.encrypt = function (text) {\\n        var maxLength = (this.n.bitLength() + 7) >> 3;\\n        var m = pkcs1pad2(text, maxLength);\\n        if (m == null) {\\n            return null;\\n        }\\n        var c = this.doPublic(m);\\n        if (c == null) {\\n            return null;\\n        }\\n        var h = c.toString(16);\\n        var length = h.length;\\n        // fix zero before result\\n        for (var i = 0; i < maxLength * 2 - length; i++) {\\n            h = \\\"0\\\" + h;\\n        }\\n        return h;\\n    };\\n    // RSAKey.prototype.setPrivate = RSASetPrivate;\\n    // Set the private key fields N, e, and d from hex strings\\n    RSAKey.prototype.setPrivate = function (N, E, D) {\\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\\n            this.n = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);\\n            this.e = parseInt(E, 16);\\n            this.d = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(D, 16);\\n        }\\n        else {\\n            console.error(\\\"Invalid RSA private key\\\");\\n        }\\n    };\\n    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;\\n    // Set the private key fields N, e, d and CRT params from hex strings\\n    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {\\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\\n            this.n = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(N, 16);\\n            this.e = parseInt(E, 16);\\n            this.d = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(D, 16);\\n            this.p = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(P, 16);\\n            this.q = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(Q, 16);\\n            this.dmp1 = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(DP, 16);\\n            this.dmq1 = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(DQ, 16);\\n            this.coeff = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(C, 16);\\n        }\\n        else {\\n            console.error(\\\"Invalid RSA private key\\\");\\n        }\\n    };\\n    // RSAKey.prototype.generate = RSAGenerate;\\n    // Generate a new random private key B bits long, using public expt E\\n    RSAKey.prototype.generate = function (B, E) {\\n        var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();\\n        var qs = B >> 1;\\n        this.e = parseInt(E, 16);\\n        var ee = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(E, 16);\\n        for (;;) {\\n            for (;;) {\\n                this.p = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(B - qs, 1, rng);\\n                if (this.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {\\n                    break;\\n                }\\n            }\\n            for (;;) {\\n                this.q = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(qs, 1, rng);\\n                if (this.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {\\n                    break;\\n                }\\n            }\\n            if (this.p.compareTo(this.q) <= 0) {\\n                var t = this.p;\\n                this.p = this.q;\\n                this.q = t;\\n            }\\n            var p1 = this.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);\\n            var q1 = this.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);\\n            var phi = p1.multiply(q1);\\n            if (phi.gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0) {\\n                this.n = this.p.multiply(this.q);\\n                this.d = ee.modInverse(phi);\\n                this.dmp1 = this.d.mod(p1);\\n                this.dmq1 = this.d.mod(q1);\\n                this.coeff = this.q.modInverse(this.p);\\n                break;\\n            }\\n        }\\n    };\\n    // RSAKey.prototype.decrypt = RSADecrypt;\\n    // Return the PKCS#1 RSA decryption of \\\"ctext\\\".\\n    // \\\"ctext\\\" is an even-length hex string and the output is a plain string.\\n    RSAKey.prototype.decrypt = function (ctext) {\\n        var c = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(ctext, 16);\\n        var m = this.doPrivate(c);\\n        if (m == null) {\\n            return null;\\n        }\\n        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);\\n    };\\n    // Generate a new random private key B bits long, using public expt E\\n    RSAKey.prototype.generateAsync = function (B, E, callback) {\\n        var rng = new _rng__WEBPACK_IMPORTED_MODULE_1__.SecureRandom();\\n        var qs = B >> 1;\\n        this.e = parseInt(E, 16);\\n        var ee = new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(E, 16);\\n        var rsa = this;\\n        // These functions have non-descript names because they were originally for(;;) loops.\\n        // I don't know about cryptography to give them better names than loop1-4.\\n        var loop1 = function () {\\n            var loop4 = function () {\\n                if (rsa.p.compareTo(rsa.q) <= 0) {\\n                    var t = rsa.p;\\n                    rsa.p = rsa.q;\\n                    rsa.q = t;\\n                }\\n                var p1 = rsa.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);\\n                var q1 = rsa.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);\\n                var phi = p1.multiply(q1);\\n                if (phi.gcd(ee).compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0) {\\n                    rsa.n = rsa.p.multiply(rsa.q);\\n                    rsa.d = ee.modInverse(phi);\\n                    rsa.dmp1 = rsa.d.mod(p1);\\n                    rsa.dmq1 = rsa.d.mod(q1);\\n                    rsa.coeff = rsa.q.modInverse(rsa.p);\\n                    setTimeout(function () { callback(); }, 0); // escape\\n                }\\n                else {\\n                    setTimeout(loop1, 0);\\n                }\\n            };\\n            var loop3 = function () {\\n                rsa.q = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.nbi)();\\n                rsa.q.fromNumberAsync(qs, 1, rng, function () {\\n                    rsa.q.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcda(ee, function (r) {\\n                        if (r.compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {\\n                            setTimeout(loop4, 0);\\n                        }\\n                        else {\\n                            setTimeout(loop3, 0);\\n                        }\\n                    });\\n                });\\n            };\\n            var loop2 = function () {\\n                rsa.p = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.nbi)();\\n                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {\\n                    rsa.p.subtract(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE).gcda(ee, function (r) {\\n                        if (r.compareTo(_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {\\n                            setTimeout(loop3, 0);\\n                        }\\n                        else {\\n                            setTimeout(loop2, 0);\\n                        }\\n                    });\\n                });\\n            };\\n            setTimeout(loop2, 0);\\n        };\\n        setTimeout(loop1, 0);\\n    };\\n    RSAKey.prototype.sign = function (text, digestMethod, digestName) {\\n        var header = getDigestHeader(digestName);\\n        var digest = header + digestMethod(text).toString();\\n        var m = pkcs1pad1(digest, this.n.bitLength() / 4);\\n        if (m == null) {\\n            return null;\\n        }\\n        var c = this.doPrivate(m);\\n        if (c == null) {\\n            return null;\\n        }\\n        var h = c.toString(16);\\n        if ((h.length & 1) == 0) {\\n            return h;\\n        }\\n        else {\\n            return \\\"0\\\" + h;\\n        }\\n    };\\n    RSAKey.prototype.verify = function (text, signature, digestMethod) {\\n        var c = (0,_jsbn__WEBPACK_IMPORTED_MODULE_0__.parseBigInt)(signature, 16);\\n        var m = this.doPublic(c);\\n        if (m == null) {\\n            return null;\\n        }\\n        var unpadded = m.toString(16).replace(/^1f+00/, \\\"\\\");\\n        var digest = removeDigestHeader(unpadded);\\n        return digest == digestMethod(text).toString();\\n    };\\n    return RSAKey;\\n}());\\n\\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\\nfunction pkcs1unpad2(d, n) {\\n    var b = d.toByteArray();\\n    var i = 0;\\n    while (i < b.length && b[i] == 0) {\\n        ++i;\\n    }\\n    if (b.length - i != n - 1 || b[i] != 2) {\\n        return null;\\n    }\\n    ++i;\\n    while (b[i] != 0) {\\n        if (++i >= b.length) {\\n            return null;\\n        }\\n    }\\n    var ret = \\\"\\\";\\n    while (++i < b.length) {\\n        var c = b[i] & 255;\\n        if (c < 128) { // utf-8 decode\\n            ret += String.fromCharCode(c);\\n        }\\n        else if ((c > 191) && (c < 224)) {\\n            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));\\n            ++i;\\n        }\\n        else {\\n            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));\\n            i += 2;\\n        }\\n    }\\n    return ret;\\n}\\n// https://tools.ietf.org/html/rfc3447#page-43\\nvar DIGEST_HEADERS = {\\n    md2: \\\"3020300c06082a864886f70d020205000410\\\",\\n    md5: \\\"3020300c06082a864886f70d020505000410\\\",\\n    sha1: \\\"3021300906052b0e03021a05000414\\\",\\n    sha224: \\\"302d300d06096086480165030402040500041c\\\",\\n    sha256: \\\"3031300d060960864801650304020105000420\\\",\\n    sha384: \\\"3041300d060960864801650304020205000430\\\",\\n    sha512: \\\"3051300d060960864801650304020305000440\\\",\\n    ripemd160: \\\"3021300906052b2403020105000414\\\"\\n};\\nfunction getDigestHeader(name) {\\n    return DIGEST_HEADERS[name] || \\\"\\\";\\n}\\nfunction removeDigestHeader(str) {\\n    for (var name_1 in DIGEST_HEADERS) {\\n        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {\\n            var header = DIGEST_HEADERS[name_1];\\n            var len = header.length;\\n            if (str.substr(0, len) == header) {\\n                return str.substr(len);\\n            }\\n        }\\n    }\\n    return str;\\n}\\n// Return the PKCS#1 RSA encryption of \\\"text\\\" as a Base64-encoded string\\n// function RSAEncryptB64(text) {\\n//  var h = this.encrypt(text);\\n//  if(h) return hex2b64(h); else return null;\\n// }\\n// public\\n// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/rsa.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsbn/util.js\":\n/*!******************************!*\\\n  !*** ./lib/lib/jsbn/util.js ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"cbit\\\": () => (/* binding */ cbit),\\n/* harmony export */   \\\"int2char\\\": () => (/* binding */ int2char),\\n/* harmony export */   \\\"lbit\\\": () => (/* binding */ lbit),\\n/* harmony export */   \\\"op_and\\\": () => (/* binding */ op_and),\\n/* harmony export */   \\\"op_andnot\\\": () => (/* binding */ op_andnot),\\n/* harmony export */   \\\"op_or\\\": () => (/* binding */ op_or),\\n/* harmony export */   \\\"op_xor\\\": () => (/* binding */ op_xor)\\n/* harmony export */ });\\nvar BI_RM = \\\"0123456789abcdefghijklmnopqrstuvwxyz\\\";\\nfunction int2char(n) {\\n    return BI_RM.charAt(n);\\n}\\n//#region BIT_OPERATIONS\\n// (public) this & a\\nfunction op_and(x, y) {\\n    return x & y;\\n}\\n// (public) this | a\\nfunction op_or(x, y) {\\n    return x | y;\\n}\\n// (public) this ^ a\\nfunction op_xor(x, y) {\\n    return x ^ y;\\n}\\n// (public) this & ~a\\nfunction op_andnot(x, y) {\\n    return x & ~y;\\n}\\n// return index of lowest 1-bit in x, x < 2^31\\nfunction lbit(x) {\\n    if (x == 0) {\\n        return -1;\\n    }\\n    var r = 0;\\n    if ((x & 0xffff) == 0) {\\n        x >>= 16;\\n        r += 16;\\n    }\\n    if ((x & 0xff) == 0) {\\n        x >>= 8;\\n        r += 8;\\n    }\\n    if ((x & 0xf) == 0) {\\n        x >>= 4;\\n        r += 4;\\n    }\\n    if ((x & 3) == 0) {\\n        x >>= 2;\\n        r += 2;\\n    }\\n    if ((x & 1) == 0) {\\n        ++r;\\n    }\\n    return r;\\n}\\n// return number of 1 bits in x\\nfunction cbit(x) {\\n    var r = 0;\\n    while (x != 0) {\\n        x &= x - 1;\\n        ++r;\\n    }\\n    return r;\\n}\\n//#endregion BIT_OPERATIONS\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsbn/util.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsrsasign/asn1-1.0.js\":\n/*!***************************************!*\\\n  !*** ./lib/lib/jsrsasign/asn1-1.0.js ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"KJUR\\\": () => (/* binding */ KJUR)\\n/* harmony export */ });\\n/* harmony import */ var _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jsbn/jsbn */ \\\"./lib/lib/jsbn/jsbn.js\\\");\\n/* harmony import */ var _yahoo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./yahoo */ \\\"./lib/lib/jsrsasign/yahoo.js\\\");\\n/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license\\n */\\n/*\\n * asn1.js - ASN.1 DER encoder classes\\n *\\n * Copyright (c) 2013-2017 Kenji Urushima (kenji.urushima@gmail.com)\\n *\\n * This software is licensed under the terms of the MIT License.\\n * https://kjur.github.io/jsrsasign/license\\n *\\n * The above copyright and license notice shall be\\n * included in all copies or substantial portions of the Software.\\n */\\n\\n\\n/**\\n * @fileOverview\\n * @name asn1-1.0.js\\n * @author Kenji Urushima kenji.urushima@gmail.com\\n * @version asn1 1.0.13 (2017-Jun-02)\\n * @since jsrsasign 2.1\\n * @license <a href=\\\"https://kjur.github.io/jsrsasign/license/\\\">MIT License</a>\\n */\\n/**\\n * kjur's class library name space\\n * <p>\\n * This name space provides following name spaces:\\n * <ul>\\n * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>\\n * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>\\n * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature\\n * class and utilities</li>\\n * </ul>\\n * </p>\\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\\n * @name KJUR\\n * @namespace kjur's class library name space\\n */\\nvar KJUR = {};\\n/**\\n * kjur's ASN.1 class library name space\\n * <p>\\n * This is ITU-T X.690 ASN.1 DER encoder class library and\\n * class structure and methods is very similar to\\n * org.bouncycastle.asn1 package of\\n * well known BouncyCaslte Cryptography Library.\\n * <h4>PROVIDING ASN.1 PRIMITIVES</h4>\\n * Here are ASN.1 DER primitive classes.\\n * <ul>\\n * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>\\n * <li>0x02 {@link KJUR.asn1.DERInteger}</li>\\n * <li>0x03 {@link KJUR.asn1.DERBitString}</li>\\n * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>\\n * <li>0x05 {@link KJUR.asn1.DERNull}</li>\\n * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>\\n * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>\\n * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>\\n * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>\\n * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>\\n * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>\\n * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>\\n * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>\\n * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>\\n * <li>0x30 {@link KJUR.asn1.DERSequence}</li>\\n * <li>0x31 {@link KJUR.asn1.DERSet}</li>\\n * </ul>\\n * <h4>OTHER ASN.1 CLASSES</h4>\\n * <ul>\\n * <li>{@link KJUR.asn1.ASN1Object}</li>\\n * <li>{@link KJUR.asn1.DERAbstractString}</li>\\n * <li>{@link KJUR.asn1.DERAbstractTime}</li>\\n * <li>{@link KJUR.asn1.DERAbstractStructured}</li>\\n * <li>{@link KJUR.asn1.DERTaggedObject}</li>\\n * </ul>\\n * <h4>SUB NAME SPACES</h4>\\n * <ul>\\n * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>\\n * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>\\n * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>\\n * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>\\n * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>\\n * </ul>\\n * </p>\\n * NOTE: Please ignore method summary and document of this namespace.\\n * This caused by a bug of jsdoc2.\\n * @name KJUR.asn1\\n * @namespace\\n */\\nif (typeof KJUR.asn1 == \\\"undefined\\\" || !KJUR.asn1)\\n    KJUR.asn1 = {};\\n/**\\n * ASN1 utilities class\\n * @name KJUR.asn1.ASN1Util\\n * @class ASN1 utilities class\\n * @since asn1 1.0.2\\n */\\nKJUR.asn1.ASN1Util = new function () {\\n    this.integerToByteHex = function (i) {\\n        var h = i.toString(16);\\n        if ((h.length % 2) == 1)\\n            h = '0' + h;\\n        return h;\\n    };\\n    this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {\\n        var h = bigIntegerValue.toString(16);\\n        if (h.substr(0, 1) != '-') {\\n            if (h.length % 2 == 1) {\\n                h = '0' + h;\\n            }\\n            else {\\n                if (!h.match(/^[0-7]/)) {\\n                    h = '00' + h;\\n                }\\n            }\\n        }\\n        else {\\n            var hPos = h.substr(1);\\n            var xorLen = hPos.length;\\n            if (xorLen % 2 == 1) {\\n                xorLen += 1;\\n            }\\n            else {\\n                if (!h.match(/^[0-7]/)) {\\n                    xorLen += 2;\\n                }\\n            }\\n            var hMask = '';\\n            for (var i = 0; i < xorLen; i++) {\\n                hMask += 'f';\\n            }\\n            var biMask = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(hMask, 16);\\n            var biNeg = biMask.xor(bigIntegerValue).add(_jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger.ONE);\\n            h = biNeg.toString(16).replace(/^-/, '');\\n        }\\n        return h;\\n    };\\n    /**\\n     * get PEM string from hexadecimal data and header string\\n     * @name getPEMStringFromHex\\n     * @memberOf KJUR.asn1.ASN1Util\\n     * @function\\n     * @param {String} dataHex hexadecimal string of PEM body\\n     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')\\n     * @return {String} PEM formatted string of input data\\n     * @description\\n     * This method converts a hexadecimal string to a PEM string with\\n     * a specified header. Its line break will be CRLF(\\\"\\\\r\\\\n\\\").\\n     * @example\\n     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');\\n     * // value of pem will be:\\n     * -----BEGIN PRIVATE KEY-----\\n     * YWFh\\n     * -----END PRIVATE KEY-----\\n     */\\n    this.getPEMStringFromHex = function (dataHex, pemHeader) {\\n        return hextopem(dataHex, pemHeader);\\n    };\\n    /**\\n     * generate ASN1Object specifed by JSON parameters\\n     * @name newObject\\n     * @memberOf KJUR.asn1.ASN1Util\\n     * @function\\n     * @param {Array} param JSON parameter to generate ASN1Object\\n     * @return {KJUR.asn1.ASN1Object} generated object\\n     * @since asn1 1.0.3\\n     * @description\\n     * generate any ASN1Object specified by JSON param\\n     * including ASN.1 primitive or structured.\\n     * Generally 'param' can be described as follows:\\n     * <blockquote>\\n     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}\\n     * </blockquote>\\n     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:\\n     * <ul>\\n     * <li>'bool' - DERBoolean</li>\\n     * <li>'int' - DERInteger</li>\\n     * <li>'bitstr' - DERBitString</li>\\n     * <li>'octstr' - DEROctetString</li>\\n     * <li>'null' - DERNull</li>\\n     * <li>'oid' - DERObjectIdentifier</li>\\n     * <li>'enum' - DEREnumerated</li>\\n     * <li>'utf8str' - DERUTF8String</li>\\n     * <li>'numstr' - DERNumericString</li>\\n     * <li>'prnstr' - DERPrintableString</li>\\n     * <li>'telstr' - DERTeletexString</li>\\n     * <li>'ia5str' - DERIA5String</li>\\n     * <li>'utctime' - DERUTCTime</li>\\n     * <li>'gentime' - DERGeneralizedTime</li>\\n     * <li>'seq' - DERSequence</li>\\n     * <li>'set' - DERSet</li>\\n     * <li>'tag' - DERTaggedObject</li>\\n     * </ul>\\n     * @example\\n     * newObject({'prnstr': 'aaa'});\\n     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})\\n     * // ASN.1 Tagged Object\\n     * newObject({'tag': {'tag': 'a1',\\n     *                    'explicit': true,\\n     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});\\n     * // more simple representation of ASN.1 Tagged Object\\n     * newObject({'tag': ['a1',\\n     *                    true,\\n     *                    {'seq': [\\n     *                      {'int': 3},\\n     *                      {'prnstr': 'aaa'}]}\\n     *                   ]});\\n     */\\n    this.newObject = function (param) {\\n        var _KJUR = KJUR, _KJUR_asn1 = _KJUR.asn1, _DERBoolean = _KJUR_asn1.DERBoolean, _DERInteger = _KJUR_asn1.DERInteger, _DERBitString = _KJUR_asn1.DERBitString, _DEROctetString = _KJUR_asn1.DEROctetString, _DERNull = _KJUR_asn1.DERNull, _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier, _DEREnumerated = _KJUR_asn1.DEREnumerated, _DERUTF8String = _KJUR_asn1.DERUTF8String, _DERNumericString = _KJUR_asn1.DERNumericString, _DERPrintableString = _KJUR_asn1.DERPrintableString, _DERTeletexString = _KJUR_asn1.DERTeletexString, _DERIA5String = _KJUR_asn1.DERIA5String, _DERUTCTime = _KJUR_asn1.DERUTCTime, _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime, _DERSequence = _KJUR_asn1.DERSequence, _DERSet = _KJUR_asn1.DERSet, _DERTaggedObject = _KJUR_asn1.DERTaggedObject, _newObject = _KJUR_asn1.ASN1Util.newObject;\\n        var keys = Object.keys(param);\\n        if (keys.length != 1)\\n            throw \\\"key of param shall be only one.\\\";\\n        var key = keys[0];\\n        if (\\\":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:\\\".indexOf(\\\":\\\" + key + \\\":\\\") == -1)\\n            throw \\\"undefined key: \\\" + key;\\n        if (key == \\\"bool\\\")\\n            return new _DERBoolean(param[key]);\\n        if (key == \\\"int\\\")\\n            return new _DERInteger(param[key]);\\n        if (key == \\\"bitstr\\\")\\n            return new _DERBitString(param[key]);\\n        if (key == \\\"octstr\\\")\\n            return new _DEROctetString(param[key]);\\n        if (key == \\\"null\\\")\\n            return new _DERNull(param[key]);\\n        if (key == \\\"oid\\\")\\n            return new _DERObjectIdentifier(param[key]);\\n        if (key == \\\"enum\\\")\\n            return new _DEREnumerated(param[key]);\\n        if (key == \\\"utf8str\\\")\\n            return new _DERUTF8String(param[key]);\\n        if (key == \\\"numstr\\\")\\n            return new _DERNumericString(param[key]);\\n        if (key == \\\"prnstr\\\")\\n            return new _DERPrintableString(param[key]);\\n        if (key == \\\"telstr\\\")\\n            return new _DERTeletexString(param[key]);\\n        if (key == \\\"ia5str\\\")\\n            return new _DERIA5String(param[key]);\\n        if (key == \\\"utctime\\\")\\n            return new _DERUTCTime(param[key]);\\n        if (key == \\\"gentime\\\")\\n            return new _DERGeneralizedTime(param[key]);\\n        if (key == \\\"seq\\\") {\\n            var paramList = param[key];\\n            var a = [];\\n            for (var i = 0; i < paramList.length; i++) {\\n                var asn1Obj = _newObject(paramList[i]);\\n                a.push(asn1Obj);\\n            }\\n            return new _DERSequence({ 'array': a });\\n        }\\n        if (key == \\\"set\\\") {\\n            var paramList = param[key];\\n            var a = [];\\n            for (var i = 0; i < paramList.length; i++) {\\n                var asn1Obj = _newObject(paramList[i]);\\n                a.push(asn1Obj);\\n            }\\n            return new _DERSet({ 'array': a });\\n        }\\n        if (key == \\\"tag\\\") {\\n            var tagParam = param[key];\\n            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&\\n                tagParam.length == 3) {\\n                var obj = _newObject(tagParam[2]);\\n                return new _DERTaggedObject({ tag: tagParam[0],\\n                    explicit: tagParam[1],\\n                    obj: obj });\\n            }\\n            else {\\n                var newParam = {};\\n                if (tagParam.explicit !== undefined)\\n                    newParam.explicit = tagParam.explicit;\\n                if (tagParam.tag !== undefined)\\n                    newParam.tag = tagParam.tag;\\n                if (tagParam.obj === undefined)\\n                    throw \\\"obj shall be specified for 'tag'.\\\";\\n                newParam.obj = _newObject(tagParam.obj);\\n                return new _DERTaggedObject(newParam);\\n            }\\n        }\\n    };\\n    /**\\n     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters\\n     * @name jsonToASN1HEX\\n     * @memberOf KJUR.asn1.ASN1Util\\n     * @function\\n     * @param {Array} param JSON parameter to generate ASN1Object\\n     * @return hexadecimal string of ASN1Object\\n     * @since asn1 1.0.4\\n     * @description\\n     * As for ASN.1 object representation of JSON object,\\n     * please see {@link newObject}.\\n     * @example\\n     * jsonToASN1HEX({'prnstr': 'aaa'});\\n     */\\n    this.jsonToASN1HEX = function (param) {\\n        var asn1Obj = this.newObject(param);\\n        return asn1Obj.getEncodedHex();\\n    };\\n};\\n/**\\n * get dot noted oid number string from hexadecimal value of OID\\n * @name oidHexToInt\\n * @memberOf KJUR.asn1.ASN1Util\\n * @function\\n * @param {String} hex hexadecimal value of object identifier\\n * @return {String} dot noted string of object identifier\\n * @since jsrsasign 4.8.3 asn1 1.0.7\\n * @description\\n * This static method converts from hexadecimal string representation of\\n * ASN.1 value of object identifier to oid number string.\\n * @example\\n * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; \\\"2.5.4.6\\\"\\n */\\nKJUR.asn1.ASN1Util.oidHexToInt = function (hex) {\\n    var s = \\\"\\\";\\n    var i01 = parseInt(hex.substr(0, 2), 16);\\n    var i0 = Math.floor(i01 / 40);\\n    var i1 = i01 % 40;\\n    var s = i0 + \\\".\\\" + i1;\\n    var binbuf = \\\"\\\";\\n    for (var i = 2; i < hex.length; i += 2) {\\n        var value = parseInt(hex.substr(i, 2), 16);\\n        var bin = (\\\"00000000\\\" + value.toString(2)).slice(-8);\\n        binbuf = binbuf + bin.substr(1, 7);\\n        if (bin.substr(0, 1) == \\\"0\\\") {\\n            var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(binbuf, 2);\\n            s = s + \\\".\\\" + bi.toString(10);\\n            binbuf = \\\"\\\";\\n        }\\n    }\\n    ;\\n    return s;\\n};\\n/**\\n * get hexadecimal value of object identifier from dot noted oid value\\n * @name oidIntToHex\\n * @memberOf KJUR.asn1.ASN1Util\\n * @function\\n * @param {String} oidString dot noted string of object identifier\\n * @return {String} hexadecimal value of object identifier\\n * @since jsrsasign 4.8.3 asn1 1.0.7\\n * @description\\n * This static method converts from object identifier value string.\\n * to hexadecimal string representation of it.\\n * @example\\n * KJUR.asn1.ASN1Util.oidIntToHex(\\\"2.5.4.6\\\") &rarr; \\\"550406\\\"\\n */\\nKJUR.asn1.ASN1Util.oidIntToHex = function (oidString) {\\n    var itox = function (i) {\\n        var h = i.toString(16);\\n        if (h.length == 1)\\n            h = '0' + h;\\n        return h;\\n    };\\n    var roidtox = function (roid) {\\n        var h = '';\\n        var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(roid, 10);\\n        var b = bi.toString(2);\\n        var padLen = 7 - b.length % 7;\\n        if (padLen == 7)\\n            padLen = 0;\\n        var bPad = '';\\n        for (var i = 0; i < padLen; i++)\\n            bPad += '0';\\n        b = bPad + b;\\n        for (var i = 0; i < b.length - 1; i += 7) {\\n            var b8 = b.substr(i, 7);\\n            if (i != b.length - 7)\\n                b8 = '1' + b8;\\n            h += itox(parseInt(b8, 2));\\n        }\\n        return h;\\n    };\\n    if (!oidString.match(/^[0-9.]+$/)) {\\n        throw \\\"malformed oid string: \\\" + oidString;\\n    }\\n    var h = '';\\n    var a = oidString.split('.');\\n    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);\\n    h += itox(i0);\\n    a.splice(0, 2);\\n    for (var i = 0; i < a.length; i++) {\\n        h += roidtox(a[i]);\\n    }\\n    return h;\\n};\\n// ********************************************************************\\n//  Abstract ASN.1 Classes\\n// ********************************************************************\\n// ********************************************************************\\n/**\\n * base class for ASN.1 DER encoder object\\n * @name KJUR.asn1.ASN1Object\\n * @class base class for ASN.1 DER encoder object\\n * @property {Boolean} isModified flag whether internal data was changed\\n * @property {String} hTLV hexadecimal string of ASN.1 TLV\\n * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)\\n * @property {String} hL hexadecimal string of ASN.1 TLV length(L)\\n * @property {String} hV hexadecimal string of ASN.1 TLV value(V)\\n * @description\\n */\\nKJUR.asn1.ASN1Object = function () {\\n    var isModified = true;\\n    var hTLV = null;\\n    var hT = '00';\\n    var hL = '00';\\n    var hV = '';\\n    /**\\n     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)\\n     * @name getLengthHexFromValue\\n     * @memberOf KJUR.asn1.ASN1Object#\\n     * @function\\n     * @return {String} hexadecimal string of ASN.1 TLV length(L)\\n     */\\n    this.getLengthHexFromValue = function () {\\n        if (typeof this.hV == \\\"undefined\\\" || this.hV == null) {\\n            throw \\\"this.hV is null or undefined.\\\";\\n        }\\n        if (this.hV.length % 2 == 1) {\\n            throw \\\"value hex must be even length: n=\\\" + hV.length + \\\",v=\\\" + this.hV;\\n        }\\n        var n = this.hV.length / 2;\\n        var hN = n.toString(16);\\n        if (hN.length % 2 == 1) {\\n            hN = \\\"0\\\" + hN;\\n        }\\n        if (n < 128) {\\n            return hN;\\n        }\\n        else {\\n            var hNlen = hN.length / 2;\\n            if (hNlen > 15) {\\n                throw \\\"ASN.1 length too long to represent by 8x: n = \\\" + n.toString(16);\\n            }\\n            var head = 128 + hNlen;\\n            return head.toString(16) + hN;\\n        }\\n    };\\n    /**\\n     * get hexadecimal string of ASN.1 TLV bytes\\n     * @name getEncodedHex\\n     * @memberOf KJUR.asn1.ASN1Object#\\n     * @function\\n     * @return {String} hexadecimal string of ASN.1 TLV\\n     */\\n    this.getEncodedHex = function () {\\n        if (this.hTLV == null || this.isModified) {\\n            this.hV = this.getFreshValueHex();\\n            this.hL = this.getLengthHexFromValue();\\n            this.hTLV = this.hT + this.hL + this.hV;\\n            this.isModified = false;\\n            //alert(\\\"first time: \\\" + this.hTLV);\\n        }\\n        return this.hTLV;\\n    };\\n    /**\\n     * get hexadecimal string of ASN.1 TLV value(V) bytes\\n     * @name getValueHex\\n     * @memberOf KJUR.asn1.ASN1Object#\\n     * @function\\n     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes\\n     */\\n    this.getValueHex = function () {\\n        this.getEncodedHex();\\n        return this.hV;\\n    };\\n    this.getFreshValueHex = function () {\\n        return '';\\n    };\\n};\\n// == BEGIN DERAbstractString ================================================\\n/**\\n * base class for ASN.1 DER string classes\\n * @name KJUR.asn1.DERAbstractString\\n * @class base class for ASN.1 DER string classes\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @property {String} s internal string of value\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>str - specify initial ASN.1 value(V) by a string</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n */\\nKJUR.asn1.DERAbstractString = function (params) {\\n    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);\\n    var s = null;\\n    var hV = null;\\n    /**\\n     * get string value of this string object\\n     * @name getString\\n     * @memberOf KJUR.asn1.DERAbstractString#\\n     * @function\\n     * @return {String} string value of this string object\\n     */\\n    this.getString = function () {\\n        return this.s;\\n    };\\n    /**\\n     * set value by a string\\n     * @name setString\\n     * @memberOf KJUR.asn1.DERAbstractString#\\n     * @function\\n     * @param {String} newS value by a string to set\\n     */\\n    this.setString = function (newS) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.s = newS;\\n        this.hV = stohex(this.s);\\n    };\\n    /**\\n     * set value by a hexadecimal string\\n     * @name setStringHex\\n     * @memberOf KJUR.asn1.DERAbstractString#\\n     * @function\\n     * @param {String} newHexString value by a hexadecimal string to set\\n     */\\n    this.setStringHex = function (newHexString) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.s = null;\\n        this.hV = newHexString;\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params == \\\"string\\\") {\\n            this.setString(params);\\n        }\\n        else if (typeof params['str'] != \\\"undefined\\\") {\\n            this.setString(params['str']);\\n        }\\n        else if (typeof params['hex'] != \\\"undefined\\\") {\\n            this.setStringHex(params['hex']);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);\\n// == END   DERAbstractString ================================================\\n// == BEGIN DERAbstractTime ==================================================\\n/**\\n * base class for ASN.1 DER Generalized/UTCTime class\\n * @name KJUR.asn1.DERAbstractTime\\n * @class base class for ASN.1 DER Generalized/UTCTime class\\n * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * @see KJUR.asn1.ASN1Object - superclass\\n */\\nKJUR.asn1.DERAbstractTime = function (params) {\\n    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);\\n    var s = null;\\n    var date = null;\\n    // --- PRIVATE METHODS --------------------\\n    this.localDateToUTC = function (d) {\\n        utc = d.getTime() + (d.getTimezoneOffset() * 60000);\\n        var utcDate = new Date(utc);\\n        return utcDate;\\n    };\\n    /*\\n     * format date string by Data object\\n     * @name formatDate\\n     * @memberOf KJUR.asn1.AbstractTime;\\n     * @param {Date} dateObject\\n     * @param {string} type 'utc' or 'gen'\\n     * @param {boolean} withMillis flag for with millisections or not\\n     * @description\\n     * 'withMillis' flag is supported from asn1 1.0.6.\\n     */\\n    this.formatDate = function (dateObject, type, withMillis) {\\n        var pad = this.zeroPadding;\\n        var d = this.localDateToUTC(dateObject);\\n        var year = String(d.getFullYear());\\n        if (type == 'utc')\\n            year = year.substr(2, 2);\\n        var month = pad(String(d.getMonth() + 1), 2);\\n        var day = pad(String(d.getDate()), 2);\\n        var hour = pad(String(d.getHours()), 2);\\n        var min = pad(String(d.getMinutes()), 2);\\n        var sec = pad(String(d.getSeconds()), 2);\\n        var s = year + month + day + hour + min + sec;\\n        if (withMillis === true) {\\n            var millis = d.getMilliseconds();\\n            if (millis != 0) {\\n                var sMillis = pad(String(millis), 3);\\n                sMillis = sMillis.replace(/[0]+$/, \\\"\\\");\\n                s = s + \\\".\\\" + sMillis;\\n            }\\n        }\\n        return s + \\\"Z\\\";\\n    };\\n    this.zeroPadding = function (s, len) {\\n        if (s.length >= len)\\n            return s;\\n        return new Array(len - s.length + 1).join('0') + s;\\n    };\\n    // --- PUBLIC METHODS --------------------\\n    /**\\n     * get string value of this string object\\n     * @name getString\\n     * @memberOf KJUR.asn1.DERAbstractTime#\\n     * @function\\n     * @return {String} string value of this time object\\n     */\\n    this.getString = function () {\\n        return this.s;\\n    };\\n    /**\\n     * set value by a string\\n     * @name setString\\n     * @memberOf KJUR.asn1.DERAbstractTime#\\n     * @function\\n     * @param {String} newS value by a string to set such like \\\"130430235959Z\\\"\\n     */\\n    this.setString = function (newS) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.s = newS;\\n        this.hV = stohex(newS);\\n    };\\n    /**\\n     * set value by a Date object\\n     * @name setByDateValue\\n     * @memberOf KJUR.asn1.DERAbstractTime#\\n     * @function\\n     * @param {Integer} year year of date (ex. 2013)\\n     * @param {Integer} month month of date between 1 and 12 (ex. 12)\\n     * @param {Integer} day day of month\\n     * @param {Integer} hour hours of date\\n     * @param {Integer} min minutes of date\\n     * @param {Integer} sec seconds of date\\n     */\\n    this.setByDateValue = function (year, month, day, hour, min, sec) {\\n        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));\\n        this.setByDate(dateObject);\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);\\n// == END   DERAbstractTime ==================================================\\n// == BEGIN DERAbstractStructured ============================================\\n/**\\n * base class for ASN.1 DER structured class\\n * @name KJUR.asn1.DERAbstractStructured\\n * @class base class for ASN.1 DER structured class\\n * @property {Array} asn1Array internal array of ASN1Object\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * @see KJUR.asn1.ASN1Object - superclass\\n */\\nKJUR.asn1.DERAbstractStructured = function (params) {\\n    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);\\n    var asn1Array = null;\\n    /**\\n     * set value by array of ASN1Object\\n     * @name setByASN1ObjectArray\\n     * @memberOf KJUR.asn1.DERAbstractStructured#\\n     * @function\\n     * @param {array} asn1ObjectArray array of ASN1Object to set\\n     */\\n    this.setByASN1ObjectArray = function (asn1ObjectArray) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.asn1Array = asn1ObjectArray;\\n    };\\n    /**\\n     * append an ASN1Object to internal array\\n     * @name appendASN1Object\\n     * @memberOf KJUR.asn1.DERAbstractStructured#\\n     * @function\\n     * @param {ASN1Object} asn1Object to add\\n     */\\n    this.appendASN1Object = function (asn1Object) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.asn1Array.push(asn1Object);\\n    };\\n    this.asn1Array = new Array();\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params['array'] != \\\"undefined\\\") {\\n            this.asn1Array = params['array'];\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n//  ASN.1 Object Classes\\n// ********************************************************************\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Boolean\\n * @name KJUR.asn1.DERBoolean\\n * @class class for ASN.1 DER Boolean\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * @see KJUR.asn1.ASN1Object - superclass\\n */\\nKJUR.asn1.DERBoolean = function () {\\n    KJUR.asn1.DERBoolean.superclass.constructor.call(this);\\n    this.hT = \\\"01\\\";\\n    this.hTLV = \\\"0101ff\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Integer\\n * @name KJUR.asn1.DERInteger\\n * @class class for ASN.1 DER Integer\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>int - specify initial ASN.1 value(V) by integer value</li>\\n * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n */\\nKJUR.asn1.DERInteger = function (params) {\\n    KJUR.asn1.DERInteger.superclass.constructor.call(this);\\n    this.hT = \\\"02\\\";\\n    /**\\n     * set value by Tom Wu's BigInteger object\\n     * @name setByBigInteger\\n     * @memberOf KJUR.asn1.DERInteger#\\n     * @function\\n     * @param {BigInteger} bigIntegerValue to set\\n     */\\n    this.setByBigInteger = function (bigIntegerValue) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);\\n    };\\n    /**\\n     * set value by integer value\\n     * @name setByInteger\\n     * @memberOf KJUR.asn1.DERInteger\\n     * @function\\n     * @param {Integer} integer value to set\\n     */\\n    this.setByInteger = function (intValue) {\\n        var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(String(intValue), 10);\\n        this.setByBigInteger(bi);\\n    };\\n    /**\\n     * set value by integer value\\n     * @name setValueHex\\n     * @memberOf KJUR.asn1.DERInteger#\\n     * @function\\n     * @param {String} hexadecimal string of integer value\\n     * @description\\n     * <br/>\\n     * NOTE: Value shall be represented by minimum octet length of\\n     * two's complement representation.\\n     * @example\\n     * new KJUR.asn1.DERInteger(123);\\n     * new KJUR.asn1.DERInteger({'int': 123});\\n     * new KJUR.asn1.DERInteger({'hex': '1fad'});\\n     */\\n    this.setValueHex = function (newHexString) {\\n        this.hV = newHexString;\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params['bigint'] != \\\"undefined\\\") {\\n            this.setByBigInteger(params['bigint']);\\n        }\\n        else if (typeof params['int'] != \\\"undefined\\\") {\\n            this.setByInteger(params['int']);\\n        }\\n        else if (typeof params == \\\"number\\\") {\\n            this.setByInteger(params);\\n        }\\n        else if (typeof params['hex'] != \\\"undefined\\\") {\\n            this.setValueHex(params['hex']);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER encoded BitString primitive\\n * @name KJUR.asn1.DERBitString\\n * @class class for ASN.1 DER encoded BitString primitive\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>bin - specify binary string (ex. '10111')</li>\\n * <li>array - specify array of boolean (ex. [true,false,true,true])</li>\\n * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>\\n * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}\\n * argument for \\\"BitString encapsulates\\\" structure.</li>\\n * </ul>\\n * NOTE1: 'params' can be omitted.<br/>\\n * NOTE2: 'obj' parameter have been supported since\\n * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>\\n * @example\\n * // default constructor\\n * o = new KJUR.asn1.DERBitString();\\n * // initialize with binary string\\n * o = new KJUR.asn1.DERBitString({bin: \\\"1011\\\"});\\n * // initialize with boolean array\\n * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});\\n * // initialize with hexadecimal string (04 is unused bits)\\n * o = new KJUR.asn1.DEROctetString({hex: \\\"04bac0\\\"});\\n * // initialize with ASN1Util.newObject argument for encapsulated\\n * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});\\n * // above generates a ASN.1 data like this:\\n * // BIT STRING, encapsulates {\\n * //   SEQUENCE {\\n * //     INTEGER 3\\n * //     PrintableString 'aaa'\\n * //     }\\n * //   }\\n */\\nKJUR.asn1.DERBitString = function (params) {\\n    if (params !== undefined && typeof params.obj !== \\\"undefined\\\") {\\n        var o = KJUR.asn1.ASN1Util.newObject(params.obj);\\n        params.hex = \\\"00\\\" + o.getEncodedHex();\\n    }\\n    KJUR.asn1.DERBitString.superclass.constructor.call(this);\\n    this.hT = \\\"03\\\";\\n    /**\\n     * set ASN.1 value(V) by a hexadecimal string including unused bits\\n     * @name setHexValueIncludingUnusedBits\\n     * @memberOf KJUR.asn1.DERBitString#\\n     * @function\\n     * @param {String} newHexStringIncludingUnusedBits\\n     */\\n    this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.hV = newHexStringIncludingUnusedBits;\\n    };\\n    /**\\n     * set ASN.1 value(V) by unused bit and hexadecimal string of value\\n     * @name setUnusedBitsAndHexValue\\n     * @memberOf KJUR.asn1.DERBitString#\\n     * @function\\n     * @param {Integer} unusedBits\\n     * @param {String} hValue\\n     */\\n    this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {\\n        if (unusedBits < 0 || 7 < unusedBits) {\\n            throw \\\"unused bits shall be from 0 to 7: u = \\\" + unusedBits;\\n        }\\n        var hUnusedBits = \\\"0\\\" + unusedBits;\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.hV = hUnusedBits + hValue;\\n    };\\n    /**\\n     * set ASN.1 DER BitString by binary string<br/>\\n     * @name setByBinaryString\\n     * @memberOf KJUR.asn1.DERBitString#\\n     * @function\\n     * @param {String} binaryString binary value string (i.e. '10111')\\n     * @description\\n     * Its unused bits will be calculated automatically by length of\\n     * 'binaryValue'. <br/>\\n     * NOTE: Trailing zeros '0' will be ignored.\\n     * @example\\n     * o = new KJUR.asn1.DERBitString();\\n     * o.setByBooleanArray(\\\"01011\\\");\\n     */\\n    this.setByBinaryString = function (binaryString) {\\n        binaryString = binaryString.replace(/0+$/, '');\\n        var unusedBits = 8 - binaryString.length % 8;\\n        if (unusedBits == 8)\\n            unusedBits = 0;\\n        for (var i = 0; i <= unusedBits; i++) {\\n            binaryString += '0';\\n        }\\n        var h = '';\\n        for (var i = 0; i < binaryString.length - 1; i += 8) {\\n            var b = binaryString.substr(i, 8);\\n            var x = parseInt(b, 2).toString(16);\\n            if (x.length == 1)\\n                x = '0' + x;\\n            h += x;\\n        }\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.hV = '0' + unusedBits + h;\\n    };\\n    /**\\n     * set ASN.1 TLV value(V) by an array of boolean<br/>\\n     * @name setByBooleanArray\\n     * @memberOf KJUR.asn1.DERBitString#\\n     * @function\\n     * @param {array} booleanArray array of boolean (ex. [true, false, true])\\n     * @description\\n     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.\\n     * @example\\n     * o = new KJUR.asn1.DERBitString();\\n     * o.setByBooleanArray([false, true, false, true, true]);\\n     */\\n    this.setByBooleanArray = function (booleanArray) {\\n        var s = '';\\n        for (var i = 0; i < booleanArray.length; i++) {\\n            if (booleanArray[i] == true) {\\n                s += '1';\\n            }\\n            else {\\n                s += '0';\\n            }\\n        }\\n        this.setByBinaryString(s);\\n    };\\n    /**\\n     * generate an array of falses with specified length<br/>\\n     * @name newFalseArray\\n     * @memberOf KJUR.asn1.DERBitString\\n     * @function\\n     * @param {Integer} nLength length of array to generate\\n     * @return {array} array of boolean falses\\n     * @description\\n     * This static method may be useful to initialize boolean array.\\n     * @example\\n     * o = new KJUR.asn1.DERBitString();\\n     * o.newFalseArray(3) &rarr; [false, false, false]\\n     */\\n    this.newFalseArray = function (nLength) {\\n        var a = new Array(nLength);\\n        for (var i = 0; i < nLength; i++) {\\n            a[i] = false;\\n        }\\n        return a;\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params == \\\"string\\\" && params.toLowerCase().match(/^[0-9a-f]+$/)) {\\n            this.setHexValueIncludingUnusedBits(params);\\n        }\\n        else if (typeof params['hex'] != \\\"undefined\\\") {\\n            this.setHexValueIncludingUnusedBits(params['hex']);\\n        }\\n        else if (typeof params['bin'] != \\\"undefined\\\") {\\n            this.setByBinaryString(params['bin']);\\n        }\\n        else if (typeof params['array'] != \\\"undefined\\\") {\\n            this.setByBooleanArray(params['array']);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER OctetString<br/>\\n * @name KJUR.asn1.DEROctetString\\n * @class class for ASN.1 DER OctetString\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * This class provides ASN.1 OctetString simple type.<br/>\\n * Supported \\\"params\\\" attributes are:\\n * <ul>\\n * <li>str - to set a string as a value</li>\\n * <li>hex - to set a hexadecimal string as a value</li>\\n * <li>obj - to set a encapsulated ASN.1 value by JSON object\\n * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>\\n * </ul>\\n * NOTE: A parameter 'obj' have been supported\\n * for \\\"OCTET STRING, encapsulates\\\" structure.\\n * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).\\n * @see KJUR.asn1.DERAbstractString - superclass\\n * @example\\n * // default constructor\\n * o = new KJUR.asn1.DEROctetString();\\n * // initialize with string\\n * o = new KJUR.asn1.DEROctetString({str: \\\"aaa\\\"});\\n * // initialize with hexadecimal string\\n * o = new KJUR.asn1.DEROctetString({hex: \\\"616161\\\"});\\n * // initialize with ASN1Util.newObject argument\\n * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});\\n * // above generates a ASN.1 data like this:\\n * // OCTET STRING, encapsulates {\\n * //   SEQUENCE {\\n * //     INTEGER 3\\n * //     PrintableString 'aaa'\\n * //     }\\n * //   }\\n */\\nKJUR.asn1.DEROctetString = function (params) {\\n    if (params !== undefined && typeof params.obj !== \\\"undefined\\\") {\\n        var o = KJUR.asn1.ASN1Util.newObject(params.obj);\\n        params.hex = o.getEncodedHex();\\n    }\\n    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);\\n    this.hT = \\\"04\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Null\\n * @name KJUR.asn1.DERNull\\n * @class class for ASN.1 DER Null\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * @see KJUR.asn1.ASN1Object - superclass\\n */\\nKJUR.asn1.DERNull = function () {\\n    KJUR.asn1.DERNull.superclass.constructor.call(this);\\n    this.hT = \\\"05\\\";\\n    this.hTLV = \\\"0500\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER ObjectIdentifier\\n * @name KJUR.asn1.DERObjectIdentifier\\n * @class class for ASN.1 DER ObjectIdentifier\\n * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n */\\nKJUR.asn1.DERObjectIdentifier = function (params) {\\n    var itox = function (i) {\\n        var h = i.toString(16);\\n        if (h.length == 1)\\n            h = '0' + h;\\n        return h;\\n    };\\n    var roidtox = function (roid) {\\n        var h = '';\\n        var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(roid, 10);\\n        var b = bi.toString(2);\\n        var padLen = 7 - b.length % 7;\\n        if (padLen == 7)\\n            padLen = 0;\\n        var bPad = '';\\n        for (var i = 0; i < padLen; i++)\\n            bPad += '0';\\n        b = bPad + b;\\n        for (var i = 0; i < b.length - 1; i += 7) {\\n            var b8 = b.substr(i, 7);\\n            if (i != b.length - 7)\\n                b8 = '1' + b8;\\n            h += itox(parseInt(b8, 2));\\n        }\\n        return h;\\n    };\\n    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);\\n    this.hT = \\\"06\\\";\\n    /**\\n     * set value by a hexadecimal string\\n     * @name setValueHex\\n     * @memberOf KJUR.asn1.DERObjectIdentifier#\\n     * @function\\n     * @param {String} newHexString hexadecimal value of OID bytes\\n     */\\n    this.setValueHex = function (newHexString) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.s = null;\\n        this.hV = newHexString;\\n    };\\n    /**\\n     * set value by a OID string<br/>\\n     * @name setValueOidString\\n     * @memberOf KJUR.asn1.DERObjectIdentifier#\\n     * @function\\n     * @param {String} oidString OID string (ex. 2.5.4.13)\\n     * @example\\n     * o = new KJUR.asn1.DERObjectIdentifier();\\n     * o.setValueOidString(\\\"2.5.4.13\\\");\\n     */\\n    this.setValueOidString = function (oidString) {\\n        if (!oidString.match(/^[0-9.]+$/)) {\\n            throw \\\"malformed oid string: \\\" + oidString;\\n        }\\n        var h = '';\\n        var a = oidString.split('.');\\n        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);\\n        h += itox(i0);\\n        a.splice(0, 2);\\n        for (var i = 0; i < a.length; i++) {\\n            h += roidtox(a[i]);\\n        }\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.s = null;\\n        this.hV = h;\\n    };\\n    /**\\n     * set value by a OID name\\n     * @name setValueName\\n     * @memberOf KJUR.asn1.DERObjectIdentifier#\\n     * @function\\n     * @param {String} oidName OID name (ex. 'serverAuth')\\n     * @since 1.0.1\\n     * @description\\n     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.\\n     * Otherwise raise error.\\n     * @example\\n     * o = new KJUR.asn1.DERObjectIdentifier();\\n     * o.setValueName(\\\"serverAuth\\\");\\n     */\\n    this.setValueName = function (oidName) {\\n        var oid = KJUR.asn1.x509.OID.name2oid(oidName);\\n        if (oid !== '') {\\n            this.setValueOidString(oid);\\n        }\\n        else {\\n            throw \\\"DERObjectIdentifier oidName undefined: \\\" + oidName;\\n        }\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (params !== undefined) {\\n        if (typeof params === \\\"string\\\") {\\n            if (params.match(/^[0-2].[0-9.]+$/)) {\\n                this.setValueOidString(params);\\n            }\\n            else {\\n                this.setValueName(params);\\n            }\\n        }\\n        else if (params.oid !== undefined) {\\n            this.setValueOidString(params.oid);\\n        }\\n        else if (params.hex !== undefined) {\\n            this.setValueHex(params.hex);\\n        }\\n        else if (params.name !== undefined) {\\n            this.setValueName(params.name);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Enumerated\\n * @name KJUR.asn1.DEREnumerated\\n * @class class for ASN.1 DER Enumerated\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>int - specify initial ASN.1 value(V) by integer value</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n * @example\\n * new KJUR.asn1.DEREnumerated(123);\\n * new KJUR.asn1.DEREnumerated({int: 123});\\n * new KJUR.asn1.DEREnumerated({hex: '1fad'});\\n */\\nKJUR.asn1.DEREnumerated = function (params) {\\n    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);\\n    this.hT = \\\"0a\\\";\\n    /**\\n     * set value by Tom Wu's BigInteger object\\n     * @name setByBigInteger\\n     * @memberOf KJUR.asn1.DEREnumerated#\\n     * @function\\n     * @param {BigInteger} bigIntegerValue to set\\n     */\\n    this.setByBigInteger = function (bigIntegerValue) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);\\n    };\\n    /**\\n     * set value by integer value\\n     * @name setByInteger\\n     * @memberOf KJUR.asn1.DEREnumerated#\\n     * @function\\n     * @param {Integer} integer value to set\\n     */\\n    this.setByInteger = function (intValue) {\\n        var bi = new _jsbn_jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(String(intValue), 10);\\n        this.setByBigInteger(bi);\\n    };\\n    /**\\n     * set value by integer value\\n     * @name setValueHex\\n     * @memberOf KJUR.asn1.DEREnumerated#\\n     * @function\\n     * @param {String} hexadecimal string of integer value\\n     * @description\\n     * <br/>\\n     * NOTE: Value shall be represented by minimum octet length of\\n     * two's complement representation.\\n     */\\n    this.setValueHex = function (newHexString) {\\n        this.hV = newHexString;\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params['int'] != \\\"undefined\\\") {\\n            this.setByInteger(params['int']);\\n        }\\n        else if (typeof params == \\\"number\\\") {\\n            this.setByInteger(params);\\n        }\\n        else if (typeof params['hex'] != \\\"undefined\\\") {\\n            this.setValueHex(params['hex']);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER UTF8String\\n * @name KJUR.asn1.DERUTF8String\\n * @class class for ASN.1 DER UTF8String\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * @see KJUR.asn1.DERAbstractString - superclass\\n */\\nKJUR.asn1.DERUTF8String = function (params) {\\n    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);\\n    this.hT = \\\"0c\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER NumericString\\n * @name KJUR.asn1.DERNumericString\\n * @class class for ASN.1 DER NumericString\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * @see KJUR.asn1.DERAbstractString - superclass\\n */\\nKJUR.asn1.DERNumericString = function (params) {\\n    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);\\n    this.hT = \\\"12\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER PrintableString\\n * @name KJUR.asn1.DERPrintableString\\n * @class class for ASN.1 DER PrintableString\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * @see KJUR.asn1.DERAbstractString - superclass\\n */\\nKJUR.asn1.DERPrintableString = function (params) {\\n    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);\\n    this.hT = \\\"13\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER TeletexString\\n * @name KJUR.asn1.DERTeletexString\\n * @class class for ASN.1 DER TeletexString\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * @see KJUR.asn1.DERAbstractString - superclass\\n */\\nKJUR.asn1.DERTeletexString = function (params) {\\n    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);\\n    this.hT = \\\"14\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER IA5String\\n * @name KJUR.asn1.DERIA5String\\n * @class class for ASN.1 DER IA5String\\n * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})\\n * @extends KJUR.asn1.DERAbstractString\\n * @description\\n * @see KJUR.asn1.DERAbstractString - superclass\\n */\\nKJUR.asn1.DERIA5String = function (params) {\\n    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);\\n    this.hT = \\\"16\\\";\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER UTCTime\\n * @name KJUR.asn1.DERUTCTime\\n * @class class for ASN.1 DER UTCTime\\n * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})\\n * @extends KJUR.asn1.DERAbstractTime\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * <li>date - specify Date object.</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n * <h4>EXAMPLES</h4>\\n * @example\\n * d1 = new KJUR.asn1.DERUTCTime();\\n * d1.setString('130430125959Z');\\n *\\n * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});\\n * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});\\n * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');\\n */\\nKJUR.asn1.DERUTCTime = function (params) {\\n    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);\\n    this.hT = \\\"17\\\";\\n    /**\\n     * set value by a Date object<br/>\\n     * @name setByDate\\n     * @memberOf KJUR.asn1.DERUTCTime#\\n     * @function\\n     * @param {Date} dateObject Date object to set ASN.1 value(V)\\n     * @example\\n     * o = new KJUR.asn1.DERUTCTime();\\n     * o.setByDate(new Date(\\\"2016/12/31\\\"));\\n     */\\n    this.setByDate = function (dateObject) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.date = dateObject;\\n        this.s = this.formatDate(this.date, 'utc');\\n        this.hV = stohex(this.s);\\n    };\\n    this.getFreshValueHex = function () {\\n        if (typeof this.date == \\\"undefined\\\" && typeof this.s == \\\"undefined\\\") {\\n            this.date = new Date();\\n            this.s = this.formatDate(this.date, 'utc');\\n            this.hV = stohex(this.s);\\n        }\\n        return this.hV;\\n    };\\n    if (params !== undefined) {\\n        if (params.str !== undefined) {\\n            this.setString(params.str);\\n        }\\n        else if (typeof params == \\\"string\\\" && params.match(/^[0-9]{12}Z$/)) {\\n            this.setString(params);\\n        }\\n        else if (params.hex !== undefined) {\\n            this.setStringHex(params.hex);\\n        }\\n        else if (params.date !== undefined) {\\n            this.setByDate(params.date);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER GeneralizedTime\\n * @name KJUR.asn1.DERGeneralizedTime\\n * @class class for ASN.1 DER GeneralizedTime\\n * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})\\n * @property {Boolean} withMillis flag to show milliseconds or not\\n * @extends KJUR.asn1.DERAbstractTime\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>\\n * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>\\n * <li>date - specify Date object.</li>\\n * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>\\n * </ul>\\n * NOTE1: 'params' can be omitted.\\n * NOTE2: 'withMillis' property is supported from asn1 1.0.6.\\n */\\nKJUR.asn1.DERGeneralizedTime = function (params) {\\n    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);\\n    this.hT = \\\"18\\\";\\n    this.withMillis = false;\\n    /**\\n     * set value by a Date object\\n     * @name setByDate\\n     * @memberOf KJUR.asn1.DERGeneralizedTime#\\n     * @function\\n     * @param {Date} dateObject Date object to set ASN.1 value(V)\\n     * @example\\n     * When you specify UTC time, use 'Date.UTC' method like this:<br/>\\n     * o1 = new DERUTCTime();\\n     * o1.setByDate(date);\\n     *\\n     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59\\n     */\\n    this.setByDate = function (dateObject) {\\n        this.hTLV = null;\\n        this.isModified = true;\\n        this.date = dateObject;\\n        this.s = this.formatDate(this.date, 'gen', this.withMillis);\\n        this.hV = stohex(this.s);\\n    };\\n    this.getFreshValueHex = function () {\\n        if (this.date === undefined && this.s === undefined) {\\n            this.date = new Date();\\n            this.s = this.formatDate(this.date, 'gen', this.withMillis);\\n            this.hV = stohex(this.s);\\n        }\\n        return this.hV;\\n    };\\n    if (params !== undefined) {\\n        if (params.str !== undefined) {\\n            this.setString(params.str);\\n        }\\n        else if (typeof params == \\\"string\\\" && params.match(/^[0-9]{14}Z$/)) {\\n            this.setString(params);\\n        }\\n        else if (params.hex !== undefined) {\\n            this.setStringHex(params.hex);\\n        }\\n        else if (params.date !== undefined) {\\n            this.setByDate(params.date);\\n        }\\n        if (params.millis === true) {\\n            this.withMillis = true;\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Sequence\\n * @name KJUR.asn1.DERSequence\\n * @class class for ASN.1 DER Sequence\\n * @extends KJUR.asn1.DERAbstractStructured\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>array - specify array of ASN1Object to set elements of content</li>\\n * </ul>\\n * NOTE: 'params' can be omitted.\\n */\\nKJUR.asn1.DERSequence = function (params) {\\n    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);\\n    this.hT = \\\"30\\\";\\n    this.getFreshValueHex = function () {\\n        var h = '';\\n        for (var i = 0; i < this.asn1Array.length; i++) {\\n            var asn1Obj = this.asn1Array[i];\\n            h += asn1Obj.getEncodedHex();\\n        }\\n        this.hV = h;\\n        return this.hV;\\n    };\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER Set\\n * @name KJUR.asn1.DERSet\\n * @class class for ASN.1 DER Set\\n * @extends KJUR.asn1.DERAbstractStructured\\n * @description\\n * <br/>\\n * As for argument 'params' for constructor, you can specify one of\\n * following properties:\\n * <ul>\\n * <li>array - specify array of ASN1Object to set elements of content</li>\\n * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>\\n * </ul>\\n * NOTE1: 'params' can be omitted.<br/>\\n * NOTE2: sortflag is supported since 1.0.5.\\n */\\nKJUR.asn1.DERSet = function (params) {\\n    KJUR.asn1.DERSet.superclass.constructor.call(this, params);\\n    this.hT = \\\"31\\\";\\n    this.sortFlag = true; // item shall be sorted only in ASN.1 DER\\n    this.getFreshValueHex = function () {\\n        var a = new Array();\\n        for (var i = 0; i < this.asn1Array.length; i++) {\\n            var asn1Obj = this.asn1Array[i];\\n            a.push(asn1Obj.getEncodedHex());\\n        }\\n        if (this.sortFlag == true)\\n            a.sort();\\n        this.hV = a.join('');\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params.sortflag != \\\"undefined\\\" &&\\n            params.sortflag == false)\\n            this.sortFlag = false;\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);\\n// ********************************************************************\\n/**\\n * class for ASN.1 DER TaggedObject\\n * @name KJUR.asn1.DERTaggedObject\\n * @class class for ASN.1 DER TaggedObject\\n * @extends KJUR.asn1.ASN1Object\\n * @description\\n * <br/>\\n * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.\\n * For example, if you find '[1]' tag in a ASN.1 dump,\\n * 'tagNoHex' will be 'a1'.\\n * <br/>\\n * As for optional argument 'params' for constructor, you can specify *ANY* of\\n * following properties:\\n * <ul>\\n * <li>explicit - specify true if this is explicit tag otherwise false\\n *     (default is 'true').</li>\\n * <li>tag - specify tag (default is 'a0' which means [0])</li>\\n * <li>obj - specify ASN1Object which is tagged</li>\\n * </ul>\\n * @example\\n * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});\\n * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});\\n * hex = d2.getEncodedHex();\\n */\\nKJUR.asn1.DERTaggedObject = function (params) {\\n    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);\\n    this.hT = \\\"a0\\\";\\n    this.hV = '';\\n    this.isExplicit = true;\\n    this.asn1Object = null;\\n    /**\\n     * set value by an ASN1Object\\n     * @name setString\\n     * @memberOf KJUR.asn1.DERTaggedObject#\\n     * @function\\n     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag\\n     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag\\n     * @param {ASN1Object} asn1Object ASN.1 to encapsulate\\n     */\\n    this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {\\n        this.hT = tagNoHex;\\n        this.isExplicit = isExplicitFlag;\\n        this.asn1Object = asn1Object;\\n        if (this.isExplicit) {\\n            this.hV = this.asn1Object.getEncodedHex();\\n            this.hTLV = null;\\n            this.isModified = true;\\n        }\\n        else {\\n            this.hV = null;\\n            this.hTLV = asn1Object.getEncodedHex();\\n            this.hTLV = this.hTLV.replace(/^../, tagNoHex);\\n            this.isModified = false;\\n        }\\n    };\\n    this.getFreshValueHex = function () {\\n        return this.hV;\\n    };\\n    if (typeof params != \\\"undefined\\\") {\\n        if (typeof params['tag'] != \\\"undefined\\\") {\\n            this.hT = params['tag'];\\n        }\\n        if (typeof params['explicit'] != \\\"undefined\\\") {\\n            this.isExplicit = params['explicit'];\\n        }\\n        if (typeof params['obj'] != \\\"undefined\\\") {\\n            this.asn1Object = params['obj'];\\n            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);\\n        }\\n    }\\n};\\n_yahoo__WEBPACK_IMPORTED_MODULE_1__.YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsrsasign/asn1-1.0.js?\");\n\n/***/ }),\n\n/***/ \"./lib/lib/jsrsasign/yahoo.js\":\n/*!************************************!*\\\n  !*** ./lib/lib/jsrsasign/yahoo.js ***!\n  \\************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"YAHOO\\\": () => (/* binding */ YAHOO)\\n/* harmony export */ });\\n/*!\\nCopyright (c) 2011, Yahoo! Inc. All rights reserved.\\nCode licensed under the BSD License:\\nhttp://developer.yahoo.com/yui/license.html\\nversion: 2.9.0\\n*/\\nvar YAHOO = {};\\nYAHOO.lang = {\\n    /**\\n     * Utility to set up the prototype, constructor and superclass properties to\\n     * support an inheritance strategy that can chain constructors and methods.\\n     * Static members will not be inherited.\\n     *\\n     * @method extend\\n     * @static\\n     * @param {Function} subc   the object to modify\\n     * @param {Function} superc the object to inherit\\n     * @param {Object} overrides  additional properties/methods to add to the\\n     *                              subclass prototype.  These will override the\\n     *                              matching items obtained from the superclass\\n     *                              if present.\\n     */\\n    extend: function (subc, superc, overrides) {\\n        if (!superc || !subc) {\\n            throw new Error(\\\"YAHOO.lang.extend failed, please check that \\\" +\\n                \\\"all dependencies are included.\\\");\\n        }\\n        var F = function () { };\\n        F.prototype = superc.prototype;\\n        subc.prototype = new F();\\n        subc.prototype.constructor = subc;\\n        subc.superclass = superc.prototype;\\n        if (superc.prototype.constructor == Object.prototype.constructor) {\\n            superc.prototype.constructor = superc;\\n        }\\n        if (overrides) {\\n            var i;\\n            for (i in overrides) {\\n                subc.prototype[i] = overrides[i];\\n            }\\n            /*\\n             * IE will not enumerate native functions in a derived object even if the\\n             * function was overridden.  This is a workaround for specific functions\\n             * we care about on the Object prototype.\\n             * @property _IEEnumFix\\n             * @param {Function} r  the object to receive the augmentation\\n             * @param {Function} s  the object that supplies the properties to augment\\n             * @static\\n             * @private\\n             */\\n            var _IEEnumFix = function () { }, ADD = [\\\"toString\\\", \\\"valueOf\\\"];\\n            try {\\n                if (/MSIE/.test(navigator.userAgent)) {\\n                    _IEEnumFix = function (r, s) {\\n                        for (i = 0; i < ADD.length; i = i + 1) {\\n                            var fname = ADD[i], f = s[fname];\\n                            if (typeof f === 'function' && f != Object.prototype[fname]) {\\n                                r[fname] = f;\\n                            }\\n                        }\\n                    };\\n                }\\n            }\\n            catch (ex) { }\\n            ;\\n            _IEEnumFix(subc.prototype, overrides);\\n        }\\n    }\\n};\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./lib/lib/jsrsasign/yahoo.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/process/browser.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/process/browser.js ***!\n  \\*****************************************/\n/***/ ((module) => {\n\neval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n\\n//# sourceURL=webpack://JSEncrypt/./node_modules/process/browser.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_210803__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_210803__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_210803__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_210803__.o(definition, key) && !__nested_webpack_require_210803__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_210803__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_210803__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_210803__(\"./lib/index.js\");\n/******/ \t__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2Jpbi9qc2VuY3J5cHQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLMEI7QUFDaEMsQ0FBQztBQUNELHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELG1FQUFtRSwrRkFBK0YsRUFBRSxzSkFBc0osc0pBQXNKLDRIQUE0SCxTQUFTLDZJQUE2SSxzQkFBc0IsUUFBUSxhQUFhLDJHQUEyRyxTQUFTLGlFQUFpRSxTQUFTLHVHQUF1RyxTQUFTLGdIQUFnSCxtQ0FBbUMsb0NBQW9DLGVBQWUsa0NBQWtDLHFJQUFxSSx3RkFBd0YsbUdBQW1HLGtFQUFrRSxPQUFPLHFQQUFxUCxlQUFlLG1KQUFtSixxQ0FBcUMsNEVBQTRFLFdBQVcsNEZBQTRGLFFBQVEsMktBQTJLLDJEQUEyRCxRQUFRLHlLQUF5SywrREFBK0QsUUFBUSxrVEFBa1QsUUFBUSw4REFBOEQsUUFBUSxpR0FBaUcsd0RBQXdELDRHQUE0RyxXQUFXLHNCQUFzQiwyQkFBMkIsV0FBVyxRQUFRLGlUQUFpVCxRQUFRLDJDQUEyQyxRQUFRLG1IQUFtSCx3REFBd0QsMkdBQTJHLFdBQVcsc0JBQXNCLDJCQUEyQixXQUFXLFFBQVEseUVBQXlFLFFBQVEsdUNBQXVDLFVBQVUseUNBQXlDLFFBQVEsMkRBQTJELFFBQVEsbUlBQW1JLDhFQUE4RSxrSUFBa0ksV0FBVyxzQkFBc0IsMkJBQTJCLFdBQVcsUUFBUSwyRUFBMkUsUUFBUSx5Q0FBeUMsUUFBUSxtRkFBbUYsVUFBVSwwQ0FBMEMsU0FBUyx5SUFBeUksMkVBQTJFLG9JQUFvSSxXQUFXLHNCQUFzQiwyQkFBMkIsV0FBVyxRQUFRLHdKQUF3SixVQUFVLGdIQUFnSCxpQkFBaUIscUdBQXFHLDRFQUE0RSxvSUFBb0ksMEJBQTBCLCtDQUEr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QU8sSUFBSSxnRUFBZ0UscUJBQXFCLHlCQUF5QixHQUFHLG9DQUFvQyx1Q0FBdUMsSUFBSSw0QkFBNEIseUJBQXlCLG1CQUFtQixvQkFBb0Isd0JBQXdCLDhEQUE4RCxzQkFBc0Isc0JBQXNCLDZCQUE2QixzQkFBc0IscUJBQXFCLGdDQUFnQyxvQ0FBb0Msc0JBQXNCLGlDQUFpQyxxQ0FBcUMsMENBQTBDLFdBQVcsdUNBQXVDLDBEQUEwRCxJQUFJLGdDQUFnQyxhQUFhLGtDQUFrQyx3REFBd0QsSUFBSSwrQkFBK0IsWUFBWTs7QUFFdCtLLE9BQU87O0FBRVAsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlDQUFtQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QjtBQUNBLGdCQUFnQixpQ0FBbUIsd0JBQXdCLGlDQUFtQjtBQUM5RSxvREFBb0Qsd0NBQXdDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QjtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUFtQixHQUFHLGlDQUFtQjtBQUN2RCxVQUFVLDBCQUFtQixHQUFHLDBCQUFtQjtBQUNuRDtBQUNBLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzYS10b2tlbi1nZW5lcmF0b3IvLi9ub2RlX21vZHVsZXMvanNlbmNyeXB0L2Jpbi9qc2VuY3J5cHQuanM/MjJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkpTRW5jcnlwdFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJKU0VuY3J5cHRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2xpYi9KU0VuY3J5cHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbGliL0pTRW5jcnlwdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkpTRW5jcnlwdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEpTRW5jcnlwdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl9qc2JuX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvanNibi9iYXNlNjQgKi8gXFxcIi4vbGliL2xpYi9qc2JuL2Jhc2U2NC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfSlNFbmNyeXB0UlNBS2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0pTRW5jcnlwdFJTQUtleSAqLyBcXFwiLi9saWIvSlNFbmNyeXB0UlNBS2V5LmpzXFxcIik7XFxuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHByb2Nlc3MvYnJvd3NlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIik7XFxudmFyIF9hO1xcblxcblxcbnZhciB2ZXJzaW9uID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXFxuICAgID8gKF9hID0gcHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBcXFwiMy4zLjJcXFwiXFxuICAgIDogdW5kZWZpbmVkO1xcbi8qKlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zID0ge31dIC0gQW4gb2JqZWN0IHRvIGN1c3RvbWl6ZSBKU0VuY3J5cHQgYmVoYXZpb3VyXFxuICogcG9zc2libGUgcGFyYW1ldGVycyBhcmU6XFxuICogLSBkZWZhdWx0X2tleV9zaXplICAgICAgICB7bnVtYmVyfSAgZGVmYXVsdDogMTAyNCB0aGUga2V5IHNpemUgaW4gYml0XFxuICogLSBkZWZhdWx0X3B1YmxpY19leHBvbmVudCB7c3RyaW5nfSAgZGVmYXVsdDogJzAxMDAwMScgdGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMgZXhwb25lbnRcXG4gKiAtIGxvZyAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBkZWZhdWx0OiBmYWxzZSB3aGV0aGVyIGxvZyB3YXJuL2Vycm9yIG9yIG5vdFxcbiAqIEBjb25zdHJ1Y3RvclxcbiAqL1xcbnZhciBKU0VuY3J5cHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdChvcHRpb25zKSB7XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgICAgICB0aGlzLmRlZmF1bHRfa2V5X3NpemUgPSBvcHRpb25zLmRlZmF1bHRfa2V5X3NpemVcXG4gICAgICAgICAgICA/IHBhcnNlSW50KG9wdGlvbnMuZGVmYXVsdF9rZXlfc2l6ZSwgMTApXFxuICAgICAgICAgICAgOiAxMDI0O1xcbiAgICAgICAgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCA9IG9wdGlvbnMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQgfHwgXFxcIjAxMDAwMVxcXCI7IC8vIDY1NTM3IGRlZmF1bHQgb3BlbnNzbCBwdWJsaWMgZXhwb25lbnQgZm9yIHJzYSBrZXkgdHlwZVxcbiAgICAgICAgdGhpcy5sb2cgPSBvcHRpb25zLmxvZyB8fCBmYWxzZTtcXG4gICAgICAgIC8vIFRoZSBwcml2YXRlIGFuZCBwdWJsaWMga2V5LlxcbiAgICAgICAgdGhpcy5rZXkgPSBudWxsO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBNZXRob2QgdG8gc2V0IHRoZSByc2Ega2V5IHBhcmFtZXRlciAob25lIG1ldGhvZCBpcyBlbm91Z2ggdG8gc2V0IGJvdGggdGhlIHB1YmxpY1xcbiAgICAgKiBhbmQgdGhlIHByaXZhdGUga2V5LCBzaW5jZSB0aGUgcHJpdmF0ZSBrZXkgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgcGFyYW1lbnRlcnMpXFxuICAgICAqIExvZyBhIHdhcm5pbmcgaWYgbG9ncyBhcmUgZW5hYmxlZFxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleSB0aGUgcGVtIGVuY29kZWQgc3RyaW5nIG9yIGFuIG9iamVjdCAod2l0aCBvciB3aXRob3V0IGhlYWRlci9mb290ZXIpXFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgaWYgKHRoaXMubG9nICYmIHRoaXMua2V5KSB7XFxuICAgICAgICAgICAgY29uc29sZS53YXJuKFxcXCJBIGtleSB3YXMgYWxyZWFkeSBzZXQsIG92ZXJyaWRpbmcgZXhpc3RpbmcuXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmtleSA9IG5ldyBfSlNFbmNyeXB0UlNBS2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uSlNFbmNyeXB0UlNBS2V5KGtleSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIHNldEtleSwgZm9yIGFwaSBjb21wYXRpYmlsaXR5XFxuICAgICAqIEBzZWUgc2V0S2V5XFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2a2V5KSB7XFxuICAgICAgICAvLyBDcmVhdGUgdGhlIGtleS5cXG4gICAgICAgIHRoaXMuc2V0S2V5KHByaXZrZXkpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBzZXRLZXksIGZvciBhcGkgY29tcGF0aWJpbGl0eVxcbiAgICAgKiBAc2VlIHNldEtleVxcbiAgICAgKiBAcHVibGljXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWJrZXkpIHtcXG4gICAgICAgIC8vIFNldHMgdGhlIHB1YmxpYyBrZXkuXFxuICAgICAgICB0aGlzLnNldEtleShwdWJrZXkpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgZGVjcnlwdCwgZGVjcnlwdCB0aGUgc3RyaW5nIHVzaW5nIHRoZSBwcml2YXRlXFxuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJzYSBrZXkgb2JqZWN0LiBOb3RlIHRoYXQgaWYgdGhlIG9iamVjdCB3YXMgbm90IHNldCB3aWxsIGJlIGNyZWF0ZWRcXG4gICAgICogb24gdGhlIGZseSAoYnkgdGhlIGdldEtleSBtZXRob2QpIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBpbiB0aGUgSlNFbmNyeXB0IGNvbnN0cnVjdG9yXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgYmFzZTY0IGVuY29kZWQgY3J5cHRlZCBzdHJpbmcgdG8gZGVjcnlwdFxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkZWNyeXB0ZWQgc3RyaW5nXFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgICAgIC8vIFJldHVybiB0aGUgZGVjcnlwdGVkIHN0cmluZy5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZGVjcnlwdCgoMCxfbGliX2pzYm5fYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYjY0dG9oZXgpKHN0cikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgZW5jcnlwdCwgZW5jcnlwdCB0aGUgc3RyaW5nIHVzaW5nIHRoZSBwdWJsaWNcXG4gICAgICogY29tcG9uZW50cyBvZiB0aGUgcnNhIGtleSBvYmplY3QuIE5vdGUgdGhhdCBpZiB0aGUgb2JqZWN0IHdhcyBub3Qgc2V0IHdpbGwgYmUgY3JlYXRlZFxcbiAgICAgKiBvbiB0aGUgZmx5IChieSB0aGUgZ2V0S2V5IG1ldGhvZCkgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIGluIHRoZSBKU0VuY3J5cHQgY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVuY3J5cHRcXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZW5jcnlwdGVkIHN0cmluZyBlbmNvZGVkIGluIGJhc2U2NFxcbiAgICAgKiBAcHVibGljXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVuY3J5cHRlZCBzdHJpbmcuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHJldHVybiAoMCxfbGliX2pzYm5fYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaGV4MmI2NCkodGhpcy5nZXRLZXkoKS5lbmNyeXB0KHN0cikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3Mgc2lnbi5cXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHNpZ25cXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnZXN0TWV0aG9kIGhhc2ggbWV0aG9kXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWdlc3ROYW1lIHRoZSBuYW1lIG9mIHRoZSBoYXNoIGFsZ29yaXRobVxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzaWduYXR1cmUgZW5jb2RlZCBpbiBiYXNlNjRcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKHN0ciwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSB7XFxuICAgICAgICAvLyByZXR1cm4gdGhlIFJTQSBzaWduYXR1cmUgb2YgJ3N0cicgaW4gJ2hleCcgZm9ybWF0LlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gKDAsX2xpYl9qc2JuX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmhleDJiNjQpKHRoaXMuZ2V0S2V5KCkuc2lnbihzdHIsIGRpZ2VzdE1ldGhvZCwgZGlnZXN0TmFtZSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgdmVyaWZ5LlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSBlbmNvZGVkIGluIGJhc2U2NCB0byBjb21wYXJlIHRoZSBzdHJpbmcgdG9cXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnZXN0TWV0aG9kIGhhc2ggbWV0aG9kXFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGRhdGEgYW5kIHNpZ25hdHVyZSBtYXRjaFxcbiAgICAgKiBAcHVibGljXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChzdHIsIHNpZ25hdHVyZSwgZGlnZXN0TWV0aG9kKSB7XFxuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlY3J5cHRlZCAnZGlnZXN0JyBvZiB0aGUgc2lnbmF0dXJlLlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS52ZXJpZnkoc3RyLCAoMCxfbGliX2pzYm5fYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uYjY0dG9oZXgpKHNpZ25hdHVyZSksIGRpZ2VzdE1ldGhvZCk7XFxuICAgICAgICB9XFxuICAgICAgICBjYXRjaCAoZXgpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBHZXR0ZXIgZm9yIHRoZSBjdXJyZW50IEpTRW5jcnlwdFJTQUtleSBvYmplY3QuIElmIGl0IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IG9iamVjdFxcbiAgICAgKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkXFxuICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IFtjYl0gdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiB3ZSB3YW50IHRoZSBrZXkgdG8gYmUgZ2VuZXJhdGVkXFxuICAgICAqIGluIGFuIGFzeW5jIGZhc2hpb25cXG4gICAgICogQHJldHVybnMge0pTRW5jcnlwdFJTQUtleX0gdGhlIEpTRW5jcnlwdFJTQUtleSBvYmplY3RcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoY2IpIHtcXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIG5ldyBpZiBpdCBkb2VzIG5vdCBleGlzdC5cXG4gICAgICAgIGlmICghdGhpcy5rZXkpIHtcXG4gICAgICAgICAgICAvLyBHZXQgYSBuZXcgcHJpdmF0ZSBrZXkuXFxuICAgICAgICAgICAgdGhpcy5rZXkgPSBuZXcgX0pTRW5jcnlwdFJTQUtleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkpTRW5jcnlwdFJTQUtleSgpO1xcbiAgICAgICAgICAgIGlmIChjYiAmJiB7fS50b1N0cmluZy5jYWxsKGNiKSA9PT0gXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLmtleS5nZW5lcmF0ZUFzeW5jKHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSwgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCwgY2IpO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBrZXkuXFxuICAgICAgICAgICAgdGhpcy5rZXkuZ2VuZXJhdGUodGhpcy5kZWZhdWx0X2tleV9zaXplLCB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleSgpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XFxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkgV0lUSE9VVCBoZWFkZXIgYW5kIGZvb3RlclxcbiAgICAgKiBAcHVibGljXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFByaXZhdGVLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQcml2YXRlQmFzZUtleUI2NCgpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUmV0dXJucyB0aGUgcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcXG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IFdJVEggaGVhZGVyIGFuZCBmb290ZXJcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBSZXR1cm4gdGhlIHByaXZhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBrZXkuXFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQdWJsaWNLZXkoKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XFxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBXSVRIT1VUIGhlYWRlciBhbmQgZm9vdGVyXFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHVibGljS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHVibGljQmFzZUtleUI2NCgpO1xcbiAgICB9O1xcbiAgICBKU0VuY3J5cHQudmVyc2lvbiA9IHZlcnNpb247XFxuICAgIHJldHVybiBKU0VuY3J5cHQ7XFxufSgpKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9KU0VuY3J5cHQvLi9saWIvSlNFbmNyeXB0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9saWIvSlNFbmNyeXB0UlNBS2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9KU0VuY3J5cHRSU0FLZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJKU0VuY3J5cHRSU0FLZXlcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBKU0VuY3J5cHRSU0FLZXkpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJfanNibl9iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2pzYm4vYmFzZTY0ICovIFxcXCIuL2xpYi9saWIvanNibi9iYXNlNjQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl9hc24xanNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9hc24xanMvaGV4ICovIFxcXCIuL2xpYi9saWIvYXNuMWpzL2hleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGliX2FzbjFqc19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2FzbjFqcy9iYXNlNjQgKi8gXFxcIi4vbGliL2xpYi9hc24xanMvYmFzZTY0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJfYXNuMWpzX2FzbjFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2FzbjFqcy9hc24xICovIFxcXCIuL2xpYi9saWIvYXNuMWpzL2FzbjEuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl9qc2JuX3JzYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvanNibi9yc2EgKi8gXFxcIi4vbGliL2xpYi9qc2JuL3JzYS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvanNibi9qc2JuICovIFxcXCIuL2xpYi9saWIvanNibi9qc2JuLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJfanNyc2FzaWduX2FzbjFfMV8wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjAgKi8gXFxcIi4vbGliL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjAuanNcXFwiKTtcXG52YXIgX19leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBKU0VuY3J5cHRSU0FLZXkgdGhhdCBleHRlbmRzIFRvbSBXdSdzIFJTQSBrZXkgb2JqZWN0LlxcbiAqIFRoaXMgb2JqZWN0IGlzIGp1c3QgYSBkZWNvcmF0b3IgZm9yIHBhcnNpbmcgdGhlIGtleSBwYXJhbWV0ZXJcXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleSAtIFRoZSBrZXkgaW4gc3RyaW5nIGZvcm1hdCwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcXG4gKiB0aGUgcGFyYW1ldGVycyBuZWVkZWQgdG8gYnVpbGQgYSBSU0FLZXkgb2JqZWN0LlxcbiAqIEBjb25zdHJ1Y3RvclxcbiAqL1xcbnZhciBKU0VuY3J5cHRSU0FLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhKU0VuY3J5cHRSU0FLZXksIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdFJTQUtleShrZXkpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XFxuICAgICAgICAvLyBDYWxsIHRoZSBzdXBlciBjb25zdHJ1Y3Rvci5cXG4gICAgICAgIC8vICBSU0FLZXkuY2FsbCh0aGlzKTtcXG4gICAgICAgIC8vIElmIGEga2V5IGtleSB3YXMgcHJvdmlkZWQuXFxuICAgICAgICBpZiAoa2V5KSB7XFxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmluZy4uLlxcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUtleShrZXkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChKU0VuY3J5cHRSU0FLZXkuaGFzUHJpdmF0ZUtleVByb3BlcnR5KGtleSkgfHxcXG4gICAgICAgICAgICAgICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1B1YmxpY0tleVByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZXMgZm9yIHRoZSBrZXkuXFxuICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlUHJvcGVydGllc0Zyb20oa2V5KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE1ldGhvZCB0byBwYXJzZSBhIHBlbSBlbmNvZGVkIHN0cmluZyBjb250YWluaW5nIGJvdGggYSBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkuXFxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCB0cmFuc2xhdGUgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyBpbiBhIGRlciBlbmNvZGVkIHN0cmluZyBhbmRcXG4gICAgICogd2lsbCBwYXJzZSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleSBwYXJhbWV0ZXJzLiBUaGlzIG1ldGhvZCBhY2NlcHRzIHB1YmxpYyBrZXlcXG4gICAgICogaW4gdGhlIHJzYWVuY3J5cHRpb24gcGtjcyAjMSBmb3JtYXQgKG9pZDogMS4yLjg0MC4xMTM1NDkuMS4xLjEpLlxcbiAgICAgKlxcbiAgICAgKiBAdG9kbyBDaGVjayBob3cgbWFueSByc2EgZm9ybWF0cyB1c2UgdGhlIHNhbWUgZm9ybWF0IG9mIHBrY3MgIzEuXFxuICAgICAqXFxuICAgICAqIFRoZSBmb3JtYXQgaXMgZGVmaW5lZCBhczpcXG4gICAgICogUHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxcbiAgICAgKiAgIFB1YmxpY0tleSAgICAgICBCSVQgU1RSSU5HXFxuICAgICAqIH1cXG4gICAgICogV2hlcmUgQWxnb3JpdGhtSWRlbnRpZmllciBpczpcXG4gICAgICogQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gU0VRVUVOQ0Uge1xcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBPQkpFQ1QgSURFTlRJRklFUiwgICAgIHRoZSBPSUQgb2YgdGhlIGVuYyBhbGdvcml0aG1cXG4gICAgICogICBwYXJhbWV0ZXJzICAgICAgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMIChOVUxMIGZvciBQS0NTICMxKVxcbiAgICAgKiB9XFxuICAgICAqIGFuZCBQdWJsaWNLZXkgaXMgYSBTRVFVRU5DRSBlbmNhcHN1bGF0ZWQgaW4gYSBCSVQgU1RSSU5HXFxuICAgICAqIFJTQVB1YmxpY0tleSA6Oj0gU0VRVUVOQ0Uge1xcbiAgICAgKiAgIG1vZHVsdXMgICAgICAgICAgIElOVEVHRVIsICAtLSBuXFxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiAgIC0tIGVcXG4gICAgICogfVxcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRvIGV4YW1pbmUgdGhlIHN0cnVjdHVyZSBvZiB0aGUga2V5cyBvYnRhaW5lZCBmcm9tIG9wZW5zc2wgdXNpbmdcXG4gICAgICogYW4gYXNuLjEgZHVtcGVyIGFzIHRoZSBvbmUgdXNlZCBoZXJlIHRvIHBhcnNlIHRoZSBjb21wb25lbnRzOiBodHRwOi8vbGFwby5pdC9hc24xanMvXFxuICAgICAqIEBhcmd1bWVudCB7c3RyaW5nfSBwZW0gdGhlIHBlbSBlbmNvZGVkIHN0cmluZywgY2FuIGluY2x1ZGUgdGhlIEJFR0lOL0VORCBoZWFkZXIvZm9vdGVyXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLnBhcnNlS2V5ID0gZnVuY3Rpb24gKHBlbSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB2YXIgbW9kdWx1cyA9IDA7XFxuICAgICAgICAgICAgdmFyIHB1YmxpY19leHBvbmVudCA9IDA7XFxuICAgICAgICAgICAgdmFyIHJlSGV4ID0gL15cXFxccyooPzpbMC05QS1GYS1mXVswLTlBLUZhLWZdXFxcXHMqKSskLztcXG4gICAgICAgICAgICB2YXIgZGVyID0gcmVIZXgudGVzdChwZW0pID8gX2xpYl9hc24xanNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uSGV4LmRlY29kZShwZW0pIDogX2xpYl9hc24xanNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uQmFzZTY0LnVuYXJtb3IocGVtKTtcXG4gICAgICAgICAgICB2YXIgYXNuMSA9IF9saWJfYXNuMWpzX2FzbjFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5BU04xLmRlY29kZShkZXIpO1xcbiAgICAgICAgICAgIC8vIEZpeGVzIGEgYnVnIHdpdGggT3BlblNTTCAxLjArIHByaXZhdGUga2V5c1xcbiAgICAgICAgICAgIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDMpIHtcXG4gICAgICAgICAgICAgICAgYXNuMSA9IGFzbjEuc3ViWzJdLnN1YlswXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGFzbjEuc3ViLmxlbmd0aCA9PT0gOSkge1xcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgcHJpdmF0ZSBrZXkuXFxuICAgICAgICAgICAgICAgIG1vZHVsdXMgPSBhc24xLnN1YlsxXS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcXG4gICAgICAgICAgICAgICAgdGhpcy5uID0gKDAsX2xpYl9qc2JuX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5wYXJzZUJpZ0ludCkobW9kdWx1cywgMTYpO1xcbiAgICAgICAgICAgICAgICBwdWJsaWNfZXhwb25lbnQgPSBhc24xLnN1YlsyXS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBpbnRcXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQocHVibGljX2V4cG9uZW50LCAxNik7XFxuICAgICAgICAgICAgICAgIHZhciBwcml2YXRlX2V4cG9uZW50ID0gYXNuMS5zdWJbM10uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XFxuICAgICAgICAgICAgICAgIHRoaXMuZCA9ICgwLF9saWJfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ucGFyc2VCaWdJbnQpKHByaXZhdGVfZXhwb25lbnQsIDE2KTtcXG4gICAgICAgICAgICAgICAgdmFyIHByaW1lMSA9IGFzbjEuc3ViWzRdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShwcmltZTEsIDE2KTtcXG4gICAgICAgICAgICAgICAgdmFyIHByaW1lMiA9IGFzbjEuc3ViWzVdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxcbiAgICAgICAgICAgICAgICB0aGlzLnEgPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShwcmltZTIsIDE2KTtcXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MSA9IGFzbjEuc3ViWzZdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxcbiAgICAgICAgICAgICAgICB0aGlzLmRtcDEgPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShleHBvbmVudDEsIDE2KTtcXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50MiA9IGFzbjEuc3ViWzddLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxcbiAgICAgICAgICAgICAgICB0aGlzLmRtcTEgPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShleHBvbmVudDIsIDE2KTtcXG4gICAgICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gYXNuMS5zdWJbOF0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmYgPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShjb2VmZmljaWVudCwgMTYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGFzbjEuc3ViWzBdLnN1Yikge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8gdHlwZSBhcyBkZWZpbmVkIGJ5IFguNTA5XFxuICAgICAgICAgICAgICAgICAgICB2YXIgYml0X3N0cmluZyA9IGFzbjEuc3ViWzFdO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gYml0X3N0cmluZy5zdWJbMF07XFxuICAgICAgICAgICAgICAgICAgICBtb2R1bHVzID0gc2VxdWVuY2Uuc3ViWzBdLmdldEhleFN0cmluZ1ZhbHVlKCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm4gPSAoMCxfbGliX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLnBhcnNlQmlnSW50KShtb2R1bHVzLCAxNik7XFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNfZXhwb25lbnQgPSBzZXF1ZW5jZS5zdWJbMV0uZ2V0SGV4U3RyaW5nVmFsdWUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KHB1YmxpY19leHBvbmVudCwgMTYpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgQVNOLjEgUlNBUHVibGljS2V5IHR5cGUgYXMgZGVmaW5lZCBieSBQS0NTICMxXFxuICAgICAgICAgICAgICAgICAgICBtb2R1bHVzID0gYXNuMS5zdWJbMF0uZ2V0SGV4U3RyaW5nVmFsdWUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubiA9ICgwLF9saWJfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18ucGFyc2VCaWdJbnQpKG1vZHVsdXMsIDE2KTtcXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY19leHBvbmVudCA9IGFzbjEuc3ViWzFdLmdldEhleFN0cmluZ1ZhbHVlKCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChwdWJsaWNfZXhwb25lbnQsIDE2KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChleCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFRyYW5zbGF0ZSByc2EgcGFyYW1ldGVycyBpbiBhIGhleCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBrZXkuXFxuICAgICAqXFxuICAgICAqIFRoZSB0cmFuc2xhdGlvbiBmb2xsb3cgdGhlIEFTTi4xIG5vdGF0aW9uIDpcXG4gICAgICogUlNBUHJpdmF0ZUtleSA6Oj0gU0VRVUVOQ0Uge1xcbiAgICAgKiAgIHZlcnNpb24gICAgICAgICAgIFZlcnNpb24sXFxuICAgICAqICAgbW9kdWx1cyAgICAgICAgICAgSU5URUdFUiwgIC0tIG5cXG4gICAgICogICBwdWJsaWNFeHBvbmVudCAgICBJTlRFR0VSLCAgLS0gZVxcbiAgICAgKiAgIHByaXZhdGVFeHBvbmVudCAgIElOVEVHRVIsICAtLSBkXFxuICAgICAqICAgcHJpbWUxICAgICAgICAgICAgSU5URUdFUiwgIC0tIHBcXG4gICAgICogICBwcmltZTIgICAgICAgICAgICBJTlRFR0VSLCAgLS0gcVxcbiAgICAgKiAgIGV4cG9uZW50MSAgICAgICAgIElOVEVHRVIsICAtLSBkIG1vZCAocDEpXFxuICAgICAqICAgZXhwb25lbnQyICAgICAgICAgSU5URUdFUiwgIC0tIGQgbW9kIChxLTEpXFxuICAgICAqICAgY29lZmZpY2llbnQgICAgICAgSU5URUdFUiwgIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXFxuICAgICAqIH1cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIERFUiBFbmNvZGVkIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwcml2YXRlIGtleVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlQmFzZUtleSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgICAgICAgIGFycmF5OiBbXFxuICAgICAgICAgICAgICAgIG5ldyBfbGliX2pzcnNhc2lnbl9hc24xXzFfMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLktKVVIuYXNuMS5ERVJJbnRlZ2VyKHsgaW50OiAwIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5wIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5xIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXAxIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5kbXExIH0pLFxcbiAgICAgICAgICAgICAgICBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5jb2VmZiB9KSxcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBzZXEgPSBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSU2VxdWVuY2Uob3B0aW9ucyk7XFxuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlQmFzZUtleUI2NCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAoMCxfbGliX2pzYm5fYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaGV4MmI2NCkodGhpcy5nZXRQcml2YXRlQmFzZUtleSgpKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFRyYW5zbGF0ZSByc2EgcGFyYW1ldGVycyBpbiBhIGhleCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwdWJsaWMga2V5LlxcbiAgICAgKiBUaGUgcmVwcmVzZW50YXRpb24gZm9sbG93IHRoZSBBU04uMSBub3RhdGlvbiA6XFxuICAgICAqIFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcXG4gICAgICogICBhbGdvcml0aG0gICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcXG4gICAgICogICBQdWJsaWNLZXkgICAgICAgQklUIFNUUklOR1xcbiAgICAgKiB9XFxuICAgICAqIFdoZXJlIEFsZ29yaXRobUlkZW50aWZpZXIgaXM6XFxuICAgICAqIEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IFNFUVVFTkNFIHtcXG4gICAgICogICBhbGdvcml0aG0gICAgICAgT0JKRUNUIElERU5USUZJRVIsICAgICB0aGUgT0lEIG9mIHRoZSBlbmMgYWxnb3JpdGhtXFxuICAgICAqICAgcGFyYW1ldGVycyAgICAgIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTCAoTlVMTCBmb3IgUEtDUyAjMSlcXG4gICAgICogfVxcbiAgICAgKiBhbmQgUHVibGljS2V5IGlzIGEgU0VRVUVOQ0UgZW5jYXBzdWxhdGVkIGluIGEgQklUIFNUUklOR1xcbiAgICAgKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcXG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxcbiAgICAgKiAgIHB1YmxpY0V4cG9uZW50ICAgIElOVEVHRVIgICAtLSBlXFxuICAgICAqIH1cXG4gICAgICogQHJldHVybnMge3N0cmluZ30gREVSIEVuY29kZWQgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHB1YmxpYyBrZXlcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljQmFzZUtleSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBmaXJzdF9zZXF1ZW5jZSA9IG5ldyBfbGliX2pzcnNhc2lnbl9hc24xXzFfMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLktKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XFxuICAgICAgICAgICAgYXJyYXk6IFtcXG4gICAgICAgICAgICAgICAgbmV3IF9saWJfanNyc2FzaWduX2FzbjFfMV8wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoeyBvaWQ6IFxcXCIxLjIuODQwLjExMzU0OS4xLjEuMVxcXCIgfSksXFxuICAgICAgICAgICAgICAgIG5ldyBfbGliX2pzcnNhc2lnbl9hc24xXzFfMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLktKVVIuYXNuMS5ERVJOdWxsKCksXFxuICAgICAgICAgICAgXSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdmFyIHNlY29uZF9zZXF1ZW5jZSA9IG5ldyBfbGliX2pzcnNhc2lnbl9hc24xXzFfMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLktKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XFxuICAgICAgICAgICAgYXJyYXk6IFtcXG4gICAgICAgICAgICAgICAgbmV3IF9saWJfanNyc2FzaWduX2FzbjFfMV8wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMubiB9KSxcXG4gICAgICAgICAgICAgICAgbmV3IF9saWJfanNyc2FzaWduX2FzbjFfMV8wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uS0pVUi5hc24xLkRFUkludGVnZXIoeyBpbnQ6IHRoaXMuZSB9KSxcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgfSk7XFxuICAgICAgICB2YXIgYml0X3N0cmluZyA9IG5ldyBfbGliX2pzcnNhc2lnbl9hc24xXzFfMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLktKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe1xcbiAgICAgICAgICAgIGhleDogXFxcIjAwXFxcIiArIHNlY29uZF9zZXF1ZW5jZS5nZXRFbmNvZGVkSGV4KCksXFxuICAgICAgICB9KTtcXG4gICAgICAgIHZhciBzZXEgPSBuZXcgX2xpYl9qc3JzYXNpZ25fYXNuMV8xXzBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5LSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xcbiAgICAgICAgICAgIGFycmF5OiBbZmlyc3Rfc2VxdWVuY2UsIGJpdF9zdHJpbmddLFxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaGVhZGVyIGFuZCBmb290ZXJcXG4gICAgICogQHB1YmxpY1xcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQdWJsaWNCYXNlS2V5QjY0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICgwLF9saWJfanNibl9iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5oZXgyYjY0KSh0aGlzLmdldFB1YmxpY0Jhc2VLZXkoKSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiB3cmFwIHRoZSBzdHJpbmcgaW4gYmxvY2sgb2Ygd2lkdGggY2hhcnMuIFRoZSBkZWZhdWx0IHZhbHVlIGZvciByc2Ega2V5cyBpcyA2NFxcbiAgICAgKiBjaGFyYWN0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTY0XSAtIHRoZSBsZW5ndGggdGhlIHN0cmluZyBoYXMgdG8gYmUgd3JhcHBlZCBhdFxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwID0gZnVuY3Rpb24gKHN0ciwgd2lkdGgpIHtcXG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgNjQ7XFxuICAgICAgICBpZiAoIXN0cikge1xcbiAgICAgICAgICAgIHJldHVybiBzdHI7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcmVnZXggPSBcXFwiKC57MSxcXFwiICsgd2lkdGggKyBcXFwifSkoICt8JFxcXFxuPyl8KC57MSxcXFwiICsgd2lkdGggKyBcXFwifSlcXFwiO1xcbiAgICAgICAgcmV0dXJuIHN0ci5tYXRjaChSZWdFeHAocmVnZXgsIFxcXCJnXFxcIikpLmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcGVtIGVuY29kZWQgcHJpdmF0ZSBrZXlcXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHByaXZhdGUga2V5IHdpdGggaGVhZGVyL2Zvb3RlclxcbiAgICAgKiBAcHVibGljXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIga2V5ID0gXFxcIi0tLS0tQkVHSU4gUlNBIFBSSVZBVEUgS0VZLS0tLS1cXFxcblxcXCI7XFxuICAgICAgICBrZXkgKz0gSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwKHRoaXMuZ2V0UHJpdmF0ZUJhc2VLZXlCNjQoKSkgKyBcXFwiXFxcXG5cXFwiO1xcbiAgICAgICAga2V5ICs9IFxcXCItLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLVxcXCI7XFxuICAgICAgICByZXR1cm4ga2V5O1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUmV0cmlldmUgdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXlcXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXkgd2l0aCBoZWFkZXIvZm9vdGVyXFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGtleSA9IFxcXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcXFxuXFxcIjtcXG4gICAgICAgIGtleSArPSBKU0VuY3J5cHRSU0FLZXkud29yZHdyYXAodGhpcy5nZXRQdWJsaWNCYXNlS2V5QjY0KCkpICsgXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgIGtleSArPSBcXFwiLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXFxcIjtcXG4gICAgICAgIHJldHVybiBrZXk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcGFyYW1ldGVycyB0byBwb3B1bGF0ZSB0aGUgcnNhIG1vZHVsdXNcXG4gICAgICogYW5kIHB1YmxpYyBleHBvbmVudCBwYXJhbWV0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXkgY29udGFpbiB0aGUgdHdvIHB1YmxpYyBrZXlcXG4gICAgICogcGFyYW1ldGVyc1xcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGJvdGggdGhlIG1vZHVsdXMgYW5kIHRoZSBwdWJsaWMgZXhwb25lbnRcXG4gICAgICogcHJvcGVydGllcyAobiBhbmQgZSlcXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIG4gYW5kIGUuIE4gc2hvdWxkIGJlIGEgcGFyc2VhYmxlIGJpZ0ludCBvYmplY3QsIEUgc2hvdWxkXFxuICAgICAqIGJlIGEgcGFyc2VhYmxlIGludGVnZXIgbnVtYmVyXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHVibGljS2V5UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgICBvYmogPSBvYmogfHwge307XFxuICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KFxcXCJuXFxcIikgJiYgb2JqLmhhc093blByb3BlcnR5KFxcXCJlXFxcIik7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIEFMTCB0aGUgcGFyYW1ldGVycyBvZiBhbiBSU0Ega2V5LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gLSBBbiBvYmplY3QgdGhhdCBtYXkgY29udGFpbiBuaW5lIHJzYSBrZXlcXG4gICAgICogcGFyYW1ldGVyc1xcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkZWRcXG4gICAgICogQHRvZG8gY2hlY2sgZm9yIHR5cGVzIG9mIHRoZSBwYXJhbWV0ZXJzIGFsbCB0aGUgcGFyYW1ldGVycyBidXQgdGhlIHB1YmxpYyBleHBvbmVudFxcbiAgICAgKiBzaG91bGQgYmUgcGFyc2VhYmxlIGJpZ2ludCBvYmplY3RzLCB0aGUgcHVibGljIGV4cG9uZW50IHNob3VsZCBiZSBhIHBhcnNlYWJsZSBpbnRlZ2VyIG51bWJlclxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG4gICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgICAgIG9iaiA9IG9iaiB8fCB7fTtcXG4gICAgICAgIHJldHVybiAob2JqLmhhc093blByb3BlcnR5KFxcXCJuXFxcIikgJiZcXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXFxcImVcXFwiKSAmJlxcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcXFwiZFxcXCIpICYmXFxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFxcXCJwXFxcIikgJiZcXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXFxcInFcXFwiKSAmJlxcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcXFwiZG1wMVxcXCIpICYmXFxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KFxcXCJkbXExXFxcIikgJiZcXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXFxcImNvZWZmXFxcIikpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogUGFyc2UgdGhlIHByb3BlcnRpZXMgb2Ygb2JqIGluIHRoZSBjdXJyZW50IHJzYSBvYmplY3QuIE9iaiBzaG91bGQgQVQgTEVBU1RcXG4gICAgICogaW5jbHVkZSB0aGUgbW9kdWx1cyBhbmQgcHVibGljIGV4cG9uZW50IChuLCBlKSBwYXJhbWV0ZXJzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCBjb250YWluaW5nIHJzYSBwYXJhbWV0ZXJzXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLnBhcnNlUHJvcGVydGllc0Zyb20gPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgICB0aGlzLm4gPSBvYmoubjtcXG4gICAgICAgIHRoaXMuZSA9IG9iai5lO1xcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcXFwiZFxcXCIpKSB7XFxuICAgICAgICAgICAgdGhpcy5kID0gb2JqLmQ7XFxuICAgICAgICAgICAgdGhpcy5wID0gb2JqLnA7XFxuICAgICAgICAgICAgdGhpcy5xID0gb2JqLnE7XFxuICAgICAgICAgICAgdGhpcy5kbXAxID0gb2JqLmRtcDE7XFxuICAgICAgICAgICAgdGhpcy5kbXExID0gb2JqLmRtcTE7XFxuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IG9iai5jb2VmZjtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV0dXJuIEpTRW5jcnlwdFJTQUtleTtcXG59KF9saWJfanNibl9yc2FfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy5SU0FLZXkpKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9KU0VuY3J5cHQvLi9saWIvSlNFbmNyeXB0UlNBS2V5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9saWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkpTRW5jcnlwdFxcXCI6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9KU0VuY3J5cHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5KU0VuY3J5cHQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9KU0VuY3J5cHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vSlNFbmNyeXB0ICovIFxcXCIuL2xpYi9KU0VuY3J5cHQuanNcXFwiKTtcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKF9KU0VuY3J5cHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5KU0VuY3J5cHQpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0pTRW5jcnlwdC8uL2xpYi9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbGliL2xpYi9hc24xanMvYXNuMS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvbGliL2FzbjFqcy9hc24xLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiQVNOMVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEFTTjEpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkFTTjFUYWdcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBBU04xVGFnKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTdHJlYW1cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdHJlYW0pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnQxMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnQxMCAqLyBcXFwiLi9saWIvbGliL2FzbjFqcy9pbnQxMC5qc1xcXCIpO1xcbi8vIEFTTi4xIEphdmFTY3JpcHQgZGVjb2Rlclxcbi8vIENvcHlyaWdodCAoYykgMjAwOC0yMDE0IExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0Plxcbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXFxuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXFxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxcbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXFxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xcbi8qZ2xvYmFsIG9pZHMgKi9cXG5cXG52YXIgZWxsaXBzaXMgPSBcXFwiXFxcXHUyMDI2XFxcIjtcXG52YXIgcmVUaW1lUyA9IC9eKFxcXFxkXFxcXGQpKDBbMS05XXwxWzAtMl0pKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pKFswMV1cXFxcZHwyWzAtM10pKD86KFswLTVdXFxcXGQpKD86KFswLTVdXFxcXGQpKD86Wy4sXShcXFxcZHsxLDN9KSk/KT8pPyhafFstK10oPzpbMF1cXFxcZHwxWzAtMl0pKFswLTVdXFxcXGQpPyk/JC87XFxudmFyIHJlVGltZUwgPSAvXihcXFxcZFxcXFxkXFxcXGRcXFxcZCkoMFsxLTldfDFbMC0yXSkoMFsxLTldfFsxMl1cXFxcZHwzWzAxXSkoWzAxXVxcXFxkfDJbMC0zXSkoPzooWzAtNV1cXFxcZCkoPzooWzAtNV1cXFxcZCkoPzpbLixdKFxcXFxkezEsM30pKT8pPyk/KFp8Wy0rXSg/OlswXVxcXFxkfDFbMC0yXSkoWzAtNV1cXFxcZCk/KT8kLztcXG5mdW5jdGlvbiBzdHJpbmdDdXQoc3RyLCBsZW4pIHtcXG4gICAgaWYgKHN0ci5sZW5ndGggPiBsZW4pIHtcXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgbGVuKSArIGVsbGlwc2lzO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHI7XFxufVxcbnZhciBTdHJlYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFN0cmVhbShlbmMsIHBvcykge1xcbiAgICAgICAgdGhpcy5oZXhEaWdpdHMgPSBcXFwiMDEyMzQ1Njc4OUFCQ0RFRlxcXCI7XFxuICAgICAgICBpZiAoZW5jIGluc3RhbmNlb2YgU3RyZWFtKSB7XFxuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmMuZW5jO1xcbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5jLnBvcztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIC8vIGVuYyBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBiaW5hcnkgc3RyaW5nXFxuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmM7XFxuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgU3RyZWFtLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocG9zKSB7XFxuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcysrO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmVuYy5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlJlcXVlc3RpbmcgYnl0ZSBvZmZzZXQgXFxcIi5jb25jYXQocG9zLCBcXFwiIG9uIGEgc3RyZWFtIG9mIGxlbmd0aCBcXFwiKS5jb25jYXQodGhpcy5lbmMubGVuZ3RoKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKFxcXCJzdHJpbmdcXFwiID09PSB0eXBlb2YgdGhpcy5lbmMpID8gdGhpcy5lbmMuY2hhckNvZGVBdChwb3MpIDogdGhpcy5lbmNbcG9zXTtcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5oZXhCeXRlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmhleERpZ2l0cy5jaGFyQXQoKGIgPj4gNCkgJiAweEYpICsgdGhpcy5oZXhEaWdpdHMuY2hhckF0KGIgJiAweEYpO1xcbiAgICB9O1xcbiAgICBTdHJlYW0ucHJvdG90eXBlLmhleER1bXAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcmF3KSB7XFxuICAgICAgICB2YXIgcyA9IFxcXCJcXFwiO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgICAgICAgICBzICs9IHRoaXMuaGV4Qnl0ZSh0aGlzLmdldChpKSk7XFxuICAgICAgICAgICAgaWYgKHJhdyAhPT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGkgJiAweEYpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg3OlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXFxcIiAgXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhGOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcXFwiIFxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcztcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5pc0FTQ0lJID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldChpKTtcXG4gICAgICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxNzYpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9O1xcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlU3RyaW5nSVNPID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcXG4gICAgICAgIHZhciBzID0gXFxcIlxcXCI7XFxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldChpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcztcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ1VURiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XFxuICAgICAgICB2YXIgcyA9IFxcXCJcXFwiO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5nZXQoaSsrKTtcXG4gICAgICAgICAgICBpZiAoYyA8IDEyOCkge1xcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKChjID4gMTkxKSAmJiAoYyA8IDIyNCkpIHtcXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKHRoaXMuZ2V0KGkrKykgJiAweDNGKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwRikgPDwgMTIpIHwgKCh0aGlzLmdldChpKyspICYgMHgzRikgPDwgNikgfCAodGhpcy5nZXQoaSsrKSAmIDB4M0YpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcztcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZVN0cmluZ0JNUCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XFxuICAgICAgICB2YXIgc3RyID0gXFxcIlxcXCI7XFxuICAgICAgICB2YXIgaGk7XFxuICAgICAgICB2YXIgbG87XFxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XFxuICAgICAgICAgICAgaGkgPSB0aGlzLmdldChpKyspO1xcbiAgICAgICAgICAgIGxvID0gdGhpcy5nZXQoaSsrKTtcXG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaGkgPDwgOCkgfCBsbyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc3RyO1xcbiAgICB9O1xcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlVGltZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzaG9ydFllYXIpIHtcXG4gICAgICAgIHZhciBzID0gdGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKTtcXG4gICAgICAgIHZhciBtID0gKHNob3J0WWVhciA/IHJlVGltZVMgOiByZVRpbWVMKS5leGVjKHMpO1xcbiAgICAgICAgaWYgKCFtKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJVbnJlY29nbml6ZWQgdGltZTogXFxcIiArIHM7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoc2hvcnRZZWFyKSB7XFxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgcXVlcnlpbmcgdGhlIHRpbWVyLCB1c2UgdGhlIGZpeGVkIHJhbmdlIFsxOTcwLCAyMDY5XVxcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgY29uZm9ybSB3aXRoIElUVSBYLjQwMCBbLTEwLCArNDBdIHNsaWRpbmcgd2luZG93IHVudGlsIDIwMzBcXG4gICAgICAgICAgICBtWzFdID0gK21bMV07XFxuICAgICAgICAgICAgbVsxXSArPSAoK21bMV0gPCA3MCkgPyAyMDAwIDogMTkwMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHMgPSBtWzFdICsgXFxcIi1cXFwiICsgbVsyXSArIFxcXCItXFxcIiArIG1bM10gKyBcXFwiIFxcXCIgKyBtWzRdO1xcbiAgICAgICAgaWYgKG1bNV0pIHtcXG4gICAgICAgICAgICBzICs9IFxcXCI6XFxcIiArIG1bNV07XFxuICAgICAgICAgICAgaWYgKG1bNl0pIHtcXG4gICAgICAgICAgICAgICAgcyArPSBcXFwiOlxcXCIgKyBtWzZdO1xcbiAgICAgICAgICAgICAgICBpZiAobVs3XSkge1xcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcXFwiLlxcXCIgKyBtWzddO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG1bOF0pIHtcXG4gICAgICAgICAgICBzICs9IFxcXCIgVVRDXFxcIjtcXG4gICAgICAgICAgICBpZiAobVs4XSAhPSBcXFwiWlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcyArPSBtWzhdO1xcbiAgICAgICAgICAgICAgICBpZiAobVs5XSkge1xcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcXFwiOlxcXCIgKyBtWzldO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgIH07XFxuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VJbnRlZ2VyID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXQoc3RhcnQpO1xcbiAgICAgICAgdmFyIG5lZyA9ICh2ID4gMTI3KTtcXG4gICAgICAgIHZhciBwYWQgPSBuZWcgPyAyNTUgOiAwO1xcbiAgICAgICAgdmFyIGxlbjtcXG4gICAgICAgIHZhciBzID0gXFxcIlxcXCI7XFxuICAgICAgICAvLyBza2lwIHVudXNlZnVsIGJpdHMgKG5vdCBhbGxvd2VkIGluIERFUilcXG4gICAgICAgIHdoaWxlICh2ID09IHBhZCAmJiArK3N0YXJ0IDwgZW5kKSB7XFxuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHN0YXJ0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxlbiA9IGVuZCAtIHN0YXJ0O1xcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBuZWcgPyAtMSA6IDA7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBzaG93IGJpdCBsZW5ndGggb2YgaHVnZSBpbnRlZ2Vyc1xcbiAgICAgICAgaWYgKGxlbiA+IDQpIHtcXG4gICAgICAgICAgICBzID0gdjtcXG4gICAgICAgICAgICBsZW4gPDw9IDM7XFxuICAgICAgICAgICAgd2hpbGUgKCgoK3MgXiBwYWQpICYgMHg4MCkgPT0gMCkge1xcbiAgICAgICAgICAgICAgICBzID0gK3MgPDwgMTtcXG4gICAgICAgICAgICAgICAgLS1sZW47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHMgPSBcXFwiKFxcXCIgKyBsZW4gKyBcXFwiIGJpdClcXFxcblxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBkZWNvZGUgdGhlIGludGVnZXJcXG4gICAgICAgIGlmIChuZWcpIHtcXG4gICAgICAgICAgICB2ID0gdiAtIDI1NjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBuID0gbmV3IF9pbnQxMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkludDEwKHYpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgKytpKSB7XFxuICAgICAgICAgICAgbi5tdWxBZGQoMjU2LCB0aGlzLmdldChpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcyArIG4udG9TdHJpbmcoKTtcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZUJpdFN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcXG4gICAgICAgIHZhciB1bnVzZWRCaXQgPSB0aGlzLmdldChzdGFydCk7XFxuICAgICAgICB2YXIgbGVuQml0ID0gKChlbmQgLSBzdGFydCAtIDEpIDw8IDMpIC0gdW51c2VkQml0O1xcbiAgICAgICAgdmFyIGludHJvID0gXFxcIihcXFwiICsgbGVuQml0ICsgXFxcIiBiaXQpXFxcXG5cXFwiO1xcbiAgICAgICAgdmFyIHMgPSBcXFwiXFxcIjtcXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7ICsraSkge1xcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5nZXQoaSk7XFxuICAgICAgICAgICAgdmFyIHNraXAgPSAoaSA9PSBlbmQgLSAxKSA/IHVudXNlZEJpdCA6IDA7XFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDc7IGogPj0gc2tpcDsgLS1qKSB7XFxuICAgICAgICAgICAgICAgIHMgKz0gKGIgPj4gaikgJiAxID8gXFxcIjFcXFwiIDogXFxcIjBcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludHJvICsgc3RyaW5nQ3V0KHMsIG1heExlbmd0aCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGludHJvICsgcztcXG4gICAgfTtcXG4gICAgU3RyZWFtLnByb3RvdHlwZS5wYXJzZU9jdGV0U3RyaW5nID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG1heExlbmd0aCkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNBU0NJSShzdGFydCwgZW5kKSkge1xcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5wYXJzZVN0cmluZ0lTTyhzdGFydCwgZW5kKSwgbWF4TGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcXG4gICAgICAgIHZhciBzID0gXFxcIihcXFwiICsgbGVuICsgXFxcIiBieXRlKVxcXFxuXFxcIjtcXG4gICAgICAgIG1heExlbmd0aCAvPSAyOyAvLyB3ZSB3b3JrIGluIGJ5dGVzXFxuICAgICAgICBpZiAobGVuID4gbWF4TGVuZ3RoKSB7XFxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBtYXhMZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICAgICAgICAgIHMgKz0gdGhpcy5oZXhCeXRlKHRoaXMuZ2V0KGkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsZW4gPiBtYXhMZW5ndGgpIHtcXG4gICAgICAgICAgICBzICs9IGVsbGlwc2lzO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgIH07XFxuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VPSUQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWF4TGVuZ3RoKSB7XFxuICAgICAgICB2YXIgcyA9IFxcXCJcXFwiO1xcbiAgICAgICAgdmFyIG4gPSBuZXcgX2ludDEwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uSW50MTAoKTtcXG4gICAgICAgIHZhciBiaXRzID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldChpKTtcXG4gICAgICAgICAgICBuLm11bEFkZCgxMjgsIHYgJiAweDdGKTtcXG4gICAgICAgICAgICBiaXRzICs9IDc7XFxuICAgICAgICAgICAgaWYgKCEodiAmIDB4ODApKSB7IC8vIGZpbmlzaGVkXFxuICAgICAgICAgICAgICAgIGlmIChzID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uc2ltcGxpZnkoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgX2ludDEwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uSW50MTApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN1Yig4MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFxcXCIyLlxcXCIgKyBuLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IG4gPCA4MCA/IG4gPCA0MCA/IDAgOiAxIDogMjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbSArIFxcXCIuXFxcIiArIChuIC0gbSAqIDQwKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXFxcIi5cXFwiICsgbi50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA+IG1heExlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dChzLCBtYXhMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG4gPSBuZXcgX2ludDEwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uSW50MTAoKTtcXG4gICAgICAgICAgICAgICAgYml0cyA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XFxuICAgICAgICAgICAgcyArPSBcXFwiLmluY29tcGxldGVcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgIH07XFxuICAgIHJldHVybiBTdHJlYW07XFxufSgpKTtcXG5cXG52YXIgQVNOMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gQVNOMShzdHJlYW0sIGhlYWRlciwgbGVuZ3RoLCB0YWcsIHN1Yikge1xcbiAgICAgICAgaWYgKCEodGFnIGluc3RhbmNlb2YgQVNOMVRhZykpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgdGFnIHZhbHVlLlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XFxuICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XFxuICAgICAgICB0aGlzLnN1YiA9IHN1YjtcXG4gICAgfVxcbiAgICBBU04xLnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHN3aXRjaCAodGhpcy50YWcudGFnQ2xhc3MpIHtcXG4gICAgICAgICAgICBjYXNlIDA6IC8vIHVuaXZlcnNhbFxcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAwOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiRU9DXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIkJPT0xFQU5cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAyOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiSU5URUdFUlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDM6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJCSVRfU1RSSU5HXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNDpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIk9DVEVUX1NUUklOR1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJOVUxMXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNjpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIk9CSkVDVF9JREVOVElGSUVSXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwNzpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIk9iamVjdERlc2NyaXB0b3JcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA4OlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiRVhURVJOQUxcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA5OlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiUkVBTFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEE6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJFTlVNRVJBVEVEXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwQjpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIkVNQkVEREVEX1BEVlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEM6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJVVEY4U3RyaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMDpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlNFUVVFTkNFXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlNFVFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJOdW1lcmljU3RyaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxMzpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlByaW50YWJsZVN0cmluZ1xcXCI7IC8vIEFTQ0lJIHN1YnNldFxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiVGVsZXRleFN0cmluZ1xcXCI7IC8vIGFrYSBUNjFTdHJpbmdcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlZpZGVvdGV4U3RyaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNjpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIklBNVN0cmluZ1xcXCI7IC8vIEFTQ0lJXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJVVENUaW1lXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxODpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIkdlbmVyYWxpemVkVGltZVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTk6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJHcmFwaGljU3RyaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlZpc2libGVTdHJpbmdcXFwiOyAvLyBBU0NJSSBzdWJzZXRcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQjpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIkdlbmVyYWxTdHJpbmdcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDFDOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiVW5pdmVyc2FsU3RyaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxRTpcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIkJNUFN0cmluZ1xcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJVbml2ZXJzYWxfXFxcIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xcbiAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJBcHBsaWNhdGlvbl9cXFwiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcIltcXFwiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCkgKyBcXFwiXVxcXCI7IC8vIENvbnRleHRcXG4gICAgICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiUHJpdmF0ZV9cXFwiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIEFTTjEucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XFxuICAgICAgICBpZiAodGhpcy50YWcgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG1heExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMucG9zQ29udGVudCgpO1xcbiAgICAgICAgdmFyIGxlbiA9IE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcXG4gICAgICAgIGlmICghdGhpcy50YWcuaXNVbml2ZXJzYWwoKSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YiAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcIihcXFwiICsgdGhpcy5zdWIubGVuZ3RoICsgXFxcIiBlbGVtKVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9jdGV0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XFxuICAgICAgICB9XFxuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ051bWJlcikge1xcbiAgICAgICAgICAgIGNhc2UgMHgwMTogLy8gQk9PTEVBTlxcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuc3RyZWFtLmdldChjb250ZW50KSA9PT0gMCkgPyBcXFwiZmFsc2VcXFwiIDogXFxcInRydWVcXFwiO1xcbiAgICAgICAgICAgIGNhc2UgMHgwMjogLy8gSU5URUdFUlxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VJbnRlZ2VyKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pO1xcbiAgICAgICAgICAgIGNhc2UgMHgwMzogLy8gQklUX1NUUklOR1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIgPyBcXFwiKFxcXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcXFwiIGVsZW0pXFxcIiA6XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXJzZUJpdFN0cmluZyhjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xcbiAgICAgICAgICAgIGNhc2UgMHgwNDogLy8gT0NURVRfU1RSSU5HXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YiA/IFxcXCIoXFxcIiArIHRoaXMuc3ViLmxlbmd0aCArIFxcXCIgZWxlbSlcXFwiIDpcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhcnNlT2N0ZXRTdHJpbmcoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDU6IC8vIE5VTExcXG4gICAgICAgICAgICBjYXNlIDB4MDY6IC8vIE9CSkVDVF9JREVOVElGSUVSXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZU9JRChjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwNzogLy8gT2JqZWN0RGVzY3JpcHRvclxcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwODogLy8gRVhURVJOQUxcXG4gICAgICAgICAgICAvLyBjYXNlIDB4MDk6IC8vIFJFQUxcXG4gICAgICAgICAgICAvLyBjYXNlIDB4MEE6IC8vIEVOVU1FUkFURURcXG4gICAgICAgICAgICAvLyBjYXNlIDB4MEI6IC8vIEVNQkVEREVEX1BEVlxcbiAgICAgICAgICAgIGNhc2UgMHgxMDogLy8gU0VRVUVOQ0VcXG4gICAgICAgICAgICBjYXNlIDB4MTE6IC8vIFNFVFxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiKFxcXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcXFwiIGVsZW0pXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiKG5vIGVsZW0pXFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhc2UgMHgwQzogLy8gVVRGOFN0cmluZ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nVVRGKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xcbiAgICAgICAgICAgIGNhc2UgMHgxMjogLy8gTnVtZXJpY1N0cmluZ1xcbiAgICAgICAgICAgIGNhc2UgMHgxMzogLy8gUHJpbnRhYmxlU3RyaW5nXFxuICAgICAgICAgICAgY2FzZSAweDE0OiAvLyBUZWxldGV4U3RyaW5nXFxuICAgICAgICAgICAgY2FzZSAweDE1OiAvLyBWaWRlb3RleFN0cmluZ1xcbiAgICAgICAgICAgIGNhc2UgMHgxNjogLy8gSUE1U3RyaW5nXFxuICAgICAgICAgICAgLy8gY2FzZSAweDE5OiAvLyBHcmFwaGljU3RyaW5nXFxuICAgICAgICAgICAgY2FzZSAweDFBOiAvLyBWaXNpYmxlU3RyaW5nXFxuICAgICAgICAgICAgICAgIC8vIGNhc2UgMHgxQjogLy8gR2VuZXJhbFN0cmluZ1xcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDB4MUM6IC8vIFVuaXZlcnNhbFN0cmluZ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nSVNPKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xcbiAgICAgICAgICAgIGNhc2UgMHgxRTogLy8gQk1QU3RyaW5nXFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQodGhpcy5zdHJlYW0ucGFyc2VTdHJpbmdCTVAoY29udGVudCwgY29udGVudCArIGxlbiksIG1heExlbmd0aCk7XFxuICAgICAgICAgICAgY2FzZSAweDE3OiAvLyBVVENUaW1lXFxuICAgICAgICAgICAgY2FzZSAweDE4OiAvLyBHZW5lcmFsaXplZFRpbWVcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBhcnNlVGltZShjb250ZW50LCBjb250ZW50ICsgbGVuLCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MTcpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9O1xcbiAgICBBU04xLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVOYW1lKCkgKyBcXFwiQFxcXCIgKyB0aGlzLnN0cmVhbS5wb3MgKyBcXFwiW2hlYWRlcjpcXFwiICsgdGhpcy5oZWFkZXIgKyBcXFwiLGxlbmd0aDpcXFwiICsgdGhpcy5sZW5ndGggKyBcXFwiLHN1YjpcXFwiICsgKCh0aGlzLnN1YiA9PT0gbnVsbCkgPyBcXFwibnVsbFxcXCIgOiB0aGlzLnN1Yi5sZW5ndGgpICsgXFxcIl1cXFwiO1xcbiAgICB9O1xcbiAgICBBU04xLnByb3RvdHlwZS50b1ByZXR0eVN0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcXG4gICAgICAgIGlmIChpbmRlbnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGluZGVudCA9IFxcXCJcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHMgPSBpbmRlbnQgKyB0aGlzLnR5cGVOYW1lKCkgKyBcXFwiIEBcXFwiICsgdGhpcy5zdHJlYW0ucG9zO1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDApIHtcXG4gICAgICAgICAgICBzICs9IFxcXCIrXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHMgKz0gdGhpcy5sZW5ndGg7XFxuICAgICAgICBpZiAodGhpcy50YWcudGFnQ29uc3RydWN0ZWQpIHtcXG4gICAgICAgICAgICBzICs9IFxcXCIgKGNvbnN0cnVjdGVkKVxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICgodGhpcy50YWcuaXNVbml2ZXJzYWwoKSAmJiAoKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDAzKSB8fCAodGhpcy50YWcudGFnTnVtYmVyID09IDB4MDQpKSkgJiYgKHRoaXMuc3ViICE9PSBudWxsKSkge1xcbiAgICAgICAgICAgIHMgKz0gXFxcIiAoZW5jYXBzdWxhdGVzKVxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBzICs9IFxcXCJcXFxcblxcXCI7XFxuICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcXG4gICAgICAgICAgICBpbmRlbnQgKz0gXFxcIiAgXFxcIjtcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gdGhpcy5zdWIubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcXG4gICAgICAgICAgICAgICAgcyArPSB0aGlzLnN1YltpXS50b1ByZXR0eVN0cmluZyhpbmRlbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzO1xcbiAgICB9O1xcbiAgICBBU04xLnByb3RvdHlwZS5wb3NTdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3M7XFxuICAgIH07XFxuICAgIEFTTjEucHJvdG90eXBlLnBvc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9zICsgdGhpcy5oZWFkZXI7XFxuICAgIH07XFxuICAgIEFTTjEucHJvdG90eXBlLnBvc0VuZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3MgKyB0aGlzLmhlYWRlciArIE1hdGguYWJzKHRoaXMubGVuZ3RoKTtcXG4gICAgfTtcXG4gICAgQVNOMS5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0uaGV4RHVtcCh0aGlzLnBvc1N0YXJ0KCksIHRoaXMucG9zRW5kKCksIHRydWUpO1xcbiAgICB9O1xcbiAgICBBU04xLmRlY29kZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcXG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XFxuICAgICAgICB2YXIgbGVuID0gYnVmICYgMHg3RjtcXG4gICAgICAgIGlmIChsZW4gPT0gYnVmKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGxlbjtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIG5vIHJlYXNvbiB0byB1c2UgSW50MTAsIGFzIGl0IHdvdWxkIGJlIGEgaHVnZSBidWZmZXIgYW55d2F5c1xcbiAgICAgICAgaWYgKGxlbiA+IDYpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkxlbmd0aCBvdmVyIDQ4IGJpdHMgbm90IHN1cHBvcnRlZCBhdCBwb3NpdGlvbiBcXFwiICsgKHN0cmVhbS5wb3MgLSAxKSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobGVuID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IC8vIHVuZGVmaW5lZFxcbiAgICAgICAgYnVmID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgICAgICAgICBidWYgPSAoYnVmICogMjU2KSArIHN0cmVhbS5nZXQoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBidWY7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZXRyaWV2ZSB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgKGFzIGEgc3RyaW5nKSBvZiB0aGUgY3VycmVudCBBU04uMSBlbGVtZW50XFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XFxuICAgICAqIEBwdWJsaWNcXG4gICAgICovXFxuICAgIEFTTjEucHJvdG90eXBlLmdldEhleFN0cmluZ1ZhbHVlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGhleFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmhlYWRlciAqIDI7XFxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggKiAyO1xcbiAgICAgICAgcmV0dXJuIGhleFN0cmluZy5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xcbiAgICB9O1xcbiAgICBBU04xLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgICAgIHZhciBzdHJlYW07XFxuICAgICAgICBpZiAoIShzdHIgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XFxuICAgICAgICAgICAgc3RyZWFtID0gbmV3IFN0cmVhbShzdHIsIDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgc3RyZWFtID0gc3RyO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHN0cmVhbVN0YXJ0ID0gbmV3IFN0cmVhbShzdHJlYW0pO1xcbiAgICAgICAgdmFyIHRhZyA9IG5ldyBBU04xVGFnKHN0cmVhbSk7XFxuICAgICAgICB2YXIgbGVuID0gQVNOMS5kZWNvZGVMZW5ndGgoc3RyZWFtKTtcXG4gICAgICAgIHZhciBzdGFydCA9IHN0cmVhbS5wb3M7XFxuICAgICAgICB2YXIgaGVhZGVyID0gc3RhcnQgLSBzdHJlYW1TdGFydC5wb3M7XFxuICAgICAgICB2YXIgc3ViID0gbnVsbDtcXG4gICAgICAgIHZhciBnZXRTdWIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xcbiAgICAgICAgICAgIGlmIChsZW4gIT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pdGUgbGVuZ3RoXFxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbjtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IEFTTjEuZGVjb2RlKHN0cmVhbSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5wb3MgIT0gZW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkNvbnRlbnQgc2l6ZSBpcyBub3QgY29ycmVjdCBmb3IgY29udGFpbmVyIHN0YXJ0aW5nIGF0IG9mZnNldCBcXFwiICsgc3RhcnQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgbGVuZ3RoXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBBU04xLmRlY29kZShzdHJlYW0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnRhZy5pc0VPQygpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSBzO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gc3RhcnQgLSBzdHJlYW0ucG9zOyAvLyB1bmRlZmluZWQgbGVuZ3RocyBhcmUgcmVwcmVzZW50ZWQgYXMgbmVnYXRpdmUgdmFsdWVzXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiRXhjZXB0aW9uIHdoaWxlIGRlY29kaW5nIHVuZGVmaW5lZCBsZW5ndGggY29udGVudDogXFxcIiArIGUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKHRhZy50YWdDb25zdHJ1Y3RlZCkge1xcbiAgICAgICAgICAgIC8vIG11c3QgaGF2ZSB2YWxpZCBjb250ZW50XFxuICAgICAgICAgICAgc3ViID0gZ2V0U3ViKCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh0YWcuaXNVbml2ZXJzYWwoKSAmJiAoKHRhZy50YWdOdW1iZXIgPT0gMHgwMykgfHwgKHRhZy50YWdOdW1iZXIgPT0gMHgwNCkpKSB7XFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIEJpdFN0cmluZyBhbmQgT2N0ZXRTdHJpbmcgYXJlIHVzZWQgdG8gZW5jYXBzdWxhdGUgQVNOLjFcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBpZiAodGFnLnRhZ051bWJlciA9PSAweDAzKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmdldCgpICE9IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkJJVCBTVFJJTkdzIHdpdGggdW51c2VkIGJpdHMgY2Fubm90IGVuY2Fwc3VsYXRlLlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHN1YiA9IGdldFN1YigpO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YltpXS50YWcuaXNFT0MoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiRU9DIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBhY3R1YWwgY29udGVudC5cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAvLyBidXQgc2lsZW50bHkgaWdub3JlIHdoZW4gdGhleSBkb24ndFxcbiAgICAgICAgICAgICAgICBzdWIgPSBudWxsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcXG4gICAgICAgICAgICBpZiAobGVuID09PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiV2UgY2FuJ3Qgc2tpcCBvdmVyIGFuIGludmFsaWQgdGFnIHdpdGggdW5kZWZpbmVkIGxlbmd0aCBhdCBvZmZzZXQgXFxcIiArIHN0YXJ0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3RyZWFtLnBvcyA9IHN0YXJ0ICsgTWF0aC5hYnMobGVuKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBuZXcgQVNOMShzdHJlYW1TdGFydCwgaGVhZGVyLCBsZW4sIHRhZywgc3ViKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIEFTTjE7XFxufSgpKTtcXG5cXG52YXIgQVNOMVRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gQVNOMVRhZyhzdHJlYW0pIHtcXG4gICAgICAgIHZhciBidWYgPSBzdHJlYW0uZ2V0KCk7XFxuICAgICAgICB0aGlzLnRhZ0NsYXNzID0gYnVmID4+IDY7XFxuICAgICAgICB0aGlzLnRhZ0NvbnN0cnVjdGVkID0gKChidWYgJiAweDIwKSAhPT0gMCk7XFxuICAgICAgICB0aGlzLnRhZ051bWJlciA9IGJ1ZiAmIDB4MUY7XFxuICAgICAgICBpZiAodGhpcy50YWdOdW1iZXIgPT0gMHgxRikgeyAvLyBsb25nIHRhZ1xcbiAgICAgICAgICAgIHZhciBuID0gbmV3IF9pbnQxMF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkludDEwKCk7XFxuICAgICAgICAgICAgZG8ge1xcbiAgICAgICAgICAgICAgICBidWYgPSBzdHJlYW0uZ2V0KCk7XFxuICAgICAgICAgICAgICAgIG4ubXVsQWRkKDEyOCwgYnVmICYgMHg3Rik7XFxuICAgICAgICAgICAgfSB3aGlsZSAoYnVmICYgMHg4MCk7XFxuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSBuLnNpbXBsaWZ5KCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgQVNOMVRhZy5wcm90b3R5cGUuaXNVbml2ZXJzYWwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMDtcXG4gICAgfTtcXG4gICAgQVNOMVRhZy5wcm90b3R5cGUuaXNFT0MgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50YWdDbGFzcyA9PT0gMHgwMCAmJiB0aGlzLnRhZ051bWJlciA9PT0gMHgwMDtcXG4gICAgfTtcXG4gICAgcmV0dXJuIEFTTjFUYWc7XFxufSgpKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9KU0VuY3J5cHQvLi9saWIvbGliL2FzbjFqcy9hc24xLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9saWIvbGliL2FzbjFqcy9iYXNlNjQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvbGliL2FzbjFqcy9iYXNlNjQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkJhc2U2NFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2U2NClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vLyBCYXNlNjQgSmF2YVNjcmlwdCBkZWNvZGVyXFxuLy8gQ29weXJpZ2h0IChjKSAyMDA4LTIwMTMgTGFwbyBMdWNoaW5pIDxsYXBvQGxhcG8uaXQ+XFxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XFxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXFxuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXFxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxcbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXFxudmFyIGRlY29kZXI7XFxudmFyIEJhc2U2NCA9IHtcXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGk7XFxuICAgICAgICBpZiAoZGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdmFyIGI2NCA9IFxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIjtcXG4gICAgICAgICAgICB2YXIgaWdub3JlID0gXFxcIj0gXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdTAwQTBcXFxcdTIwMjhcXFxcdTIwMjlcXFwiO1xcbiAgICAgICAgICAgIGRlY29kZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XFxuICAgICAgICAgICAgICAgIGRlY29kZXJbYjY0LmNoYXJBdChpKV0gPSBpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBkZWNvZGVyWyctJ10gPSA2MjsgLy8rXFxuICAgICAgICAgICAgZGVjb2RlclsnXyddID0gNjM7IC8vLVxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZ25vcmUubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgZGVjb2RlcltpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBvdXQgPSBbXTtcXG4gICAgICAgIHZhciBiaXRzID0gMDtcXG4gICAgICAgIHZhciBjaGFyX2NvdW50ID0gMDtcXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcXG4gICAgICAgICAgICBpZiAoYyA9PSBcXFwiPVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGMgPSBkZWNvZGVyW2NdO1xcbiAgICAgICAgICAgIGlmIChjID09IC0xKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSWxsZWdhbCBjaGFyYWN0ZXIgYXQgb2Zmc2V0IFxcXCIgKyBpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYml0cyB8PSBjO1xcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gNCkge1xcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxNik7XFxuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDgpICYgMHhGRjtcXG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gYml0cyAmIDB4RkY7XFxuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xcbiAgICAgICAgICAgICAgICBjaGFyX2NvdW50ID0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGJpdHMgPDw9IDY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc3dpdGNoIChjaGFyX2NvdW50KSB7XFxuICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkJhc2U2NCBlbmNvZGluZyBpbmNvbXBsZXRlOiBhdCBsZWFzdCAyIGJpdHMgbWlzc2luZ1xcXCIpO1xcbiAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTApO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDE2KTtcXG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gOCkgJiAweEZGO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBvdXQ7XFxuICAgIH0sXFxuICAgIHJlOiAvLS0tLS1CRUdJTiBbXi1dKy0tLS0tKFtBLVphLXowLTkrXFxcXC89XFxcXHNdKyktLS0tLUVORCBbXi1dKy0tLS0tfGJlZ2luLWJhc2U2NFteXFxcXG5dK1xcXFxuKFtBLVphLXowLTkrXFxcXC89XFxcXHNdKyk9PT09LyxcXG4gICAgdW5hcm1vcjogZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBtID0gQmFzZTY0LnJlLmV4ZWMoYSk7XFxuICAgICAgICBpZiAobSkge1xcbiAgICAgICAgICAgIGlmIChtWzFdKSB7XFxuICAgICAgICAgICAgICAgIGEgPSBtWzFdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChtWzJdKSB7XFxuICAgICAgICAgICAgICAgIGEgPSBtWzJdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJSZWdFeHAgb3V0IG9mIHN5bmNcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gQmFzZTY0LmRlY29kZShhKTtcXG4gICAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9hc24xanMvYmFzZTY0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9saWIvbGliL2FzbjFqcy9oZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvbGliL2FzbjFqcy9oZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkhleFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEhleClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vLyBIZXggSmF2YVNjcmlwdCBkZWNvZGVyXFxuLy8gQ29weXJpZ2h0IChjKSAyMDA4LTIwMTMgTGFwbyBMdWNoaW5pIDxsYXBvQGxhcG8uaXQ+XFxuLy8gUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XFxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcXG4vLyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXFxuLy8gV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXFxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxcbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgaW1tZWQ6IHRydWUsIGxhdGVkZWY6IHRydWUsIHVuZGVmOiB0cnVlLCByZWdleGRhc2g6IGZhbHNlICovXFxudmFyIGRlY29kZXI7XFxudmFyIEhleCA9IHtcXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGk7XFxuICAgICAgICBpZiAoZGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdmFyIGhleCA9IFxcXCIwMTIzNDU2Nzg5QUJDREVGXFxcIjtcXG4gICAgICAgICAgICB2YXIgaWdub3JlID0gXFxcIiBcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx1MDBBMFxcXFx1MjAyOFxcXFx1MjAyOVxcXCI7XFxuICAgICAgICAgICAgZGVjb2RlciA9IHt9O1xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XFxuICAgICAgICAgICAgICAgIGRlY29kZXJbaGV4LmNoYXJBdChpKV0gPSBpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBoZXggPSBoZXgudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgICBmb3IgKGkgPSAxMDsgaSA8IDE2OyArK2kpIHtcXG4gICAgICAgICAgICAgICAgZGVjb2RlcltoZXguY2hhckF0KGkpXSA9IGk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZ25vcmUubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgZGVjb2RlcltpZ25vcmUuY2hhckF0KGkpXSA9IC0xO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBvdXQgPSBbXTtcXG4gICAgICAgIHZhciBiaXRzID0gMDtcXG4gICAgICAgIHZhciBjaGFyX2NvdW50ID0gMDtcXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcXG4gICAgICAgICAgICBpZiAoYyA9PSBcXFwiPVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGMgPSBkZWNvZGVyW2NdO1xcbiAgICAgICAgICAgIGlmIChjID09IC0xKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSWxsZWdhbCBjaGFyYWN0ZXIgYXQgb2Zmc2V0IFxcXCIgKyBpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYml0cyB8PSBjO1xcbiAgICAgICAgICAgIGlmICgrK2NoYXJfY291bnQgPj0gMikge1xcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBiaXRzO1xcbiAgICAgICAgICAgICAgICBiaXRzID0gMDtcXG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBiaXRzIDw8PSA0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaGFyX2NvdW50KSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJIZXggZW5jb2RpbmcgaW5jb21wbGV0ZTogNCBiaXRzIG1pc3NpbmdcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBvdXQ7XFxuICAgIH1cXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0pTRW5jcnlwdC8uL2xpYi9saWIvYXNuMWpzL2hleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbGliL2xpYi9hc24xanMvaW50MTAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9saWIvYXNuMWpzL2ludDEwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkludDEwXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW50MTApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLy8gQmlnIGludGVnZXIgYmFzZS0xMCBwcmludGluZyBsaWJyYXJ5XFxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IExhcG8gTHVjaGluaSA8bGFwb0BsYXBvLml0Plxcbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcXG4vLyBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXFxuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXFxuLy8gQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxcbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXFxuLy8gT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xcbnZhciBtYXggPSAxMDAwMDAwMDAwMDAwMDsgLy8gYmlnZ2VzdCBpbnRlZ2VyIHRoYXQgY2FuIHN0aWxsIGZpdCAyXjUzIHdoZW4gbXVsdGlwbGllZCBieSAyNTZcXG52YXIgSW50MTAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIEludDEwKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLmJ1ZiA9IFsrdmFsdWUgfHwgMF07XFxuICAgIH1cXG4gICAgSW50MTAucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIChtLCBjKSB7XFxuICAgICAgICAvLyBhc3NlcnQobSA8PSAyNTYpXFxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xcbiAgICAgICAgdmFyIGwgPSBiLmxlbmd0aDtcXG4gICAgICAgIHZhciBpO1xcbiAgICAgICAgdmFyIHQ7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XFxuICAgICAgICAgICAgdCA9IGJbaV0gKiBtICsgYztcXG4gICAgICAgICAgICBpZiAodCA8IG1heCkge1xcbiAgICAgICAgICAgICAgICBjID0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGMgPSAwIHwgKHQgLyBtYXgpO1xcbiAgICAgICAgICAgICAgICB0IC09IGMgKiBtYXg7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGJbaV0gPSB0O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGMgPiAwKSB7XFxuICAgICAgICAgICAgYltpXSA9IGM7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIEludDEwLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoYykge1xcbiAgICAgICAgLy8gYXNzZXJ0KG0gPD0gMjU2KVxcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcXG4gICAgICAgIHZhciBsID0gYi5sZW5ndGg7XFxuICAgICAgICB2YXIgaTtcXG4gICAgICAgIHZhciB0O1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xcbiAgICAgICAgICAgIHQgPSBiW2ldIC0gYztcXG4gICAgICAgICAgICBpZiAodCA8IDApIHtcXG4gICAgICAgICAgICAgICAgdCArPSBtYXg7XFxuICAgICAgICAgICAgICAgIGMgPSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYyA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGJbaV0gPSB0O1xcbiAgICAgICAgfVxcbiAgICAgICAgd2hpbGUgKGJbYi5sZW5ndGggLSAxXSA9PT0gMCkge1xcbiAgICAgICAgICAgIGIucG9wKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIEludDEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChiYXNlKSB7XFxuICAgICAgICBpZiAoKGJhc2UgfHwgMTApICE9IDEwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJvbmx5IGJhc2UgMTAgaXMgc3VwcG9ydGVkXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xcbiAgICAgICAgdmFyIHMgPSBiW2IubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgcyArPSAobWF4ICsgYltpXSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcztcXG4gICAgfTtcXG4gICAgSW50MTAucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuYnVmO1xcbiAgICAgICAgdmFyIHYgPSAwO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgICAgICB2ID0gdiAqIG1heCArIGJbaV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgfTtcXG4gICAgSW50MTAucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcXG4gICAgICAgIHJldHVybiAoYi5sZW5ndGggPT0gMSkgPyBiWzBdIDogdGhpcztcXG4gICAgfTtcXG4gICAgcmV0dXJuIEludDEwO1xcbn0oKSk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9hc24xanMvaW50MTAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2xpYi9saWIvanNibi9iYXNlNjQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbGliL2xpYi9qc2JuL2Jhc2U2NC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImI2NHRvQkFcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBiNjR0b0JBKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJiNjR0b2hleFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGI2NHRvaGV4KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJoZXgyYjY0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaGV4MmI2NClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcXFwiLi9saWIvbGliL2pzYm4vdXRpbC5qc1xcXCIpO1xcblxcbnZhciBiNjRtYXAgPSBcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCI7XFxudmFyIGI2NHBhZCA9IFxcXCI9XFxcIjtcXG5mdW5jdGlvbiBoZXgyYjY0KGgpIHtcXG4gICAgdmFyIGk7XFxuICAgIHZhciBjO1xcbiAgICB2YXIgcmV0ID0gXFxcIlxcXCI7XFxuICAgIGZvciAoaSA9IDA7IGkgKyAzIDw9IGgubGVuZ3RoOyBpICs9IDMpIHtcXG4gICAgICAgIGMgPSBwYXJzZUludChoLnN1YnN0cmluZyhpLCBpICsgMyksIDE2KTtcXG4gICAgICAgIHJldCArPSBiNjRtYXAuY2hhckF0KGMgPj4gNikgKyBiNjRtYXAuY2hhckF0KGMgJiA2Myk7XFxuICAgIH1cXG4gICAgaWYgKGkgKyAxID09IGgubGVuZ3RoKSB7XFxuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDEpLCAxNik7XFxuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjIDw8IDIpO1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKGkgKyAyID09IGgubGVuZ3RoKSB7XFxuICAgICAgICBjID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XFxuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjID4+IDIpICsgYjY0bWFwLmNoYXJBdCgoYyAmIDMpIDw8IDQpO1xcbiAgICB9XFxuICAgIHdoaWxlICgocmV0Lmxlbmd0aCAmIDMpID4gMCkge1xcbiAgICAgICAgcmV0ICs9IGI2NHBhZDtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbn1cXG4vLyBjb252ZXJ0IGEgYmFzZTY0IHN0cmluZyB0byBoZXhcXG5mdW5jdGlvbiBiNjR0b2hleChzKSB7XFxuICAgIHZhciByZXQgPSBcXFwiXFxcIjtcXG4gICAgdmFyIGk7XFxuICAgIHZhciBrID0gMDsgLy8gYjY0IHN0YXRlLCAwLTNcXG4gICAgdmFyIHNsb3AgPSAwO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09IGI2NHBhZCkge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHYgPSBiNjRtYXAuaW5kZXhPZihzLmNoYXJBdChpKSk7XFxuICAgICAgICBpZiAodiA8IDApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChrID09IDApIHtcXG4gICAgICAgICAgICByZXQgKz0gKDAsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pbnQyY2hhcikodiA+PiAyKTtcXG4gICAgICAgICAgICBzbG9wID0gdiAmIDM7XFxuICAgICAgICAgICAgayA9IDE7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChrID09IDEpIHtcXG4gICAgICAgICAgICByZXQgKz0gKDAsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pbnQyY2hhcikoKHNsb3AgPDwgMikgfCAodiA+PiA0KSk7XFxuICAgICAgICAgICAgc2xvcCA9IHYgJiAweGY7XFxuICAgICAgICAgICAgayA9IDI7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChrID09IDIpIHtcXG4gICAgICAgICAgICByZXQgKz0gKDAsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pbnQyY2hhcikoc2xvcCk7XFxuICAgICAgICAgICAgcmV0ICs9ICgwLF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaW50MmNoYXIpKHYgPj4gMik7XFxuICAgICAgICAgICAgc2xvcCA9IHYgJiAzO1xcbiAgICAgICAgICAgIGsgPSAzO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0ICs9ICgwLF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaW50MmNoYXIpKChzbG9wIDw8IDIpIHwgKHYgPj4gNCkpO1xcbiAgICAgICAgICAgIHJldCArPSAoMCxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmludDJjaGFyKSh2ICYgMHhmKTtcXG4gICAgICAgICAgICBrID0gMDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoayA9PSAxKSB7XFxuICAgICAgICByZXQgKz0gKDAsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5pbnQyY2hhcikoc2xvcCA8PCAyKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbn1cXG4vLyBjb252ZXJ0IGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUvbnVtYmVyIGFycmF5XFxuZnVuY3Rpb24gYjY0dG9CQShzKSB7XFxuICAgIC8vIHBpZ2d5YmFjayBvbiBiNjR0b2hleCBmb3Igbm93LCBvcHRpbWl6ZSBsYXRlclxcbiAgICB2YXIgaCA9IGI2NHRvaGV4KHMpO1xcbiAgICB2YXIgaTtcXG4gICAgdmFyIGEgPSBbXTtcXG4gICAgZm9yIChpID0gMDsgMiAqIGkgPCBoLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICBhW2ldID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgMiksIDE2KTtcXG4gICAgfVxcbiAgICByZXR1cm4gYTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9qc2JuL2Jhc2U2NC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbGliL2xpYi9qc2JuL2pzYm4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9saWIvanNibi9qc2JuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIkJpZ0ludGVnZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBCaWdJbnRlZ2VyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJpbnRBdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGludEF0KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJuYmlcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBuYmkpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm5iaXRzXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbmJpdHMpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm5idlxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG5idiksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwicGFyc2VCaWdJbnRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwYXJzZUJpZ0ludClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcXFwiLi9saWIvbGliL2pzYm4vdXRpbC5qc1xcXCIpO1xcbi8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XFxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4vLyBTZWUgXFxcIkxJQ0VOU0VcXFwiIGZvciBkZXRhaWxzLlxcbi8vIEJhc2ljIEphdmFTY3JpcHQgQk4gbGlicmFyeSAtIHN1YnNldCB1c2VmdWwgZm9yIFJTQSBlbmNyeXB0aW9uLlxcblxcbi8vIEJpdHMgcGVyIGRpZ2l0XFxudmFyIGRiaXRzO1xcbi8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXFxudmFyIGNhbmFyeSA9IDB4ZGVhZGJlZWZjYWZlO1xcbnZhciBqX2xtID0gKChjYW5hcnkgJiAweGZmZmZmZikgPT0gMHhlZmNhZmUpO1xcbi8vI3JlZ2lvblxcbnZhciBsb3dwcmltZXMgPSBbMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOSwgMzEsIDM3LCA0MSwgNDMsIDQ3LCA1MywgNTksIDYxLCA2NywgNzEsIDczLCA3OSwgODMsIDg5LCA5NywgMTAxLCAxMDMsIDEwNywgMTA5LCAxMTMsIDEyNywgMTMxLCAxMzcsIDEzOSwgMTQ5LCAxNTEsIDE1NywgMTYzLCAxNjcsIDE3MywgMTc5LCAxODEsIDE5MSwgMTkzLCAxOTcsIDE5OSwgMjExLCAyMjMsIDIyNywgMjI5LCAyMzMsIDIzOSwgMjQxLCAyNTEsIDI1NywgMjYzLCAyNjksIDI3MSwgMjc3LCAyODEsIDI4MywgMjkzLCAzMDcsIDMxMSwgMzEzLCAzMTcsIDMzMSwgMzM3LCAzNDcsIDM0OSwgMzUzLCAzNTksIDM2NywgMzczLCAzNzksIDM4MywgMzg5LCAzOTcsIDQwMSwgNDA5LCA0MTksIDQyMSwgNDMxLCA0MzMsIDQzOSwgNDQzLCA0NDksIDQ1NywgNDYxLCA0NjMsIDQ2NywgNDc5LCA0ODcsIDQ5MSwgNDk5LCA1MDMsIDUwOSwgNTIxLCA1MjMsIDU0MSwgNTQ3LCA1NTcsIDU2MywgNTY5LCA1NzEsIDU3NywgNTg3LCA1OTMsIDU5OSwgNjAxLCA2MDcsIDYxMywgNjE3LCA2MTksIDYzMSwgNjQxLCA2NDMsIDY0NywgNjUzLCA2NTksIDY2MSwgNjczLCA2NzcsIDY4MywgNjkxLCA3MDEsIDcwOSwgNzE5LCA3MjcsIDczMywgNzM5LCA3NDMsIDc1MSwgNzU3LCA3NjEsIDc2OSwgNzczLCA3ODcsIDc5NywgODA5LCA4MTEsIDgyMSwgODIzLCA4MjcsIDgyOSwgODM5LCA4NTMsIDg1NywgODU5LCA4NjMsIDg3NywgODgxLCA4ODMsIDg4NywgOTA3LCA5MTEsIDkxOSwgOTI5LCA5MzcsIDk0MSwgOTQ3LCA5NTMsIDk2NywgOTcxLCA5NzcsIDk4MywgOTkxLCA5OTddO1xcbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV07XFxuLy8jZW5kcmVnaW9uXFxuLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcXG52YXIgQmlnSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gQmlnSW50ZWdlcihhLCBiLCBjKSB7XFxuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgaWYgKFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBhKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLCBiLCBjKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PSBudWxsICYmIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKGEsIGIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyNyZWdpb24gUFVCTElDXFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gYm5Ub1N0cmluZztcXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBpZiAodGhpcy5zIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiLVxcXCIgKyB0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGs7XFxuICAgICAgICBpZiAoYiA9PSAxNikge1xcbiAgICAgICAgICAgIGsgPSA0O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoYiA9PSA4KSB7XFxuICAgICAgICAgICAgayA9IDM7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChiID09IDIpIHtcXG4gICAgICAgICAgICBrID0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMzIpIHtcXG4gICAgICAgICAgICBrID0gNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGIgPT0gNCkge1xcbiAgICAgICAgICAgIGsgPSAyO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBrbSA9ICgxIDw8IGspIC0gMTtcXG4gICAgICAgIHZhciBkO1xcbiAgICAgICAgdmFyIG0gPSBmYWxzZTtcXG4gICAgICAgIHZhciByID0gXFxcIlxcXCI7XFxuICAgICAgICB2YXIgaSA9IHRoaXMudDtcXG4gICAgICAgIHZhciBwID0gdGhpcy5EQiAtIChpICogdGhpcy5EQikgJSBrO1xcbiAgICAgICAgaWYgKGktLSA+IDApIHtcXG4gICAgICAgICAgICBpZiAocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldID4+IHApID4gMCkge1xcbiAgICAgICAgICAgICAgICBtID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgciA9ICgwLF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaW50MmNoYXIpKGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIGlmIChwIDwgaykge1xcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcCk7XFxuICAgICAgICAgICAgICAgICAgICBkIHw9IHRoaXNbLS1pXSA+PiAocCArPSB0aGlzLkRCIC0gayk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBkID0gKHRoaXNbaV0gPj4gKHAgLT0gaykpICYga207XFxuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoZCA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIG0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChtKSB7XFxuICAgICAgICAgICAgICAgICAgICByICs9ICgwLF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uaW50MmNoYXIpKGQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG0gPyByIDogXFxcIjBcXFwiO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcXG4gICAgLy8gKHB1YmxpYykgLXRoaXNcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCByKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBibkFicztcXG4gICAgLy8gKHB1YmxpYykgfHRoaXN8XFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcztcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XFxuICAgIC8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgciA9IHRoaXMucyAtIGEucztcXG4gICAgICAgIGlmIChyICE9IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gcjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBpID0gdGhpcy50O1xcbiAgICAgICAgciA9IGkgLSBhLnQ7XFxuICAgICAgICBpZiAociAhPSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IC1yIDogcjtcXG4gICAgICAgIH1cXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xcbiAgICAgICAgICAgIGlmICgociA9IHRoaXNbaV0gLSBhW2ldKSAhPSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiByO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAwO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcXFwidGhpc1xcXCJcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMudCA8PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcy5EQiAqICh0aGlzLnQgLSAxKSArIG5iaXRzKHRoaXNbdGhpcy50IC0gMV0gXiAodGhpcy5zICYgdGhpcy5ETSkpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBibk1vZDtcXG4gICAgLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMuYWJzKCkuZGl2UmVtVG8oYSwgbnVsbCwgcik7XFxuICAgICAgICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkge1xcbiAgICAgICAgICAgIGEuc3ViVG8ociwgcik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XFxuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gZnVuY3Rpb24gKGUsIG0pIHtcXG4gICAgICAgIHZhciB6O1xcbiAgICAgICAgaWYgKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgIHogPSBuZXcgQ2xhc3NpYyhtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLmV4cChlLCB6KTtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBibkNsb25lO1xcbiAgICAvLyAocHVibGljKVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICB0aGlzLmNvcHlUbyhyKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XFxuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcXG4gICAgICAgICAgICBpZiAodGhpcy50ID09IDEpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gLSB0aGlzLkRWO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAodGhpcy50ID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxcbiAgICAgICAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAyNCkgPj4gMjQ7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XFxuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gKHRoaXMudCA9PSAwKSA/IHRoaXMucyA6ICh0aGlzWzBdIDw8IDE2KSA+PiAxNjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XFxuICAgIC8vIChwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXk7XFxuICAgIC8vIChwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgaSA9IHRoaXMudDtcXG4gICAgICAgIHZhciByID0gW107XFxuICAgICAgICByWzBdID0gdGhpcy5zO1xcbiAgICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gKGkgKiB0aGlzLkRCKSAlIDg7XFxuICAgICAgICB2YXIgZDtcXG4gICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgIGlmIChpLS0gPiAwKSB7XFxuICAgICAgICAgICAgaWYgKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXSA+PiBwKSAhPSAodGhpcy5zICYgdGhpcy5ETSkgPj4gcCkge1xcbiAgICAgICAgICAgICAgICByW2srK10gPSBkIHwgKHRoaXMucyA8PCAodGhpcy5EQiAtIHApKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xcbiAgICAgICAgICAgICAgICBpZiAocCA8IDgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoOCAtIHApO1xcbiAgICAgICAgICAgICAgICAgICAgZCB8PSB0aGlzWy0taV0gPj4gKHAgKz0gdGhpcy5EQiAtIDgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgZCA9ICh0aGlzW2ldID4+IChwIC09IDgpKSAmIDB4ZmY7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocCA8PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoKGQgJiAweDgwKSAhPSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBkIHw9IC0yNTY7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGsgPT0gMCAmJiAodGhpcy5zICYgMHg4MCkgIT0gKGQgJiAweDgwKSkge1xcbiAgICAgICAgICAgICAgICAgICAgKytrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChrID4gMCB8fCBkICE9IHRoaXMucykge1xcbiAgICAgICAgICAgICAgICAgICAgcltrKytdID0gZDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPT0gMCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGJuTWluO1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA8IDApID8gdGhpcyA6IGE7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1heCA9IGJuTWF4O1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA+IDApID8gdGhpcyA6IGE7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ub3BfYW5kLCByKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGJuT3I7XFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wX29yLCByKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBiblhvcjtcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wX3hvciwgcik7XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZE5vdCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8oYSwgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vcF9hbmRub3QsIHIpO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xcbiAgICAvLyAocHVibGljKSB+dGhpc1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xcbiAgICAgICAgICAgIHJbaV0gPSB0aGlzLkRNICYgfnRoaXNbaV07XFxuICAgICAgICB9XFxuICAgICAgICByLnQgPSB0aGlzLnQ7XFxuICAgICAgICByLnMgPSB+dGhpcy5zO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0O1xcbiAgICAvLyAocHVibGljKSB0aGlzIDw8IG5cXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICBpZiAobiA8IDApIHtcXG4gICAgICAgICAgICB0aGlzLnJTaGlmdFRvKC1uLCByKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8obiwgcik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodDtcXG4gICAgLy8gKHB1YmxpYykgdGhpcyA+PiBuXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiAobikge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIGlmIChuIDwgMCkge1xcbiAgICAgICAgICAgIHRoaXMubFNoaWZ0VG8oLW4sIHIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5yU2hpZnRUbyhuLCByKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdDtcXG4gICAgLy8gKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHtcXG4gICAgICAgICAgICBpZiAodGhpc1tpXSAhPSAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogdGhpcy5EQiArICgwLF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubGJpdCkodGhpc1tpXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMucyA8IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ICogdGhpcy5EQjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBibkJpdENvdW50O1xcbiAgICAvLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHIgPSAwO1xcbiAgICAgICAgdmFyIHggPSB0aGlzLnMgJiB0aGlzLkRNO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xcbiAgICAgICAgICAgIHIgKz0gKDAsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5jYml0KSh0aGlzW2ldIF4geCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcXG4gICAgLy8gKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xcbiAgICAgICAgaWYgKGogPj0gdGhpcy50KSB7XFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnMgIT0gMCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCh0aGlzW2pdICYgKDEgPDwgKG4gJSB0aGlzLkRCKSkpICE9IDApO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBiblNldEJpdDtcXG4gICAgLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zZXRCaXQgPSBmdW5jdGlvbiAobikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ub3Bfb3IpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XFxuICAgIC8vIChwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsZWFyQml0ID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wX2FuZG5vdCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZsaXBCaXQgPSBibkZsaXBCaXQ7XFxuICAgIC8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vcF94b3IpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBibkFkZDtcXG4gICAgLy8gKHB1YmxpYykgdGhpcyArIGFcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICB0aGlzLmFkZFRvKGEsIHIpO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdDtcXG4gICAgLy8gKHB1YmxpYykgdGhpcyAtIGFcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMuc3ViVG8oYSwgcik7XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBibk11bHRpcGx5O1xcbiAgICAvLyAocHVibGljKSB0aGlzICogYVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvKGEsIHIpO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGJuRGl2aWRlO1xcbiAgICAvLyAocHVibGljKSB0aGlzIC8gYVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgciwgbnVsbCk7XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gYm5SZW1haW5kZXI7XFxuICAgIC8vIChwdWJsaWMpIHRoaXMgJSBhXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhhLCBudWxsLCByKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlcjtcXG4gICAgLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgcSA9IG5iaSgpO1xcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgcSwgcik7XFxuICAgICAgICByZXR1cm4gW3EsIHJdO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcXG4gICAgLy8gKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZSwgbSkge1xcbiAgICAgICAgdmFyIGkgPSBlLmJpdExlbmd0aCgpO1xcbiAgICAgICAgdmFyIGs7XFxuICAgICAgICB2YXIgciA9IG5idigxKTtcXG4gICAgICAgIHZhciB6O1xcbiAgICAgICAgaWYgKGkgPD0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiByO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaSA8IDE4KSB7XFxuICAgICAgICAgICAgayA9IDE7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpIDwgNDgpIHtcXG4gICAgICAgICAgICBrID0gMztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGkgPCAxNDQpIHtcXG4gICAgICAgICAgICBrID0gNDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGkgPCA3NjgpIHtcXG4gICAgICAgICAgICBrID0gNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGsgPSA2O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGkgPCA4KSB7XFxuICAgICAgICAgICAgeiA9IG5ldyBDbGFzc2ljKG0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAobS5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgIHogPSBuZXcgQmFycmV0dChtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHByZWNvbXB1dGF0aW9uXFxuICAgICAgICB2YXIgZyA9IFtdO1xcbiAgICAgICAgdmFyIG4gPSAzO1xcbiAgICAgICAgdmFyIGsxID0gayAtIDE7XFxuICAgICAgICB2YXIga20gPSAoMSA8PCBrKSAtIDE7XFxuICAgICAgICBnWzFdID0gei5jb252ZXJ0KHRoaXMpO1xcbiAgICAgICAgaWYgKGsgPiAxKSB7XFxuICAgICAgICAgICAgdmFyIGcyID0gbmJpKCk7XFxuICAgICAgICAgICAgei5zcXJUbyhnWzFdLCBnMik7XFxuICAgICAgICAgICAgd2hpbGUgKG4gPD0ga20pIHtcXG4gICAgICAgICAgICAgICAgZ1tuXSA9IG5iaSgpO1xcbiAgICAgICAgICAgICAgICB6Lm11bFRvKGcyLCBnW24gLSAyXSwgZ1tuXSk7XFxuICAgICAgICAgICAgICAgIG4gKz0gMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgaiA9IGUudCAtIDE7XFxuICAgICAgICB2YXIgdztcXG4gICAgICAgIHZhciBpczEgPSB0cnVlO1xcbiAgICAgICAgdmFyIHIyID0gbmJpKCk7XFxuICAgICAgICB2YXIgdDtcXG4gICAgICAgIGkgPSBuYml0cyhlW2pdKSAtIDE7XFxuICAgICAgICB3aGlsZSAoaiA+PSAwKSB7XFxuICAgICAgICAgICAgaWYgKGkgPj0gazEpIHtcXG4gICAgICAgICAgICAgICAgdyA9IChlW2pdID4+IChpIC0gazEpKSAmIGttO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdyA9IChlW2pdICYgKCgxIDw8IChpICsgMSkpIC0gMSkpIDw8IChrMSAtIGkpO1xcbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG4gPSBrO1xcbiAgICAgICAgICAgIHdoaWxlICgodyAmIDEpID09IDApIHtcXG4gICAgICAgICAgICAgICAgdyA+Pj0gMTtcXG4gICAgICAgICAgICAgICAgLS1uO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoKGkgLT0gbikgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGkgKz0gdGhpcy5EQjtcXG4gICAgICAgICAgICAgICAgLS1qO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoaXMxKSB7IC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcXG4gICAgICAgICAgICAgICAgZ1t3XS5jb3B5VG8ocik7XFxuICAgICAgICAgICAgICAgIGlzMSA9IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPiAxKSB7XFxuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcXG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ocjIsIHIpO1xcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChuID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyLCByMik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0ID0gcjtcXG4gICAgICAgICAgICAgICAgICAgIHIgPSByMjtcXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiAoZVtqXSAmICgxIDw8IGkpKSA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHouc3FyVG8ociwgcjIpO1xcbiAgICAgICAgICAgICAgICB0ID0gcjtcXG4gICAgICAgICAgICAgICAgciA9IHIyO1xcbiAgICAgICAgICAgICAgICByMiA9IHQ7XFxuICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5EQiAtIDE7XFxuICAgICAgICAgICAgICAgICAgICAtLWo7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gei5yZXZlcnQocik7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XFxuICAgIC8vIChwdWJsaWMpIDEvdGhpcyAlIG0gKEhBQyAxNC42MSlcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChtKSB7XFxuICAgICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xcbiAgICAgICAgaWYgKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHUgPSBtLmNsb25lKCk7XFxuICAgICAgICB2YXIgdiA9IHRoaXMuY2xvbmUoKTtcXG4gICAgICAgIHZhciBhID0gbmJ2KDEpO1xcbiAgICAgICAgdmFyIGIgPSBuYnYoMCk7XFxuICAgICAgICB2YXIgYyA9IG5idigwKTtcXG4gICAgICAgIHZhciBkID0gbmJ2KDEpO1xcbiAgICAgICAgd2hpbGUgKHUuc2lnbnVtKCkgIT0gMCkge1xcbiAgICAgICAgICAgIHdoaWxlICh1LmlzRXZlbigpKSB7XFxuICAgICAgICAgICAgICAgIHUuclNoaWZ0VG8oMSwgdSk7XFxuICAgICAgICAgICAgICAgIGlmIChhYykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYS5hZGRUbyh0aGlzLCBhKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnN1YlRvKG0sIGIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgYS5yU2hpZnRUbygxLCBhKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYi5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgICAgICAgICAgYi5zdWJUbyhtLCBiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBiLnJTaGlmdFRvKDEsIGIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3aGlsZSAodi5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgICAgICB2LnJTaGlmdFRvKDEsIHYpO1xcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYWRkVG8odGhpcywgYyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZC5zdWJUbyhtLCBkKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGMuclNoaWZ0VG8oMSwgYyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWQuaXNFdmVuKCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGQuc3ViVG8obSwgZCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZC5yU2hpZnRUbygxLCBkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcXG4gICAgICAgICAgICAgICAgdS5zdWJUbyh2LCB1KTtcXG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XFxuICAgICAgICAgICAgICAgICAgICBhLnN1YlRvKGMsIGEpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGIuc3ViVG8oZCwgYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2LnN1YlRvKHUsIHYpO1xcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcXG4gICAgICAgICAgICAgICAgICAgIGMuc3ViVG8oYSwgYyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZC5zdWJUbyhiLCBkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGQuY29tcGFyZVRvKG0pID49IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gZC5zdWJ0cmFjdChtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xcbiAgICAgICAgICAgIGQuYWRkVG8obSwgZCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChkLnNpZ251bSgpIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiBkLmFkZChtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcXG4gICAgLy8gKHB1YmxpYykgdGhpc15lXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5leHAoZSwgbmV3IE51bGxFeHAoKSk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xcbiAgICAvLyAocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpO1xcbiAgICAgICAgdmFyIHkgPSAoYS5zIDwgMCkgPyBhLm5lZ2F0ZSgpIDogYS5jbG9uZSgpO1xcbiAgICAgICAgaWYgKHguY29tcGFyZVRvKHkpIDwgMCkge1xcbiAgICAgICAgICAgIHZhciB0ID0geDtcXG4gICAgICAgICAgICB4ID0geTtcXG4gICAgICAgICAgICB5ID0gdDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKTtcXG4gICAgICAgIHZhciBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcXG4gICAgICAgIGlmIChnIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGkgPCBnKSB7XFxuICAgICAgICAgICAgZyA9IGk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZyA+IDApIHtcXG4gICAgICAgICAgICB4LnJTaGlmdFRvKGcsIHgpO1xcbiAgICAgICAgICAgIHkuclNoaWZ0VG8oZywgeSk7XFxuICAgICAgICB9XFxuICAgICAgICB3aGlsZSAoeC5zaWdudW0oKSA+IDApIHtcXG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcXG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XFxuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XFxuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oMSwgeCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB5LnN1YlRvKHgsIHkpO1xcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChnID4gMCkge1xcbiAgICAgICAgICAgIHkubFNoaWZ0VG8oZywgeSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geTtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XFxuICAgIC8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAodCkge1xcbiAgICAgICAgdmFyIGk7XFxuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XFxuICAgICAgICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgICAgICBpZiAoeFswXSA9PSBsb3dwcmltZXNbaV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh4LmlzRXZlbigpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaSA9IDE7XFxuICAgICAgICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXTtcXG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIHtcXG4gICAgICAgICAgICAgICAgbSAqPSBsb3dwcmltZXNbaisrXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbSA9IHgubW9kSW50KG0pO1xcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaikge1xcbiAgICAgICAgICAgICAgICBpZiAobSAlIGxvd3ByaW1lc1tpKytdID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xcbiAgICB9O1xcbiAgICAvLyNlbmRyZWdpb24gUFVCTElDXFxuICAgIC8vI3JlZ2lvbiBQUk9URUNURURcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbiAocikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgcltpXSA9IHRoaXNbaV07XFxuICAgICAgICB9XFxuICAgICAgICByLnQgPSB0aGlzLnQ7XFxuICAgICAgICByLnMgPSB0aGlzLnM7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBibnBGcm9tSW50O1xcbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICB0aGlzLnQgPSAxO1xcbiAgICAgICAgdGhpcy5zID0gKHggPCAwKSA/IC0xIDogMDtcXG4gICAgICAgIGlmICh4ID4gMCkge1xcbiAgICAgICAgICAgIHRoaXNbMF0gPSB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoeCA8IC0xKSB7XFxuICAgICAgICAgICAgdGhpc1swXSA9IHggKyB0aGlzLkRWO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy50ID0gMDtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmc7XFxuICAgIC8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzLCBiKSB7XFxuICAgICAgICB2YXIgaztcXG4gICAgICAgIGlmIChiID09IDE2KSB7XFxuICAgICAgICAgICAgayA9IDQ7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChiID09IDgpIHtcXG4gICAgICAgICAgICBrID0gMztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMjU2KSB7XFxuICAgICAgICAgICAgayA9IDg7XFxuICAgICAgICAgICAgLyogYnl0ZSBhcnJheSAqL1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoYiA9PSAyKSB7XFxuICAgICAgICAgICAgayA9IDE7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChiID09IDMyKSB7XFxuICAgICAgICAgICAgayA9IDU7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChiID09IDQpIHtcXG4gICAgICAgICAgICBrID0gMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuZnJvbVJhZGl4KHMsIGIpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMudCA9IDA7XFxuICAgICAgICB0aGlzLnMgPSAwO1xcbiAgICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcXG4gICAgICAgIHZhciBtaSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIHNoID0gMDtcXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xcbiAgICAgICAgICAgIHZhciB4ID0gKGsgPT0gOCkgPyAoK3NbaV0pICYgMHhmZiA6IGludEF0KHMsIGkpO1xcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xcbiAgICAgICAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXFxcIi1cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG1pID0gZmFsc2U7XFxuICAgICAgICAgICAgaWYgKHNoID09IDApIHtcXG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSB4O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChzaCArIGsgPiB0aGlzLkRCKSB7XFxuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHRoaXMuREIgLSBzaCkpIC0gMSkpIDw8IHNoO1xcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9ICh4ID4+ICh0aGlzLkRCIC0gc2gpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0geCA8PCBzaDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc2ggKz0gaztcXG4gICAgICAgICAgICBpZiAoc2ggPj0gdGhpcy5EQikge1xcbiAgICAgICAgICAgICAgICBzaCAtPSB0aGlzLkRCO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChrID09IDggJiYgKCgrc1swXSkgJiAweDgwKSAhPSAwKSB7XFxuICAgICAgICAgICAgdGhpcy5zID0gLTE7XFxuICAgICAgICAgICAgaWYgKHNoID4gMCkge1xcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCAtIDFdIHw9ICgoMSA8PCAodGhpcy5EQiAtIHNoKSkgLSAxKSA8PCBzaDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmNsYW1wKCk7XFxuICAgICAgICBpZiAobWkpIHtcXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgdGhpcyk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XFxuICAgIC8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5zICYgdGhpcy5ETTtcXG4gICAgICAgIHdoaWxlICh0aGlzLnQgPiAwICYmIHRoaXNbdGhpcy50IC0gMV0gPT0gYykge1xcbiAgICAgICAgICAgIC0tdGhpcy50O1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XFxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcXG4gICAgICAgIHZhciBpO1xcbiAgICAgICAgZm9yIChpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgICAgICByW2kgKyBuXSA9IHRoaXNbaV07XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgICAgICByW2ldID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHIudCA9IHRoaXMudCArIG47XFxuICAgICAgICByLnMgPSB0aGlzLnM7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUbztcXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkge1xcbiAgICAgICAgICAgIHJbaSAtIG5dID0gdGhpc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHIudCA9IE1hdGgubWF4KHRoaXMudCAtIG4sIDApO1xcbiAgICAgICAgci5zID0gdGhpcy5zO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcXG4gICAgICAgIHZhciBicyA9IG4gJSB0aGlzLkRCO1xcbiAgICAgICAgdmFyIGNicyA9IHRoaXMuREIgLSBicztcXG4gICAgICAgIHZhciBibSA9ICgxIDw8IGNicykgLSAxO1xcbiAgICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XFxuICAgICAgICB2YXIgYyA9ICh0aGlzLnMgPDwgYnMpICYgdGhpcy5ETTtcXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgICAgIHJbaSArIGRzICsgMV0gPSAodGhpc1tpXSA+PiBjYnMpIHwgYztcXG4gICAgICAgICAgICBjID0gKHRoaXNbaV0gJiBibSkgPDwgYnM7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBpID0gZHMgLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgICAgIHJbaV0gPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgcltkc10gPSBjO1xcbiAgICAgICAgci50ID0gdGhpcy50ICsgZHMgKyAxO1xcbiAgICAgICAgci5zID0gdGhpcy5zO1xcbiAgICAgICAgci5jbGFtcCgpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yU2hpZnRUbyA9IGJucFJTaGlmdFRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcXG4gICAgICAgIHIucyA9IHRoaXMucztcXG4gICAgICAgIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xcbiAgICAgICAgaWYgKGRzID49IHRoaXMudCkge1xcbiAgICAgICAgICAgIHIudCA9IDA7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGJzID0gbiAlIHRoaXMuREI7XFxuICAgICAgICB2YXIgY2JzID0gdGhpcy5EQiAtIGJzO1xcbiAgICAgICAgdmFyIGJtID0gKDEgPDwgYnMpIC0gMTtcXG4gICAgICAgIHJbMF0gPSB0aGlzW2RzXSA+PiBicztcXG4gICAgICAgIGZvciAodmFyIGkgPSBkcyArIDE7IGkgPCB0aGlzLnQ7ICsraSkge1xcbiAgICAgICAgICAgIHJbaSAtIGRzIC0gMV0gfD0gKHRoaXNbaV0gJiBibSkgPDwgY2JzO1xcbiAgICAgICAgICAgIHJbaSAtIGRzXSA9IHRoaXNbaV0gPj4gYnM7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYnMgPiAwKSB7XFxuICAgICAgICAgICAgclt0aGlzLnQgLSBkcyAtIDFdIHw9ICh0aGlzLnMgJiBibSkgPDwgY2JzO1xcbiAgICAgICAgfVxcbiAgICAgICAgci50ID0gdGhpcy50IC0gZHM7XFxuICAgICAgICByLmNsYW1wKCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XFxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGZ1bmN0aW9uIChhLCByKSB7XFxuICAgICAgICB2YXIgaSA9IDA7XFxuICAgICAgICB2YXIgYyA9IDA7XFxuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcXG4gICAgICAgIHdoaWxlIChpIDwgbSkge1xcbiAgICAgICAgICAgIGMgKz0gdGhpc1tpXSAtIGFbaV07XFxuICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XFxuICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcXG4gICAgICAgICAgICBjIC09IGEucztcXG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMudCkge1xcbiAgICAgICAgICAgICAgICBjICs9IHRoaXNbaV07XFxuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjICs9IHRoaXMucztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYS50KSB7XFxuICAgICAgICAgICAgICAgIGMgLT0gYVtpXTtcXG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XFxuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGMgLT0gYS5zO1xcbiAgICAgICAgfVxcbiAgICAgICAgci5zID0gKGMgPCAwKSA/IC0xIDogMDtcXG4gICAgICAgIGlmIChjIDwgLTEpIHtcXG4gICAgICAgICAgICByW2krK10gPSB0aGlzLkRWICsgYztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGMgPiAwKSB7XFxuICAgICAgICAgICAgcltpKytdID0gYztcXG4gICAgICAgIH1cXG4gICAgICAgIHIudCA9IGk7XFxuICAgICAgICByLmNsYW1wKCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXFxuICAgIC8vIFxcXCJ0aGlzXFxcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VG8gPSBmdW5jdGlvbiAoYSwgcikge1xcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xcbiAgICAgICAgdmFyIHkgPSBhLmFicygpO1xcbiAgICAgICAgdmFyIGkgPSB4LnQ7XFxuICAgICAgICByLnQgPSBpICsgeS50O1xcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XFxuICAgICAgICAgICAgcltpXSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeS50OyArK2kpIHtcXG4gICAgICAgICAgICByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgci5zID0gMDtcXG4gICAgICAgIHIuY2xhbXAoKTtcXG4gICAgICAgIGlmICh0aGlzLnMgIT0gYS5zKSB7XFxuICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGJucFNxdWFyZVRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBmdW5jdGlvbiAocikge1xcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xcbiAgICAgICAgdmFyIGkgPSByLnQgPSAyICogeC50O1xcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XFxuICAgICAgICAgICAgcltpXSA9IDA7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC50IC0gMTsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcXG4gICAgICAgICAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XFxuICAgICAgICAgICAgICAgIHJbaSArIHgudF0gLT0geC5EVjtcXG4gICAgICAgICAgICAgICAgcltpICsgeC50ICsgMV0gPSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyLnQgPiAwKSB7XFxuICAgICAgICAgICAgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHIucyA9IDA7XFxuICAgICAgICByLmNsYW1wKCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gYm5wRGl2UmVtVG87XFxuICAgIC8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxcbiAgICAvLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBmdW5jdGlvbiAobSwgcSwgcikge1xcbiAgICAgICAgdmFyIHBtID0gbS5hYnMoKTtcXG4gICAgICAgIGlmIChwbS50IDw9IDApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcHQgPSB0aGlzLmFicygpO1xcbiAgICAgICAgaWYgKHB0LnQgPCBwbS50KSB7XFxuICAgICAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICBxLmZyb21JbnQoMCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChyICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VG8ocik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyID09IG51bGwpIHtcXG4gICAgICAgICAgICByID0gbmJpKCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgeSA9IG5iaSgpO1xcbiAgICAgICAgdmFyIHRzID0gdGhpcy5zO1xcbiAgICAgICAgdmFyIG1zID0gbS5zO1xcbiAgICAgICAgdmFyIG5zaCA9IHRoaXMuREIgLSBuYml0cyhwbVtwbS50IC0gMV0pOyAvLyBub3JtYWxpemUgbW9kdWx1c1xcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcXG4gICAgICAgICAgICBwbS5sU2hpZnRUbyhuc2gsIHkpO1xcbiAgICAgICAgICAgIHB0LmxTaGlmdFRvKG5zaCwgcik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBwbS5jb3B5VG8oeSk7XFxuICAgICAgICAgICAgcHQuY29weVRvKHIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHlzID0geS50O1xcbiAgICAgICAgdmFyIHkwID0geVt5cyAtIDFdO1xcbiAgICAgICAgaWYgKHkwID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgeXQgPSB5MCAqICgxIDw8IHRoaXMuRjEpICsgKCh5cyA+IDEpID8geVt5cyAtIDJdID4+IHRoaXMuRjIgOiAwKTtcXG4gICAgICAgIHZhciBkMSA9IHRoaXMuRlYgLyB5dDtcXG4gICAgICAgIHZhciBkMiA9ICgxIDw8IHRoaXMuRjEpIC8geXQ7XFxuICAgICAgICB2YXIgZSA9IDEgPDwgdGhpcy5GMjtcXG4gICAgICAgIHZhciBpID0gci50O1xcbiAgICAgICAgdmFyIGogPSBpIC0geXM7XFxuICAgICAgICB2YXIgdCA9IChxID09IG51bGwpID8gbmJpKCkgOiBxO1xcbiAgICAgICAgeS5kbFNoaWZ0VG8oaiwgdCk7XFxuICAgICAgICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xcbiAgICAgICAgICAgIHJbci50KytdID0gMTtcXG4gICAgICAgICAgICByLnN1YlRvKHQsIHIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLCB0KTtcXG4gICAgICAgIHQuc3ViVG8oeSwgeSk7IC8vIFxcXCJuZWdhdGl2ZVxcXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxcbiAgICAgICAgd2hpbGUgKHkudCA8IHlzKSB7XFxuICAgICAgICAgICAgeVt5LnQrK10gPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgd2hpbGUgKC0taiA+PSAwKSB7XFxuICAgICAgICAgICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcXG4gICAgICAgICAgICB2YXIgcWQgPSAoclstLWldID09IHkwKSA/IHRoaXMuRE0gOiBNYXRoLmZsb29yKHJbaV0gKiBkMSArIChyW2kgLSAxXSArIGUpICogZDIpO1xcbiAgICAgICAgICAgIGlmICgocltpXSArPSB5LmFtKDAsIHFkLCByLCBqLCAwLCB5cykpIDwgcWQpIHsgLy8gVHJ5IGl0IG91dFxcbiAgICAgICAgICAgICAgICB5LmRsU2hpZnRUbyhqLCB0KTtcXG4gICAgICAgICAgICAgICAgci5zdWJUbyh0LCByKTtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJbaV0gPCAtLXFkKSB7XFxuICAgICAgICAgICAgICAgICAgICByLnN1YlRvKHQsIHIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHEgIT0gbnVsbCkge1xcbiAgICAgICAgICAgIHIuZHJTaGlmdFRvKHlzLCBxKTtcXG4gICAgICAgICAgICBpZiAodHMgIT0gbXMpIHtcXG4gICAgICAgICAgICAgICAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHIudCA9IHlzO1xcbiAgICAgICAgci5jbGFtcCgpO1xcbiAgICAgICAgaWYgKG5zaCA+IDApIHtcXG4gICAgICAgICAgICByLnJTaGlmdFRvKG5zaCwgcik7XFxuICAgICAgICB9IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxcbiAgICAgICAgaWYgKHRzIDwgMCkge1xcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIFxcXCItMS90aGlzICUgMl5EQlxcXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXFxuICAgIC8vIGp1c3RpZmljYXRpb246XFxuICAgIC8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXFxuICAgIC8vICAgICAgICAgeHkgPSAgMStrbVxcbiAgICAvLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXFxuICAgIC8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxcbiAgICAvLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXFxuICAgIC8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcXG4gICAgLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXFxuICAgIC8vIEpTIG11bHRpcGx5IFxcXCJvdmVyZmxvd3NcXFwiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludkRpZ2l0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMudCA8IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB4ID0gdGhpc1swXTtcXG4gICAgICAgIGlmICgoeCAmIDEpID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcXG4gICAgICAgIHkgPSAoeSAqICgyIC0gKHggJiAweGYpICogeSkpICYgMHhmOyAvLyB5ID09IDEveCBtb2QgMl40XFxuICAgICAgICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmZikgKiB5KSkgJiAweGZmOyAvLyB5ID09IDEveCBtb2QgMl44XFxuICAgICAgICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XFxuICAgICAgICAvLyBsYXN0IHN0ZXAgLSBjYWxjdWxhdGUgaW52ZXJzZSBtb2QgRFYgZGlyZWN0bHk7XFxuICAgICAgICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcXG4gICAgICAgIHkgPSAoeSAqICgyIC0geCAqIHkgJSB0aGlzLkRWKSkgJSB0aGlzLkRWOyAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xcbiAgICAgICAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcXG4gICAgICAgIHJldHVybiAoeSA+IDApID8gdGhpcy5EViAtIHkgOiAteTtcXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gYm5wSXNFdmVuO1xcbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICgodGhpcy50ID4gMCkgPyAodGhpc1swXSAmIDEpIDogdGhpcy5zKSA9PSAwO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XFxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXFxcInJcXFwiIChIQUMgMTQuNzkpXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChlLCB6KSB7XFxuICAgICAgICBpZiAoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5PTkU7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgdmFyIHIyID0gbmJpKCk7XFxuICAgICAgICB2YXIgZyA9IHouY29udmVydCh0aGlzKTtcXG4gICAgICAgIHZhciBpID0gbmJpdHMoZSkgLSAxO1xcbiAgICAgICAgZy5jb3B5VG8ocik7XFxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcXG4gICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcXG4gICAgICAgICAgICBpZiAoKGUgJiAoMSA8PCBpKSkgPiAwKSB7XFxuICAgICAgICAgICAgICAgIHoubXVsVG8ocjIsIGcsIHIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFyIHQgPSByO1xcbiAgICAgICAgICAgICAgICByID0gcjI7XFxuICAgICAgICAgICAgICAgIHIyID0gdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gei5yZXZlcnQocik7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZTtcXG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAocikge1xcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIgKiB0aGlzLkRCIC8gTWF0aC5sb2cocikpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gYm5wVG9SYWRpeDtcXG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XFxuICAgICAgICAgICAgYiA9IDEwO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcIjBcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XFxuICAgICAgICB2YXIgYSA9IE1hdGgucG93KGIsIGNzKTtcXG4gICAgICAgIHZhciBkID0gbmJ2KGEpO1xcbiAgICAgICAgdmFyIHkgPSBuYmkoKTtcXG4gICAgICAgIHZhciB6ID0gbmJpKCk7XFxuICAgICAgICB2YXIgciA9IFxcXCJcXFwiO1xcbiAgICAgICAgdGhpcy5kaXZSZW1UbyhkLCB5LCB6KTtcXG4gICAgICAgIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xcbiAgICAgICAgICAgIHIgPSAoYSArIHouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpICsgcjtcXG4gICAgICAgICAgICB5LmRpdlJlbVRvKGQsIHksIHopO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKSArIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeDtcXG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBmdW5jdGlvbiAocywgYikge1xcbiAgICAgICAgdGhpcy5mcm9tSW50KDApO1xcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xcbiAgICAgICAgICAgIGIgPSAxMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xcbiAgICAgICAgdmFyIGQgPSBNYXRoLnBvdyhiLCBjcyk7XFxuICAgICAgICB2YXIgbWkgPSBmYWxzZTtcXG4gICAgICAgIHZhciBqID0gMDtcXG4gICAgICAgIHZhciB3ID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgIHZhciB4ID0gaW50QXQocywgaSk7XFxuICAgICAgICAgICAgaWYgKHggPCAwKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcXFwiLVxcXCIgJiYgdGhpcy5zaWdudW0oKSA9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBtaSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHcgPSBiICogdyArIHg7XFxuICAgICAgICAgICAgaWYgKCsraiA+PSBjcykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRNdWx0aXBseShkKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsIDApO1xcbiAgICAgICAgICAgICAgICBqID0gMDtcXG4gICAgICAgICAgICAgICAgdyA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGogPiAwKSB7XFxuICAgICAgICAgICAgdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpO1xcbiAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LCAwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChtaSkge1xcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXI7XFxuICAgIC8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgIGlmIChcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgYikge1xcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxcbiAgICAgICAgICAgIGlmIChhIDwgMikge1xcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21JbnQoMSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSwgYyk7XFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXN0Qml0KGEgLSAxKSkge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgTVNCIHNldFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5vcF9vciwgdGhpcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFdmVuKCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcXG4gICAgICAgICAgICAgICAgfSAvLyBmb3JjZSBvZGRcXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDIsIDApO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TGVuZ3RoKCkgPiBhKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCB0aGlzKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXFxuICAgICAgICAgICAgdmFyIHggPSBbXTtcXG4gICAgICAgICAgICB2YXIgdCA9IGEgJiA3O1xcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xcbiAgICAgICAgICAgIGlmICh0ID4gMCkge1xcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LCAyNTYpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG87XFxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGZ1bmN0aW9uIChhLCBvcCwgcikge1xcbiAgICAgICAgdmFyIGk7XFxuICAgICAgICB2YXIgZjtcXG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xcbiAgICAgICAgICAgIHJbaV0gPSBvcCh0aGlzW2ldLCBhW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcXG4gICAgICAgICAgICBmID0gYS5zICYgdGhpcy5ETTtcXG4gICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHtcXG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKHRoaXNbaV0sIGYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByLnQgPSB0aGlzLnQ7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBmID0gdGhpcy5zICYgdGhpcy5ETTtcXG4gICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDwgYS50OyArK2kpIHtcXG4gICAgICAgICAgICAgICAgcltpXSA9IG9wKGYsIGFbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByLnQgPSBhLnQ7XFxuICAgICAgICB9XFxuICAgICAgICByLnMgPSBvcCh0aGlzLnMsIGEucyk7XFxuICAgICAgICByLmNsYW1wKCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2hhbmdlQml0ID0gZnVuY3Rpb24gKG4sIG9wKSB7XFxuICAgICAgICB2YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKTtcXG4gICAgICAgIHRoaXMuYml0d2lzZVRvKHIsIG9wLCByKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGJucEFkZFRvO1xcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAoYSwgcikge1xcbiAgICAgICAgdmFyIGkgPSAwO1xcbiAgICAgICAgdmFyIGMgPSAwO1xcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XFxuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcXG4gICAgICAgICAgICBjICs9IHRoaXNbaV0gKyBhW2ldO1xcbiAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xcbiAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XFxuICAgICAgICAgICAgYyArPSBhLnM7XFxuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcXG4gICAgICAgICAgICAgICAgYyArPSB0aGlzW2ldO1xcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcXG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYyArPSB0aGlzLnM7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBjICs9IHRoaXMucztcXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEudCkge1xcbiAgICAgICAgICAgICAgICBjICs9IGFbaV07XFxuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjICs9IGEucztcXG4gICAgICAgIH1cXG4gICAgICAgIHIucyA9IChjIDwgMCkgPyAtMSA6IDA7XFxuICAgICAgICBpZiAoYyA+IDApIHtcXG4gICAgICAgICAgICByW2krK10gPSBjO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoYyA8IC0xKSB7XFxuICAgICAgICAgICAgcltpKytdID0gdGhpcy5EViArIGM7XFxuICAgICAgICB9XFxuICAgICAgICByLnQgPSBpO1xcbiAgICAgICAgci5jbGFtcCgpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XFxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsIG4gLSAxLCB0aGlzLCAwLCAwLCB0aGlzLnQpO1xcbiAgICAgICAgKyt0aGlzLnQ7XFxuICAgICAgICB0aGlzLmNsYW1wKCk7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0O1xcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRBZGRPZmZzZXQgPSBmdW5jdGlvbiAobiwgdykge1xcbiAgICAgICAgaWYgKG4gPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHdoaWxlICh0aGlzLnQgPD0gdykge1xcbiAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXNbd10gKz0gbjtcXG4gICAgICAgIHdoaWxlICh0aGlzW3ddID49IHRoaXMuRFYpIHtcXG4gICAgICAgICAgICB0aGlzW3ddIC09IHRoaXMuRFY7XFxuICAgICAgICAgICAgaWYgKCsrdyA+PSB0aGlzLnQpIHtcXG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICArK3RoaXNbd107XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXFxcInRoaXMgKiBhXFxcIiwgYS50IDw9IG5cXG4gICAgLy8gXFxcInRoaXNcXFwiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gZnVuY3Rpb24gKGEsIG4sIHIpIHtcXG4gICAgICAgIHZhciBpID0gTWF0aC5taW4odGhpcy50ICsgYS50LCBuKTtcXG4gICAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcXG4gICAgICAgIHIudCA9IGk7XFxuICAgICAgICB3aGlsZSAoaSA+IDApIHtcXG4gICAgICAgICAgICByWy0taV0gPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgaiA9IHIudCAtIHRoaXMudDsgaSA8IGo7ICsraSkge1xcbiAgICAgICAgICAgIHJbaSArIHRoaXMudF0gPSB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIHRoaXMudCk7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkge1xcbiAgICAgICAgICAgIHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgbiAtIGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgci5jbGFtcCgpO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG87XFxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBcXFwidGhpcyAqIGFcXFwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcXG4gICAgLy8gXFxcInRoaXNcXFwiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gZnVuY3Rpb24gKGEsIG4sIHIpIHtcXG4gICAgICAgIC0tbjtcXG4gICAgICAgIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gbjtcXG4gICAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xcbiAgICAgICAgICAgIHJbaV0gPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgobiAtIHRoaXMudCwgMCk7IGkgPCBhLnQ7ICsraSkge1xcbiAgICAgICAgICAgIHJbdGhpcy50ICsgaSAtIG5dID0gdGhpcy5hbShuIC0gaSwgYVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgci5jbGFtcCgpO1xcbiAgICAgICAgci5kclNoaWZ0VG8oMSwgcik7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICBpZiAobiA8PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZCA9IHRoaXMuRFYgJSBuO1xcbiAgICAgICAgdmFyIHIgPSAodGhpcy5zIDwgMCkgPyBuIC0gMSA6IDA7XFxuICAgICAgICBpZiAodGhpcy50ID4gMCkge1xcbiAgICAgICAgICAgIGlmIChkID09IDApIHtcXG4gICAgICAgICAgICAgICAgciA9IHRoaXNbMF0gJSBuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgICAgICAgICByID0gKGQgKiByICsgdGhpc1tpXSkgJSBuO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XFxuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgIHZhciBuMSA9IHRoaXMuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xcbiAgICAgICAgdmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKTtcXG4gICAgICAgIGlmIChrIDw9IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XFxuICAgICAgICB0ID0gKHQgKyAxKSA+PiAxO1xcbiAgICAgICAgaWYgKHQgPiBsb3dwcmltZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgdCA9IGxvd3ByaW1lcy5sZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgYSA9IG5iaSgpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcXG4gICAgICAgICAgICAvLyBQaWNrIGJhc2VzIGF0IHJhbmRvbSwgaW5zdGVhZCBvZiBzdGFydGluZyBhdCAyXFxuICAgICAgICAgICAgYS5mcm9tSW50KGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsb3dwcmltZXMubGVuZ3RoKV0pO1xcbiAgICAgICAgICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcyk7XFxuICAgICAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XFxuICAgICAgICAgICAgICAgIHZhciBqID0gMTtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHkgPSB5Lm1vZFBvd0ludCgyLCB0aGlzKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoeS5jb21wYXJlVG8objEpICE9IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9O1xcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBiblNxdWFyZTtcXG4gICAgLy8gKHB1YmxpYykgdGhpc14yXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciByID0gbmJpKCk7XFxuICAgICAgICB0aGlzLnNxdWFyZVRvKHIpO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIC8vI3JlZ2lvbiBBU1lOQ1xcbiAgICAvLyBQdWJsaWMgQVBJIG1ldGhvZFxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2RhID0gZnVuY3Rpb24gKGEsIGNhbGxiYWNrKSB7XFxuICAgICAgICB2YXIgeCA9ICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzLmNsb25lKCk7XFxuICAgICAgICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKCk7XFxuICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XFxuICAgICAgICAgICAgdmFyIHQgPSB4O1xcbiAgICAgICAgICAgIHggPSB5O1xcbiAgICAgICAgICAgIHkgPSB0O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpO1xcbiAgICAgICAgdmFyIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xcbiAgICAgICAgaWYgKGcgPCAwKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2soeCk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGkgPCBnKSB7XFxuICAgICAgICAgICAgZyA9IGk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZyA+IDApIHtcXG4gICAgICAgICAgICB4LnJTaGlmdFRvKGcsIHgpO1xcbiAgICAgICAgICAgIHkuclNoaWZ0VG8oZywgeSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBXb3JraG9yc2Ugb2YgdGhlIGFsZ29yaXRobSwgZ2V0cyBjYWxsZWQgMjAwIC0gODAwIHRpbWVzIHBlciA1MTIgYml0IGtleWdlbi5cXG4gICAgICAgIHZhciBnY2RhMSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcXG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XFxuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XFxuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oMSwgeCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB5LnN1YlRvKHgsIHkpO1xcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKDEsIHkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoISh4LnNpZ251bSgpID4gMCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGcgPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICB5LmxTaGlmdFRvKGcsIHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayh5KTsgfSwgMCk7IC8vIGVzY2FwZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChnY2RhMSwgMCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHNldFRpbWVvdXQoZ2NkYTEsIDEwKTtcXG4gICAgfTtcXG4gICAgLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXJBc3luYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBjYWxsYmFjaykge1xcbiAgICAgICAgaWYgKFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBiKSB7XFxuICAgICAgICAgICAgaWYgKGEgPCAyKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbUludCgxKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLCBjKTtcXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRlc3RCaXQoYSAtIDEpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLm9wX29yLCB0aGlzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0V2ZW4oKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDEsIDApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHZhciBibnBfMSA9IHRoaXM7XFxuICAgICAgICAgICAgICAgIHZhciBibnBmbjFfMSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJucF8xLmRBZGRPZmZzZXQoMiwgMCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm5wXzEuYml0TGVuZ3RoKCkgPiBhKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYm5wXzEuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgYm5wXzEpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJucF8xLmlzUHJvYmFibGVQcmltZShiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjaygpOyB9LCAwKTsgLy8gZXNjYXBlXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGJucGZuMV8xLCAwKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChibnBmbjFfMSwgMCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdmFyIHggPSBbXTtcXG4gICAgICAgICAgICB2YXIgdCA9IGEgJiA3O1xcbiAgICAgICAgICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxO1xcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xcbiAgICAgICAgICAgIGlmICh0ID4gMCkge1xcbiAgICAgICAgICAgICAgICB4WzBdICY9ICgoMSA8PCB0KSAtIDEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgeFswXSA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LCAyNTYpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICByZXR1cm4gQmlnSW50ZWdlcjtcXG59KCkpO1xcblxcbi8vI3JlZ2lvbiBSRURVQ0VSU1xcbi8vI3JlZ2lvbiBOdWxsRXhwXFxudmFyIE51bGxFeHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIE51bGxFeHAoKSB7XFxuICAgIH1cXG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3A7XFxuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xcbiAgICAgICAgcmV0dXJuIHg7XFxuICAgIH07XFxuICAgIC8vIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XFxuICAgIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICByZXR1cm4geDtcXG4gICAgfTtcXG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG87XFxuICAgIE51bGxFeHAucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcXG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcXG4gICAgfTtcXG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XFxuICAgIE51bGxFeHAucHJvdG90eXBlLnNxclRvID0gZnVuY3Rpb24gKHgsIHIpIHtcXG4gICAgICAgIHguc3F1YXJlVG8ocik7XFxuICAgIH07XFxuICAgIHJldHVybiBOdWxsRXhwO1xcbn0oKSk7XFxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXFxcImNsYXNzaWNcXFwiIGFsZ29yaXRobVxcbnZhciBDbGFzc2ljID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBDbGFzc2ljKG0pIHtcXG4gICAgICAgIHRoaXMubSA9IG07XFxuICAgIH1cXG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0O1xcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIGlmICh4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIHg7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XFxuICAgIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICByZXR1cm4geDtcXG4gICAgfTtcXG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcXG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIHguZGl2UmVtVG8odGhpcy5tLCBudWxsLCB4KTtcXG4gICAgfTtcXG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XFxuICAgIENsYXNzaWMucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gKHgsIHksIHIpIHtcXG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcXG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xcbiAgICB9O1xcbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcXG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcXG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gQ2xhc3NpYztcXG59KCkpO1xcbi8vI2VuZHJlZ2lvblxcbi8vI3JlZ2lvbiBNb250Z29tZXJ5XFxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cXG52YXIgTW9udGdvbWVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XFxuICAgICAgICB0aGlzLm0gPSBtO1xcbiAgICAgICAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKTtcXG4gICAgICAgIHRoaXMubXBsID0gdGhpcy5tcCAmIDB4N2ZmZjtcXG4gICAgICAgIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNTtcXG4gICAgICAgIHRoaXMudW0gPSAoMSA8PCAobS5EQiAtIDE1KSkgLSAxO1xcbiAgICAgICAgdGhpcy5tdDIgPSAyICogbS50O1xcbiAgICB9XFxuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcXG4gICAgLy8geFIgbW9kIG1cXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQsIHIpO1xcbiAgICAgICAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpO1xcbiAgICAgICAgaWYgKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHtcXG4gICAgICAgICAgICB0aGlzLm0uc3ViVG8ociwgcik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcjtcXG4gICAgfTtcXG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcXG4gICAgLy8geC9SIG1vZCBtXFxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICB2YXIgciA9IG5iaSgpO1xcbiAgICAgICAgeC5jb3B5VG8ocik7XFxuICAgICAgICB0aGlzLnJlZHVjZShyKTtcXG4gICAgICAgIHJldHVybiByO1xcbiAgICB9O1xcbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlO1xcbiAgICAvLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXFxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICB3aGlsZSAoeC50IDw9IHRoaXMubXQyKSB7XFxuICAgICAgICAgICAgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXFxuICAgICAgICAgICAgeFt4LnQrK10gPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XFxuICAgICAgICAgICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXFxuICAgICAgICAgICAgdmFyIGogPSB4W2ldICYgMHg3ZmZmO1xcbiAgICAgICAgICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETTtcXG4gICAgICAgICAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcXG4gICAgICAgICAgICBqID0gaSArIHRoaXMubS50O1xcbiAgICAgICAgICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udCk7XFxuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGNhcnJ5XFxuICAgICAgICAgICAgd2hpbGUgKHhbal0gPj0geC5EVikge1xcbiAgICAgICAgICAgICAgICB4W2pdIC09IHguRFY7XFxuICAgICAgICAgICAgICAgIHhbKytqXSsrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHguY2xhbXAoKTtcXG4gICAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50LCB4KTtcXG4gICAgICAgIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcXG4gICAgICAgICAgICB4LnN1YlRvKHRoaXMubSwgeCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xcbiAgICAvLyByID0gXFxcInh5L1IgbW9kIG1cXFwiOyB4LHkgIT0gclxcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XFxuICAgICAgICB4Lm11bHRpcGx5VG8oeSwgcik7XFxuICAgICAgICB0aGlzLnJlZHVjZShyKTtcXG4gICAgfTtcXG4gICAgLy8gTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XFxuICAgIC8vIHIgPSBcXFwieF4yL1IgbW9kIG1cXFwiOyB4ICE9IHJcXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcXG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gTW9udGdvbWVyeTtcXG59KCkpO1xcbi8vI2VuZHJlZ2lvbiBNb250Z29tZXJ5XFxuLy8jcmVnaW9uIEJhcnJldHRcXG4vLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXFxudmFyIEJhcnJldHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xcbiAgICAgICAgdGhpcy5tID0gbTtcXG4gICAgICAgIC8vIHNldHVwIEJhcnJldHRcXG4gICAgICAgIHRoaXMucjIgPSBuYmkoKTtcXG4gICAgICAgIHRoaXMucTMgPSBuYmkoKTtcXG4gICAgICAgIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyICogbS50LCB0aGlzLnIyKTtcXG4gICAgICAgIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcXG4gICAgfVxcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XFxuICAgIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xcbiAgICAgICAgaWYgKHgucyA8IDAgfHwgeC50ID4gMiAqIHRoaXMubS50KSB7XFxuICAgICAgICAgICAgcmV0dXJuIHgubW9kKHRoaXMubSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkge1xcbiAgICAgICAgICAgIHJldHVybiB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgICAgICAgICB4LmNvcHlUbyhyKTtcXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShyKTtcXG4gICAgICAgICAgICByZXR1cm4gcjtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcXG4gICAgQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIHJldHVybiB4O1xcbiAgICB9O1xcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlO1xcbiAgICAvLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCkge1xcbiAgICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQgLSAxLCB0aGlzLnIyKTtcXG4gICAgICAgIGlmICh4LnQgPiB0aGlzLm0udCArIDEpIHtcXG4gICAgICAgICAgICB4LnQgPSB0aGlzLm0udCArIDE7XFxuICAgICAgICAgICAgeC5jbGFtcCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMiwgdGhpcy5tLnQgKyAxLCB0aGlzLnEzKTtcXG4gICAgICAgIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMywgdGhpcy5tLnQgKyAxLCB0aGlzLnIyKTtcXG4gICAgICAgIHdoaWxlICh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHtcXG4gICAgICAgICAgICB4LmRBZGRPZmZzZXQoMSwgdGhpcy5tLnQgKyAxKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHguc3ViVG8odGhpcy5yMiwgeCk7XFxuICAgICAgICB3aGlsZSAoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XFxuICAgICAgICAgICAgeC5zdWJUbyh0aGlzLm0sIHgpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcXG4gICAgLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcXG4gICAgQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xcbiAgICAgICAgeC5tdWx0aXBseVRvKHksIHIpO1xcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XFxuICAgIH07XFxuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xcbiAgICAvLyByID0geF4yIG1vZCBtOyB4ICE9IHJcXG4gICAgQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xcbiAgICAgICAgeC5zcXVhcmVUbyhyKTtcXG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gQmFycmV0dDtcXG59KCkpO1xcbi8vI2VuZHJlZ2lvblxcbi8vI2VuZHJlZ2lvbiBSRURVQ0VSU1xcbi8vIHJldHVybiBuZXcsIHVuc2V0IEJpZ0ludGVnZXJcXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxcbmZ1bmN0aW9uIHBhcnNlQmlnSW50KHN0ciwgcikge1xcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3RyLCByKTtcXG59XFxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXFxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXFxcInVuZGVmaW5lZFxcXCI7XFxuaWYgKGluQnJvd3NlciAmJiBqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcXFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXFxcIikpIHtcXG4gICAgLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXFxuICAgIC8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXFxuICAgIC8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBmdW5jdGlvbiBhbTIoaSwgeCwgdywgaiwgYywgbikge1xcbiAgICAgICAgdmFyIHhsID0geCAmIDB4N2ZmZjtcXG4gICAgICAgIHZhciB4aCA9IHggPj4gMTU7XFxuICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDdmZmY7XFxuICAgICAgICAgICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTU7XFxuICAgICAgICAgICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGw7XFxuICAgICAgICAgICAgbCA9IHhsICogbCArICgobSAmIDB4N2ZmZikgPDwgMTUpICsgd1tqXSArIChjICYgMHgzZmZmZmZmZik7XFxuICAgICAgICAgICAgYyA9IChsID4+PiAzMCkgKyAobSA+Pj4gMTUpICsgeGggKiBoICsgKGMgPj4+IDMwKTtcXG4gICAgICAgICAgICB3W2orK10gPSBsICYgMHgzZmZmZmZmZjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjO1xcbiAgICB9O1xcbiAgICBkYml0cyA9IDMwO1xcbn1cXG5lbHNlIGlmIChpbkJyb3dzZXIgJiYgal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgIT0gXFxcIk5ldHNjYXBlXFxcIikpIHtcXG4gICAgLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxcbiAgICAvLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxcbiAgICAvLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXFxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gZnVuY3Rpb24gYW0xKGksIHgsIHcsIGosIGMsIG4pIHtcXG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xcbiAgICAgICAgICAgIHZhciB2ID0geCAqIHRoaXNbaSsrXSArIHdbal0gKyBjO1xcbiAgICAgICAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyAweDQwMDAwMDApO1xcbiAgICAgICAgICAgIHdbaisrXSA9IHYgJiAweDNmZmZmZmY7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYztcXG4gICAgfTtcXG4gICAgZGJpdHMgPSAyNjtcXG59XFxuZWxzZSB7IC8vIE1vemlsbGEvTmV0c2NhcGUgc2VlbXMgdG8gcHJlZmVyIGFtM1xcbiAgICAvLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcXG4gICAgLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XFxuICAgICAgICB2YXIgeGwgPSB4ICYgMHgzZmZmO1xcbiAgICAgICAgdmFyIHhoID0geCA+PiAxNDtcXG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xcbiAgICAgICAgICAgIHZhciBsID0gdGhpc1tpXSAmIDB4M2ZmZjtcXG4gICAgICAgICAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNDtcXG4gICAgICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcXG4gICAgICAgICAgICBsID0geGwgKiBsICsgKChtICYgMHgzZmZmKSA8PCAxNCkgKyB3W2pdICsgYztcXG4gICAgICAgICAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoO1xcbiAgICAgICAgICAgIHdbaisrXSA9IGwgJiAweGZmZmZmZmY7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gYztcXG4gICAgfTtcXG4gICAgZGJpdHMgPSAyODtcXG59XFxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0cztcXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMSA8PCBkYml0cykgLSAxKTtcXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxIDw8IGRiaXRzKTtcXG52YXIgQklfRlAgPSA1MjtcXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsIEJJX0ZQKTtcXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQIC0gZGJpdHM7XFxuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUDtcXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xcbnZhciBCSV9SQyA9IFtdO1xcbnZhciBycjtcXG52YXIgdnY7XFxucnIgPSBcXFwiMFxcXCIuY2hhckNvZGVBdCgwKTtcXG5mb3IgKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikge1xcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xcbn1cXG5yciA9IFxcXCJhXFxcIi5jaGFyQ29kZUF0KDApO1xcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xcbn1cXG5yciA9IFxcXCJBXFxcIi5jaGFyQ29kZUF0KDApO1xcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikge1xcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xcbn1cXG5mdW5jdGlvbiBpbnRBdChzLCBpKSB7XFxuICAgIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcXG4gICAgcmV0dXJuIChjID09IG51bGwpID8gLTEgOiBjO1xcbn1cXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXFxuZnVuY3Rpb24gbmJ2KGkpIHtcXG4gICAgdmFyIHIgPSBuYmkoKTtcXG4gICAgci5mcm9tSW50KGkpO1xcbiAgICByZXR1cm4gcjtcXG59XFxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcXG5mdW5jdGlvbiBuYml0cyh4KSB7XFxuICAgIHZhciByID0gMTtcXG4gICAgdmFyIHQ7XFxuICAgIGlmICgodCA9IHggPj4+IDE2KSAhPSAwKSB7XFxuICAgICAgICB4ID0gdDtcXG4gICAgICAgIHIgKz0gMTY7XFxuICAgIH1cXG4gICAgaWYgKCh0ID0geCA+PiA4KSAhPSAwKSB7XFxuICAgICAgICB4ID0gdDtcXG4gICAgICAgIHIgKz0gODtcXG4gICAgfVxcbiAgICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcXG4gICAgICAgIHggPSB0O1xcbiAgICAgICAgciArPSA0O1xcbiAgICB9XFxuICAgIGlmICgodCA9IHggPj4gMikgIT0gMCkge1xcbiAgICAgICAgeCA9IHQ7XFxuICAgICAgICByICs9IDI7XFxuICAgIH1cXG4gICAgaWYgKCh0ID0geCA+PiAxKSAhPSAwKSB7XFxuICAgICAgICB4ID0gdDtcXG4gICAgICAgIHIgKz0gMTtcXG4gICAgfVxcbiAgICByZXR1cm4gcjtcXG59XFxuLy8gXFxcImNvbnN0YW50c1xcXCJcXG5CaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMCk7XFxuQmlnSW50ZWdlci5PTkUgPSBuYnYoMSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9qc2JuL2pzYm4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2xpYi9saWIvanNibi9wcm5nNC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9saWIvanNibi9wcm5nNC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiQXJjZm91clxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEFyY2ZvdXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInBybmdfbmV3c3RhdGVcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcm5nX25ld3N0YXRlKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJybmdfcHNpemVcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBybmdfcHNpemUpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLy8gcHJuZzQuanMgLSB1c2VzIEFyY2ZvdXIgYXMgYSBQUk5HXFxudmFyIEFyY2ZvdXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIEFyY2ZvdXIoKSB7XFxuICAgICAgICB0aGlzLmkgPSAwO1xcbiAgICAgICAgdGhpcy5qID0gMDtcXG4gICAgICAgIHRoaXMuUyA9IFtdO1xcbiAgICB9XFxuICAgIC8vIEFyY2ZvdXIucHJvdG90eXBlLmluaXQgPSBBUkM0aW5pdDtcXG4gICAgLy8gSW5pdGlhbGl6ZSBhcmNmb3VyIGNvbnRleHQgZnJvbSBrZXksIGFuIGFycmF5IG9mIGludHMsIGVhY2ggZnJvbSBbMC4uMjU1XVxcbiAgICBBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgdmFyIGk7XFxuICAgICAgICB2YXIgajtcXG4gICAgICAgIHZhciB0O1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgKytpKSB7XFxuICAgICAgICAgICAgdGhpcy5TW2ldID0gaTtcXG4gICAgICAgIH1cXG4gICAgICAgIGogPSAwO1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgKytpKSB7XFxuICAgICAgICAgICAgaiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XFxuICAgICAgICAgICAgdCA9IHRoaXMuU1tpXTtcXG4gICAgICAgICAgICB0aGlzLlNbaV0gPSB0aGlzLlNbal07XFxuICAgICAgICAgICAgdGhpcy5TW2pdID0gdDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuaSA9IDA7XFxuICAgICAgICB0aGlzLmogPSAwO1xcbiAgICB9O1xcbiAgICAvLyBBcmNmb3VyLnByb3RvdHlwZS5uZXh0ID0gQVJDNG5leHQ7XFxuICAgIEFyY2ZvdXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdDtcXG4gICAgICAgIHRoaXMuaSA9ICh0aGlzLmkgKyAxKSAmIDI1NTtcXG4gICAgICAgIHRoaXMuaiA9ICh0aGlzLmogKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTU7XFxuICAgICAgICB0ID0gdGhpcy5TW3RoaXMuaV07XFxuICAgICAgICB0aGlzLlNbdGhpcy5pXSA9IHRoaXMuU1t0aGlzLmpdO1xcbiAgICAgICAgdGhpcy5TW3RoaXMual0gPSB0O1xcbiAgICAgICAgcmV0dXJuIHRoaXMuU1sodCArIHRoaXMuU1t0aGlzLmldKSAmIDI1NV07XFxuICAgIH07XFxuICAgIHJldHVybiBBcmNmb3VyO1xcbn0oKSk7XFxuXFxuLy8gUGx1ZyBpbiB5b3VyIFJORyBjb25zdHJ1Y3RvciBoZXJlXFxuZnVuY3Rpb24gcHJuZ19uZXdzdGF0ZSgpIHtcXG4gICAgcmV0dXJuIG5ldyBBcmNmb3VyKCk7XFxufVxcbi8vIFBvb2wgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCBhbmQgZ3JlYXRlciB0aGFuIDMyLlxcbi8vIEFuIGFycmF5IG9mIGJ5dGVzIHRoZSBzaXplIG9mIHRoZSBwb29sIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKVxcbnZhciBybmdfcHNpemUgPSAyNTY7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9qc2JuL3Bybmc0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9saWIvbGliL2pzYm4vcm5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9saWIvanNibi9ybmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJTZWN1cmVSYW5kb21cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZWN1cmVSYW5kb20pXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcm5nNF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm5nNCAqLyBcXFwiLi9saWIvbGliL2pzYm4vcHJuZzQuanNcXFwiKTtcXG4vLyBSYW5kb20gbnVtYmVyIGdlbmVyYXRvciAtIHJlcXVpcmVzIGEgUFJORyBiYWNrZW5kLCBlLmcuIHBybmc0LmpzXFxuXFxudmFyIHJuZ19zdGF0ZTtcXG52YXIgcm5nX3Bvb2wgPSBudWxsO1xcbnZhciBybmdfcHB0cjtcXG4vLyBJbml0aWFsaXplIHRoZSBwb29sIHdpdGgganVuayBpZiBuZWVkZWQuXFxuaWYgKHJuZ19wb29sID09IG51bGwpIHtcXG4gICAgcm5nX3Bvb2wgPSBbXTtcXG4gICAgcm5nX3BwdHIgPSAwO1xcbiAgICB2YXIgdCA9IHZvaWQgMDtcXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcXG4gICAgICAgIC8vIEV4dHJhY3QgZW50cm9weSAoMjA0OCBiaXRzKSBmcm9tIFJORyBpZiBhdmFpbGFibGVcXG4gICAgICAgIHZhciB6ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XFxuICAgICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh6KTtcXG4gICAgICAgIGZvciAodCA9IDA7IHQgPCB6Lmxlbmd0aDsgKyt0KSB7XFxuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSB6W3RdICYgMjU1O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8vIFVzZSBtb3VzZSBldmVudHMgZm9yIGVudHJvcHksIGlmIHdlIGRvIG5vdCBoYXZlIGVub3VnaCBlbnRyb3B5IGJ5IHRoZSB0aW1lXFxuICAgIC8vIHdlIG5lZWQgaXQsIGVudHJvcHkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgTWF0aC5yYW5kb20uXFxuICAgIHZhciBjb3VudCA9IDA7XFxuICAgIHZhciBvbk1vdXNlTW92ZUxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoZXYpIHtcXG4gICAgICAgIGNvdW50ID0gY291bnQgfHwgMDtcXG4gICAgICAgIGlmIChjb3VudCA+PSAyNTYgfHwgcm5nX3BwdHIgPj0gX3Bybmc0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucm5nX3BzaXplKSB7XFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XFxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmRldGFjaEV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudChcXFwib25tb3VzZW1vdmVcXFwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkaW5hdGVzID0gZXYueCArIGV2Lnk7XFxuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSBtb3VzZUNvb3JkaW5hdGVzICYgMjU1O1xcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XFxuICAgICAgICB9XFxuICAgICAgICBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBGaXJlZm94IHdpbGwgZGVueSBwZXJtaXNzaW9uIHRvIGFjY2VzcyBldmVudCBwcm9wZXJ0aWVzIGZvciBzb21lIHJlYXNvbi4gSWdub3JlLlxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCkge1xcbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudChcXFwib25tb3VzZW1vdmVcXFwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbmZ1bmN0aW9uIHJuZ19nZXRfYnl0ZSgpIHtcXG4gICAgaWYgKHJuZ19zdGF0ZSA9PSBudWxsKSB7XFxuICAgICAgICBybmdfc3RhdGUgPSAoMCxfcHJuZzRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wcm5nX25ld3N0YXRlKSgpO1xcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbWF5IG5vdCBoYXZlIGNvbGxlY3RlZCBlbm91Z2ggZW50cm9weS4gIElmIG5vdCwgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tXFxuICAgICAgICB3aGlsZSAocm5nX3BwdHIgPCBfcHJuZzRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5ybmdfcHNpemUpIHtcXG4gICAgICAgICAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcig2NTUzNiAqIE1hdGgucmFuZG9tKCkpO1xcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gcmFuZG9tICYgMjU1O1xcbiAgICAgICAgfVxcbiAgICAgICAgcm5nX3N0YXRlLmluaXQocm5nX3Bvb2wpO1xcbiAgICAgICAgZm9yIChybmdfcHB0ciA9IDA7IHJuZ19wcHRyIDwgcm5nX3Bvb2wubGVuZ3RoOyArK3JuZ19wcHRyKSB7XFxuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHJdID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJuZ19wcHRyID0gMDtcXG4gICAgfVxcbiAgICAvLyBUT0RPOiBhbGxvdyByZXNlZWRpbmcgYWZ0ZXIgZmlyc3QgcmVxdWVzdFxcbiAgICByZXR1cm4gcm5nX3N0YXRlLm5leHQoKTtcXG59XFxudmFyIFNlY3VyZVJhbmRvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gU2VjdXJlUmFuZG9tKCkge1xcbiAgICB9XFxuICAgIFNlY3VyZVJhbmRvbS5wcm90b3R5cGUubmV4dEJ5dGVzID0gZnVuY3Rpb24gKGJhKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgYmFbaV0gPSBybmdfZ2V0X2J5dGUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV0dXJuIFNlY3VyZVJhbmRvbTtcXG59KCkpO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0pTRW5jcnlwdC8uL2xpYi9saWIvanNibi9ybmcuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2xpYi9saWIvanNibi9yc2EuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbGliL2xpYi9qc2JuL3JzYS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlJTQUtleVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFJTQUtleSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanNibiAqLyBcXFwiLi9saWIvbGliL2pzYm4vanNibi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcm5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JuZyAqLyBcXFwiLi9saWIvbGliL2pzYm4vcm5nLmpzXFxcIik7XFxuLy8gRGVwZW5kcyBvbiBqc2JuLmpzIGFuZCBybmcuanNcXG4vLyBWZXJzaW9uIDEuMTogc3VwcG9ydCB1dGYtOCBlbmNvZGluZyBpbiBwa2NzMXBhZDJcXG4vLyBjb252ZXJ0IGEgKGhleCkgc3RyaW5nIHRvIGEgYmlnbnVtIG9iamVjdFxcblxcblxcbi8vIGZ1bmN0aW9uIGxpbmVicmsocyxuKSB7XFxuLy8gICB2YXIgcmV0ID0gXFxcIlxcXCI7XFxuLy8gICB2YXIgaSA9IDA7XFxuLy8gICB3aGlsZShpICsgbiA8IHMubGVuZ3RoKSB7XFxuLy8gICAgIHJldCArPSBzLnN1YnN0cmluZyhpLGkrbikgKyBcXFwiXFxcXG5cXFwiO1xcbi8vICAgICBpICs9IG47XFxuLy8gICB9XFxuLy8gICByZXR1cm4gcmV0ICsgcy5zdWJzdHJpbmcoaSxzLmxlbmd0aCk7XFxuLy8gfVxcbi8vIGZ1bmN0aW9uIGJ5dGUySGV4KGIpIHtcXG4vLyAgIGlmKGIgPCAweDEwKVxcbi8vICAgICByZXR1cm4gXFxcIjBcXFwiICsgYi50b1N0cmluZygxNik7XFxuLy8gICBlbHNlXFxuLy8gICAgIHJldHVybiBiLnRvU3RyaW5nKDE2KTtcXG4vLyB9XFxuZnVuY3Rpb24gcGtjczFwYWQxKHMsIG4pIHtcXG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDIyKSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJNZXNzYWdlIHRvbyBsb25nIGZvciBSU0FcXFwiKTtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHZhciBsZW4gPSBuIC0gcy5sZW5ndGggLSA2O1xcbiAgICB2YXIgZmlsbGVyID0gXFxcIlxcXCI7XFxuICAgIGZvciAodmFyIGYgPSAwOyBmIDwgbGVuOyBmICs9IDIpIHtcXG4gICAgICAgIGZpbGxlciArPSBcXFwiZmZcXFwiO1xcbiAgICB9XFxuICAgIHZhciBtID0gXFxcIjAwMDFcXFwiICsgZmlsbGVyICsgXFxcIjAwXFxcIiArIHM7XFxuICAgIHJldHVybiAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShtLCAxNik7XFxufVxcbi8vIFBLQ1MjMSAodHlwZSAyLCByYW5kb20pIHBhZCBpbnB1dCBzdHJpbmcgcyB0byBuIGJ5dGVzLCBhbmQgcmV0dXJuIGEgYmlnaW50XFxuZnVuY3Rpb24gcGtjczFwYWQyKHMsIG4pIHtcXG4gICAgaWYgKG4gPCBzLmxlbmd0aCArIDExKSB7IC8vIFRPRE86IGZpeCBmb3IgdXRmLThcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXFxcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgdmFyIGJhID0gW107XFxuICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xcbiAgICB3aGlsZSAoaSA+PSAwICYmIG4gPiAwKSB7XFxuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpLS0pO1xcbiAgICAgICAgaWYgKGMgPCAxMjgpIHsgLy8gZW5jb2RlIHVzaW5nIHV0Zi04XFxuICAgICAgICAgICAgYmFbLS1uXSA9IGM7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICgoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyAmIDYzKSB8IDEyODtcXG4gICAgICAgICAgICBiYVstLW5dID0gKGMgPj4gNikgfCAxOTI7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBiYVstLW5dID0gKGMgJiA2MykgfCAxMjg7XFxuICAgICAgICAgICAgYmFbLS1uXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcXG4gICAgICAgICAgICBiYVstLW5dID0gKGMgPj4gMTIpIHwgMjI0O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGJhWy0tbl0gPSAwO1xcbiAgICB2YXIgcm5nID0gbmV3IF9ybmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5TZWN1cmVSYW5kb20oKTtcXG4gICAgdmFyIHggPSBbXTtcXG4gICAgd2hpbGUgKG4gPiAyKSB7IC8vIHJhbmRvbSBub24temVybyBwYWRcXG4gICAgICAgIHhbMF0gPSAwO1xcbiAgICAgICAgd2hpbGUgKHhbMF0gPT0gMCkge1xcbiAgICAgICAgICAgIHJuZy5uZXh0Qnl0ZXMoeCk7XFxuICAgICAgICB9XFxuICAgICAgICBiYVstLW5dID0geFswXTtcXG4gICAgfVxcbiAgICBiYVstLW5dID0gMjtcXG4gICAgYmFbLS1uXSA9IDA7XFxuICAgIHJldHVybiBuZXcgX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyKGJhKTtcXG59XFxuLy8gXFxcImVtcHR5XFxcIiBSU0Ega2V5IGNvbnN0cnVjdG9yXFxudmFyIFJTQUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gUlNBS2V5KCkge1xcbiAgICAgICAgdGhpcy5uID0gbnVsbDtcXG4gICAgICAgIHRoaXMuZSA9IDA7XFxuICAgICAgICB0aGlzLmQgPSBudWxsO1xcbiAgICAgICAgdGhpcy5wID0gbnVsbDtcXG4gICAgICAgIHRoaXMucSA9IG51bGw7XFxuICAgICAgICB0aGlzLmRtcDEgPSBudWxsO1xcbiAgICAgICAgdGhpcy5kbXExID0gbnVsbDtcXG4gICAgICAgIHRoaXMuY29lZmYgPSBudWxsO1xcbiAgICB9XFxuICAgIC8vI3JlZ2lvbiBQUk9URUNURURcXG4gICAgLy8gcHJvdGVjdGVkXFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9QdWJsaWMgPSBSU0FEb1B1YmxpYztcXG4gICAgLy8gUGVyZm9ybSByYXcgcHVibGljIG9wZXJhdGlvbiBvbiBcXFwieFxcXCI6IHJldHVybiB4XmUgKG1vZCBuKVxcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHVibGljID0gZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIHJldHVybiB4Lm1vZFBvd0ludCh0aGlzLmUsIHRoaXMubik7XFxuICAgIH07XFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuZG9Qcml2YXRlID0gUlNBRG9Qcml2YXRlO1xcbiAgICAvLyBQZXJmb3JtIHJhdyBwcml2YXRlIG9wZXJhdGlvbiBvbiBcXFwieFxcXCI6IHJldHVybiB4XmQgKG1vZCBuKVxcbiAgICBSU0FLZXkucHJvdG90eXBlLmRvUHJpdmF0ZSA9IGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICBpZiAodGhpcy5wID09IG51bGwgfHwgdGhpcy5xID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4geC5tb2RQb3codGhpcy5kLCB0aGlzLm4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gVE9ETzogcmUtY2FsY3VsYXRlIGFueSBtaXNzaW5nIENSVCBwYXJhbXNcXG4gICAgICAgIHZhciB4cCA9IHgubW9kKHRoaXMucCkubW9kUG93KHRoaXMuZG1wMSwgdGhpcy5wKTtcXG4gICAgICAgIHZhciB4cSA9IHgubW9kKHRoaXMucSkubW9kUG93KHRoaXMuZG1xMSwgdGhpcy5xKTtcXG4gICAgICAgIHdoaWxlICh4cC5jb21wYXJlVG8oeHEpIDwgMCkge1xcbiAgICAgICAgICAgIHhwID0geHAuYWRkKHRoaXMucCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geHAuc3VidHJhY3QoeHEpLm11bHRpcGx5KHRoaXMuY29lZmYpLm1vZCh0aGlzLnApLm11bHRpcGx5KHRoaXMucSkuYWRkKHhxKTtcXG4gICAgfTtcXG4gICAgLy8jZW5kcmVnaW9uIFBST1RFQ1RFRFxcbiAgICAvLyNyZWdpb24gUFVCTElDXFxuICAgIC8vIFJTQUtleS5wcm90b3R5cGUuc2V0UHVibGljID0gUlNBU2V0UHVibGljO1xcbiAgICAvLyBTZXQgdGhlIHB1YmxpYyBrZXkgZmllbGRzIE4gYW5kIGUgZnJvbSBoZXggc3RyaW5nc1xcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFB1YmxpYyA9IGZ1bmN0aW9uIChOLCBFKSB7XFxuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgdGhpcy5uID0gKDAsX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wYXJzZUJpZ0ludCkoTiwgMTYpO1xcbiAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXFxcIkludmFsaWQgUlNBIHB1YmxpYyBrZXlcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0ID0gUlNBRW5jcnlwdDtcXG4gICAgLy8gUmV0dXJuIHRoZSBQS0NTIzEgUlNBIGVuY3J5cHRpb24gb2YgXFxcInRleHRcXFwiIGFzIGFuIGV2ZW4tbGVuZ3RoIGhleCBzdHJpbmdcXG4gICAgUlNBS2V5LnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24gKHRleHQpIHtcXG4gICAgICAgIHZhciBtYXhMZW5ndGggPSAodGhpcy5uLmJpdExlbmd0aCgpICsgNykgPj4gMztcXG4gICAgICAgIHZhciBtID0gcGtjczFwYWQyKHRleHQsIG1heExlbmd0aCk7XFxuICAgICAgICBpZiAobSA9PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgYyA9IHRoaXMuZG9QdWJsaWMobSk7XFxuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xcbiAgICAgICAgdmFyIGxlbmd0aCA9IGgubGVuZ3RoO1xcbiAgICAgICAgLy8gZml4IHplcm8gYmVmb3JlIHJlc3VsdFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMZW5ndGggKiAyIC0gbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBoID0gXFxcIjBcXFwiICsgaDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBoO1xcbiAgICB9O1xcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGUgPSBSU0FTZXRQcml2YXRlO1xcbiAgICAvLyBTZXQgdGhlIHByaXZhdGUga2V5IGZpZWxkcyBOLCBlLCBhbmQgZCBmcm9tIGhleCBzdHJpbmdzXFxuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIChOLCBFLCBEKSB7XFxuICAgICAgICBpZiAoTiAhPSBudWxsICYmIEUgIT0gbnVsbCAmJiBOLmxlbmd0aCA+IDAgJiYgRS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgdGhpcy5uID0gKDAsX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wYXJzZUJpZ0ludCkoTiwgMTYpO1xcbiAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcXG4gICAgICAgICAgICB0aGlzLmQgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShELCAxNik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJJbnZhbGlkIFJTQSBwcml2YXRlIGtleVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGVFeCA9IFJTQVNldFByaXZhdGVFeDtcXG4gICAgLy8gU2V0IHRoZSBwcml2YXRlIGtleSBmaWVsZHMgTiwgZSwgZCBhbmQgQ1JUIHBhcmFtcyBmcm9tIGhleCBzdHJpbmdzXFxuICAgIFJTQUtleS5wcm90b3R5cGUuc2V0UHJpdmF0ZUV4ID0gZnVuY3Rpb24gKE4sIEUsIEQsIFAsIFEsIERQLCBEUSwgQykge1xcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIHRoaXMubiA9ICgwLF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucGFyc2VCaWdJbnQpKE4sIDE2KTtcXG4gICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChFLCAxNik7XFxuICAgICAgICAgICAgdGhpcy5kID0gKDAsX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wYXJzZUJpZ0ludCkoRCwgMTYpO1xcbiAgICAgICAgICAgIHRoaXMucCA9ICgwLF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucGFyc2VCaWdJbnQpKFAsIDE2KTtcXG4gICAgICAgICAgICB0aGlzLnEgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShRLCAxNik7XFxuICAgICAgICAgICAgdGhpcy5kbXAxID0gKDAsX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5wYXJzZUJpZ0ludCkoRFAsIDE2KTtcXG4gICAgICAgICAgICB0aGlzLmRtcTEgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShEUSwgMTYpO1xcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShDLCAxNik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJJbnZhbGlkIFJTQSBwcml2YXRlIGtleVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gUlNBR2VuZXJhdGU7XFxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBwcml2YXRlIGtleSBCIGJpdHMgbG9uZywgdXNpbmcgcHVibGljIGV4cHQgRVxcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKEIsIEUpIHtcXG4gICAgICAgIHZhciBybmcgPSBuZXcgX3JuZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlNlY3VyZVJhbmRvbSgpO1xcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xcbiAgICAgICAgdmFyIGVlID0gbmV3IF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlcihFLCAxNik7XFxuICAgICAgICBmb3IgKDs7KSB7XFxuICAgICAgICAgICAgZm9yICg7Oykge1xcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBuZXcgX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyKEIgLSBxcywgMSwgcm5nKTtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucC5zdWJ0cmFjdChfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIuT05FKS5nY2QoZWUpLmNvbXBhcmVUbyhfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHRoaXMucC5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKDs7KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucSA9IG5ldyBfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIocXMsIDEsIHJuZyk7XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnEuc3VidHJhY3QoX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSkuZ2NkKGVlKS5jb21wYXJlVG8oX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiB0aGlzLnEuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRoaXMucC5jb21wYXJlVG8odGhpcy5xKSA8PSAwKSB7XFxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5wO1xcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnE7XFxuICAgICAgICAgICAgICAgIHRoaXMucSA9IHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBwMSA9IHRoaXMucC5zdWJ0cmFjdChfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIuT05FKTtcXG4gICAgICAgICAgICB2YXIgcTEgPSB0aGlzLnEuc3VidHJhY3QoX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSk7XFxuICAgICAgICAgICAgdmFyIHBoaSA9IHAxLm11bHRpcGx5KHExKTtcXG4gICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpID09IDApIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5wLm11bHRpcGx5KHRoaXMucSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuZCA9IGVlLm1vZEludmVyc2UocGhpKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kbXAxID0gdGhpcy5kLm1vZChwMSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuZG1xMSA9IHRoaXMuZC5tb2QocTEpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmID0gdGhpcy5xLm1vZEludmVyc2UodGhpcy5wKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRlY3J5cHQgPSBSU0FEZWNyeXB0O1xcbiAgICAvLyBSZXR1cm4gdGhlIFBLQ1MjMSBSU0EgZGVjcnlwdGlvbiBvZiBcXFwiY3RleHRcXFwiLlxcbiAgICAvLyBcXFwiY3RleHRcXFwiIGlzIGFuIGV2ZW4tbGVuZ3RoIGhleCBzdHJpbmcgYW5kIHRoZSBvdXRwdXQgaXMgYSBwbGFpbiBzdHJpbmcuXFxuICAgIFJTQUtleS5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChjdGV4dCkge1xcbiAgICAgICAgdmFyIGMgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShjdGV4dCwgMTYpO1xcbiAgICAgICAgdmFyIG0gPSB0aGlzLmRvUHJpdmF0ZShjKTtcXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwa2NzMXVucGFkMihtLCAodGhpcy5uLmJpdExlbmd0aCgpICsgNykgPj4gMyk7XFxuICAgIH07XFxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBwcml2YXRlIGtleSBCIGJpdHMgbG9uZywgdXNpbmcgcHVibGljIGV4cHQgRVxcbiAgICBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlQXN5bmMgPSBmdW5jdGlvbiAoQiwgRSwgY2FsbGJhY2spIHtcXG4gICAgICAgIHZhciBybmcgPSBuZXcgX3JuZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLlNlY3VyZVJhbmRvbSgpO1xcbiAgICAgICAgdmFyIHFzID0gQiA+PiAxO1xcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xcbiAgICAgICAgdmFyIGVlID0gbmV3IF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlcihFLCAxNik7XFxuICAgICAgICB2YXIgcnNhID0gdGhpcztcXG4gICAgICAgIC8vIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIG5vbi1kZXNjcmlwdCBuYW1lcyBiZWNhdXNlIHRoZXkgd2VyZSBvcmlnaW5hbGx5IGZvcig7OykgbG9vcHMuXFxuICAgICAgICAvLyBJIGRvbid0IGtub3cgYWJvdXQgY3J5cHRvZ3JhcGh5IHRvIGdpdmUgdGhlbSBiZXR0ZXIgbmFtZXMgdGhhbiBsb29wMS00LlxcbiAgICAgICAgdmFyIGxvb3AxID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBsb29wNCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHJzYS5wLmNvbXBhcmVUbyhyc2EucSkgPD0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByc2EucDtcXG4gICAgICAgICAgICAgICAgICAgIHJzYS5wID0gcnNhLnE7XFxuICAgICAgICAgICAgICAgICAgICByc2EucSA9IHQ7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdmFyIHAxID0gcnNhLnAuc3VidHJhY3QoX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSk7XFxuICAgICAgICAgICAgICAgIHZhciBxMSA9IHJzYS5xLnN1YnRyYWN0KF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpO1xcbiAgICAgICAgICAgICAgICB2YXIgcGhpID0gcDEubXVsdGlwbHkocTEpO1xcbiAgICAgICAgICAgICAgICBpZiAocGhpLmdjZChlZSkuY29tcGFyZVRvKF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHJzYS5uID0gcnNhLnAubXVsdGlwbHkocnNhLnEpO1xcbiAgICAgICAgICAgICAgICAgICAgcnNhLmQgPSBlZS5tb2RJbnZlcnNlKHBoaSk7XFxuICAgICAgICAgICAgICAgICAgICByc2EuZG1wMSA9IHJzYS5kLm1vZChwMSk7XFxuICAgICAgICAgICAgICAgICAgICByc2EuZG1xMSA9IHJzYS5kLm1vZChxMSk7XFxuICAgICAgICAgICAgICAgICAgICByc2EuY29lZmYgPSByc2EucS5tb2RJbnZlcnNlKHJzYS5wKTtcXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjaygpOyB9LCAwKTsgLy8gZXNjYXBlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AxLCAwKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIGxvb3AzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByc2EucSA9ICgwLF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubmJpKSgpO1xcbiAgICAgICAgICAgICAgICByc2EucS5mcm9tTnVtYmVyQXN5bmMocXMsIDEsIHJuZywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgcnNhLnEuc3VidHJhY3QoX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSkuZ2NkYShlZSwgZnVuY3Rpb24gKHIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb21wYXJlVG8oX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiByc2EucS5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDQsIDApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wMywgMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIGxvb3AyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByc2EucCA9ICgwLF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ubmJpKSgpO1xcbiAgICAgICAgICAgICAgICByc2EucC5mcm9tTnVtYmVyQXN5bmMoQiAtIHFzLCAxLCBybmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJzYS5wLnN1YnRyYWN0KF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpLmdjZGEoZWUsIGZ1bmN0aW9uIChyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29tcGFyZVRvKF9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpID09IDAgJiYgcnNhLnAuaXNQcm9iYWJsZVByaW1lKDEwKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AzLCAwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHNldFRpbWVvdXQobG9vcDEsIDApO1xcbiAgICB9O1xcbiAgICBSU0FLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAodGV4dCwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSB7XFxuICAgICAgICB2YXIgaGVhZGVyID0gZ2V0RGlnZXN0SGVhZGVyKGRpZ2VzdE5hbWUpO1xcbiAgICAgICAgdmFyIGRpZ2VzdCA9IGhlYWRlciArIGRpZ2VzdE1ldGhvZCh0ZXh0KS50b1N0cmluZygpO1xcbiAgICAgICAgdmFyIG0gPSBwa2NzMXBhZDEoZGlnZXN0LCB0aGlzLm4uYml0TGVuZ3RoKCkgLyA0KTtcXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBjID0gdGhpcy5kb1ByaXZhdGUobSk7XFxuICAgICAgICBpZiAoYyA9PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgaCA9IGMudG9TdHJpbmcoMTYpO1xcbiAgICAgICAgaWYgKChoLmxlbmd0aCAmIDEpID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gaDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiMFxcXCIgKyBoO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBSU0FLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uICh0ZXh0LCBzaWduYXR1cmUsIGRpZ2VzdE1ldGhvZCkge1xcbiAgICAgICAgdmFyIGMgPSAoMCxfanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLnBhcnNlQmlnSW50KShzaWduYXR1cmUsIDE2KTtcXG4gICAgICAgIHZhciBtID0gdGhpcy5kb1B1YmxpYyhjKTtcXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB1bnBhZGRlZCA9IG0udG9TdHJpbmcoMTYpLnJlcGxhY2UoL14xZiswMC8sIFxcXCJcXFwiKTtcXG4gICAgICAgIHZhciBkaWdlc3QgPSByZW1vdmVEaWdlc3RIZWFkZXIodW5wYWRkZWQpO1xcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCA9PSBkaWdlc3RNZXRob2QodGV4dCkudG9TdHJpbmcoKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIFJTQUtleTtcXG59KCkpO1xcblxcbi8vIFVuZG8gUEtDUyMxICh0eXBlIDIsIHJhbmRvbSkgcGFkZGluZyBhbmQsIGlmIHZhbGlkLCByZXR1cm4gdGhlIHBsYWludGV4dFxcbmZ1bmN0aW9uIHBrY3MxdW5wYWQyKGQsIG4pIHtcXG4gICAgdmFyIGIgPSBkLnRvQnl0ZUFycmF5KCk7XFxuICAgIHZhciBpID0gMDtcXG4gICAgd2hpbGUgKGkgPCBiLmxlbmd0aCAmJiBiW2ldID09IDApIHtcXG4gICAgICAgICsraTtcXG4gICAgfVxcbiAgICBpZiAoYi5sZW5ndGggLSBpICE9IG4gLSAxIHx8IGJbaV0gIT0gMikge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgKytpO1xcbiAgICB3aGlsZSAoYltpXSAhPSAwKSB7XFxuICAgICAgICBpZiAoKytpID49IGIubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgdmFyIHJldCA9IFxcXCJcXFwiO1xcbiAgICB3aGlsZSAoKytpIDwgYi5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBjID0gYltpXSAmIDI1NTtcXG4gICAgICAgIGlmIChjIDwgMTI4KSB7IC8vIHV0Zi04IGRlY29kZVxcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoKGMgPiAxOTEpICYmIChjIDwgMjI0KSkge1xcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDMxKSA8PCA2KSB8IChiW2kgKyAxXSAmIDYzKSk7XFxuICAgICAgICAgICAgKytpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMTUpIDw8IDEyKSB8ICgoYltpICsgMV0gJiA2MykgPDwgNikgfCAoYltpICsgMl0gJiA2MykpO1xcbiAgICAgICAgICAgIGkgKz0gMjtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbn1cXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ0NyNwYWdlLTQzXFxudmFyIERJR0VTVF9IRUFERVJTID0ge1xcbiAgICBtZDI6IFxcXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjAyMDUwMDA0MTBcXFwiLFxcbiAgICBtZDU6IFxcXCIzMDIwMzAwYzA2MDgyYTg2NDg4NmY3MGQwMjA1MDUwMDA0MTBcXFwiLFxcbiAgICBzaGExOiBcXFwiMzAyMTMwMDkwNjA1MmIwZTAzMDIxYTA1MDAwNDE0XFxcIixcXG4gICAgc2hhMjI0OiBcXFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcXFwiLFxcbiAgICBzaGEyNTY6IFxcXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFxcXCIsXFxuICAgIHNoYTM4NDogXFxcIjMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwXFxcIixcXG4gICAgc2hhNTEyOiBcXFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcXFwiLFxcbiAgICByaXBlbWQxNjA6IFxcXCIzMDIxMzAwOTA2MDUyYjI0MDMwMjAxMDUwMDA0MTRcXFwiXFxufTtcXG5mdW5jdGlvbiBnZXREaWdlc3RIZWFkZXIobmFtZSkge1xcbiAgICByZXR1cm4gRElHRVNUX0hFQURFUlNbbmFtZV0gfHwgXFxcIlxcXCI7XFxufVxcbmZ1bmN0aW9uIHJlbW92ZURpZ2VzdEhlYWRlcihzdHIpIHtcXG4gICAgZm9yICh2YXIgbmFtZV8xIGluIERJR0VTVF9IRUFERVJTKSB7XFxuICAgICAgICBpZiAoRElHRVNUX0hFQURFUlMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBESUdFU1RfSEVBREVSU1tuYW1lXzFdO1xcbiAgICAgICAgICAgIHZhciBsZW4gPSBoZWFkZXIubGVuZ3RoO1xcbiAgICAgICAgICAgIGlmIChzdHIuc3Vic3RyKDAsIGxlbikgPT0gaGVhZGVyKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKGxlbik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBzdHI7XFxufVxcbi8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBlbmNyeXB0aW9uIG9mIFxcXCJ0ZXh0XFxcIiBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xcbi8vIGZ1bmN0aW9uIFJTQUVuY3J5cHRCNjQodGV4dCkge1xcbi8vICB2YXIgaCA9IHRoaXMuZW5jcnlwdCh0ZXh0KTtcXG4vLyAgaWYoaCkgcmV0dXJuIGhleDJiNjQoaCk7IGVsc2UgcmV0dXJuIG51bGw7XFxuLy8gfVxcbi8vIHB1YmxpY1xcbi8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdF9iNjQgPSBSU0FFbmNyeXB0QjY0O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0pTRW5jcnlwdC8uL2xpYi9saWIvanNibi9yc2EuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2xpYi9saWIvanNibi91dGlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvbGliL2pzYm4vdXRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJjYml0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2JpdCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiaW50MmNoYXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbnQyY2hhciksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwibGJpdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGxiaXQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIm9wX2FuZFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG9wX2FuZCksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwib3BfYW5kbm90XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gb3BfYW5kbm90KSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJvcF9vclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG9wX29yKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJvcF94b3JcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBvcF94b3IpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxudmFyIEJJX1JNID0gXFxcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxcXCI7XFxuZnVuY3Rpb24gaW50MmNoYXIobikge1xcbiAgICByZXR1cm4gQklfUk0uY2hhckF0KG4pO1xcbn1cXG4vLyNyZWdpb24gQklUX09QRVJBVElPTlNcXG4vLyAocHVibGljKSB0aGlzICYgYVxcbmZ1bmN0aW9uIG9wX2FuZCh4LCB5KSB7XFxuICAgIHJldHVybiB4ICYgeTtcXG59XFxuLy8gKHB1YmxpYykgdGhpcyB8IGFcXG5mdW5jdGlvbiBvcF9vcih4LCB5KSB7XFxuICAgIHJldHVybiB4IHwgeTtcXG59XFxuLy8gKHB1YmxpYykgdGhpcyBeIGFcXG5mdW5jdGlvbiBvcF94b3IoeCwgeSkge1xcbiAgICByZXR1cm4geCBeIHk7XFxufVxcbi8vIChwdWJsaWMpIHRoaXMgJiB+YVxcbmZ1bmN0aW9uIG9wX2FuZG5vdCh4LCB5KSB7XFxuICAgIHJldHVybiB4ICYgfnk7XFxufVxcbi8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcXG5mdW5jdGlvbiBsYml0KHgpIHtcXG4gICAgaWYgKHggPT0gMCkge1xcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9XFxuICAgIHZhciByID0gMDtcXG4gICAgaWYgKCh4ICYgMHhmZmZmKSA9PSAwKSB7XFxuICAgICAgICB4ID4+PSAxNjtcXG4gICAgICAgIHIgKz0gMTY7XFxuICAgIH1cXG4gICAgaWYgKCh4ICYgMHhmZikgPT0gMCkge1xcbiAgICAgICAgeCA+Pj0gODtcXG4gICAgICAgIHIgKz0gODtcXG4gICAgfVxcbiAgICBpZiAoKHggJiAweGYpID09IDApIHtcXG4gICAgICAgIHggPj49IDQ7XFxuICAgICAgICByICs9IDQ7XFxuICAgIH1cXG4gICAgaWYgKCh4ICYgMykgPT0gMCkge1xcbiAgICAgICAgeCA+Pj0gMjtcXG4gICAgICAgIHIgKz0gMjtcXG4gICAgfVxcbiAgICBpZiAoKHggJiAxKSA9PSAwKSB7XFxuICAgICAgICArK3I7XFxuICAgIH1cXG4gICAgcmV0dXJuIHI7XFxufVxcbi8vIHJldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcXG5mdW5jdGlvbiBjYml0KHgpIHtcXG4gICAgdmFyIHIgPSAwO1xcbiAgICB3aGlsZSAoeCAhPSAwKSB7XFxuICAgICAgICB4ICY9IHggLSAxO1xcbiAgICAgICAgKytyO1xcbiAgICB9XFxuICAgIHJldHVybiByO1xcbn1cXG4vLyNlbmRyZWdpb24gQklUX09QRVJBVElPTlNcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9KU0VuY3J5cHQvLi9saWIvbGliL2pzYm4vdXRpbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbGliL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2xpYi9saWIvanNyc2FzaWduL2FzbjEtMS4wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIktKVVJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBLSlVSKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9qc2JuL2pzYm4gKi8gXFxcIi4vbGliL2xpYi9qc2JuL2pzYm4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3lhaG9vICovIFxcXCIuL2xpYi9saWIvanNyc2FzaWduL3lhaG9vLmpzXFxcIik7XFxuLyogYXNuMS0xLjAuMTMuanMgKGMpIDIwMTMtMjAxNyBLZW5qaSBVcnVzaGltYSB8IGtqdXIuZ2l0aHViLmNvbS9qc3JzYXNpZ24vbGljZW5zZVxcbiAqL1xcbi8qXFxuICogYXNuMS5qcyAtIEFTTi4xIERFUiBlbmNvZGVyIGNsYXNzZXNcXG4gKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE3IEtlbmppIFVydXNoaW1hIChrZW5qaS51cnVzaGltYUBnbWFpbC5jb20pXFxuICpcXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UuXFxuICogaHR0cHM6Ly9ranVyLmdpdGh1Yi5pby9qc3JzYXNpZ24vbGljZW5zZVxcbiAqXFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBhbmQgbGljZW5zZSBub3RpY2Ugc2hhbGwgYmVcXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4gKi9cXG5cXG5cXG4vKipcXG4gKiBAZmlsZU92ZXJ2aWV3XFxuICogQG5hbWUgYXNuMS0xLjAuanNcXG4gKiBAYXV0aG9yIEtlbmppIFVydXNoaW1hIGtlbmppLnVydXNoaW1hQGdtYWlsLmNvbVxcbiAqIEB2ZXJzaW9uIGFzbjEgMS4wLjEzICgyMDE3LUp1bi0wMilcXG4gKiBAc2luY2UganNyc2FzaWduIDIuMVxcbiAqIEBsaWNlbnNlIDxhIGhyZWY9XFxcImh0dHBzOi8va2p1ci5naXRodWIuaW8vanNyc2FzaWduL2xpY2Vuc2UvXFxcIj5NSVQgTGljZW5zZTwvYT5cXG4gKi9cXG4vKipcXG4gKiBranVyJ3MgY2xhc3MgbGlicmFyeSBuYW1lIHNwYWNlXFxuICogPHA+XFxuICogVGhpcyBuYW1lIHNwYWNlIHByb3ZpZGVzIGZvbGxvd2luZyBuYW1lIHNwYWNlczpcXG4gKiA8dWw+XFxuICogPGxpPntAbGluayBLSlVSLmFzbjF9IC0gQVNOLjEgcHJpbWl0aXZlIGhleGFkZWNpbWFsIGVuY29kZXI8L2xpPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLng1MDl9IC0gQVNOLjEgc3RydWN0dXJlIGZvciBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cXG4gKiA8bGk+e0BsaW5rIEtKVVIuY3J5cHRvfSAtIEphdmEgQ3J5cHRvZ3JhcGhpYyBFeHRlbnNpb24oSkNFKSBzdHlsZSBNZXNzYWdlRGlnZXN0L1NpZ25hdHVyZVxcbiAqIGNsYXNzIGFuZCB1dGlsaXRpZXM8L2xpPlxcbiAqIDwvdWw+XFxuICogPC9wPlxcbiAqIE5PVEU6IFBsZWFzZSBpZ25vcmUgbWV0aG9kIHN1bW1hcnkgYW5kIGRvY3VtZW50IG9mIHRoaXMgbmFtZXNwYWNlLiBUaGlzIGNhdXNlZCBieSBhIGJ1ZyBvZiBqc2RvYzIuXFxuICogQG5hbWUgS0pVUlxcbiAqIEBuYW1lc3BhY2Uga2p1cidzIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxcbiAqL1xcbnZhciBLSlVSID0ge307XFxuLyoqXFxuICoga2p1cidzIEFTTi4xIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxcbiAqIDxwPlxcbiAqIFRoaXMgaXMgSVRVLVQgWC42OTAgQVNOLjEgREVSIGVuY29kZXIgY2xhc3MgbGlicmFyeSBhbmRcXG4gKiBjbGFzcyBzdHJ1Y3R1cmUgYW5kIG1ldGhvZHMgaXMgdmVyeSBzaW1pbGFyIHRvXFxuICogb3JnLmJvdW5jeWNhc3RsZS5hc24xIHBhY2thZ2Ugb2ZcXG4gKiB3ZWxsIGtub3duIEJvdW5jeUNhc2x0ZSBDcnlwdG9ncmFwaHkgTGlicmFyeS5cXG4gKiA8aDQ+UFJPVklESU5HIEFTTi4xIFBSSU1JVElWRVM8L2g0PlxcbiAqIEhlcmUgYXJlIEFTTi4xIERFUiBwcmltaXRpdmUgY2xhc3Nlcy5cXG4gKiA8dWw+XFxuICogPGxpPjB4MDEge0BsaW5rIEtKVVIuYXNuMS5ERVJCb29sZWFufTwvbGk+XFxuICogPGxpPjB4MDIge0BsaW5rIEtKVVIuYXNuMS5ERVJJbnRlZ2VyfTwvbGk+XFxuICogPGxpPjB4MDMge0BsaW5rIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmd9PC9saT5cXG4gKiA8bGk+MHgwNCB7QGxpbmsgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nfTwvbGk+XFxuICogPGxpPjB4MDUge0BsaW5rIEtKVVIuYXNuMS5ERVJOdWxsfTwvbGk+XFxuICogPGxpPjB4MDYge0BsaW5rIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyfTwvbGk+XFxuICogPGxpPjB4MGEge0BsaW5rIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkfTwvbGk+XFxuICogPGxpPjB4MGMge0BsaW5rIEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nfTwvbGk+XFxuICogPGxpPjB4MTIge0BsaW5rIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nfTwvbGk+XFxuICogPGxpPjB4MTMge0BsaW5rIEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmd9PC9saT5cXG4gKiA8bGk+MHgxNCB7QGxpbmsgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmd9PC9saT5cXG4gKiA8bGk+MHgxNiB7QGxpbmsgS0pVUi5hc24xLkRFUklBNVN0cmluZ308L2xpPlxcbiAqIDxsaT4weDE3IHtAbGluayBLSlVSLmFzbjEuREVSVVRDVGltZX08L2xpPlxcbiAqIDxsaT4weDE4IHtAbGluayBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lfTwvbGk+XFxuICogPGxpPjB4MzAge0BsaW5rIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZX08L2xpPlxcbiAqIDxsaT4weDMxIHtAbGluayBLSlVSLmFzbjEuREVSU2V0fTwvbGk+XFxuICogPC91bD5cXG4gKiA8aDQ+T1RIRVIgQVNOLjEgQ0xBU1NFUzwvaDQ+XFxuICogPHVsPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkFTTjFPYmplY3R9PC9saT5cXG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ308L2xpPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZX08L2xpPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZH08L2xpPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdH08L2xpPlxcbiAqIDwvdWw+XFxuICogPGg0PlNVQiBOQU1FIFNQQUNFUzwvaDQ+XFxuICogPHVsPlxcbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLmNhZGVzfSAtIENBZEVTIGxvbmcgdGVybSBzaWduYXR1cmUgZm9ybWF0PC9saT5cXG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5jbXN9IC0gQ3J5cHRvZ3JhcGhpYyBNZXNzYWdlIFN5bnRheDwvbGk+XFxuICogPGxpPntAbGluayBLSlVSLmFzbjEuY3NyfSAtIENlcnRpZmljYXRlIFNpZ25pbmcgUmVxdWVzdCAoQ1NSL1BLQ1MjMTApPC9saT5cXG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS50c3B9IC0gUkZDIDMxNjEgVGltZXN0YW1waW5nIFByb3RvY29sIEZvcm1hdDwvbGk+XFxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBSRkMgNTI4MCBYLjUwOSBjZXJ0aWZpY2F0ZSBhbmQgQ1JMPC9saT5cXG4gKiA8L3VsPlxcbiAqIDwvcD5cXG4gKiBOT1RFOiBQbGVhc2UgaWdub3JlIG1ldGhvZCBzdW1tYXJ5IGFuZCBkb2N1bWVudCBvZiB0aGlzIG5hbWVzcGFjZS5cXG4gKiBUaGlzIGNhdXNlZCBieSBhIGJ1ZyBvZiBqc2RvYzIuXFxuICogQG5hbWUgS0pVUi5hc24xXFxuICogQG5hbWVzcGFjZVxcbiAqL1xcbmlmICh0eXBlb2YgS0pVUi5hc24xID09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFLSlVSLmFzbjEpXFxuICAgIEtKVVIuYXNuMSA9IHt9O1xcbi8qKlxcbiAqIEFTTjEgdXRpbGl0aWVzIGNsYXNzXFxuICogQG5hbWUgS0pVUi5hc24xLkFTTjFVdGlsXFxuICogQGNsYXNzIEFTTjEgdXRpbGl0aWVzIGNsYXNzXFxuICogQHNpbmNlIGFzbjEgMS4wLjJcXG4gKi9cXG5LSlVSLmFzbjEuQVNOMVV0aWwgPSBuZXcgZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmludGVnZXJUb0J5dGVIZXggPSBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgIGlmICgoaC5sZW5ndGggJSAyKSA9PSAxKVxcbiAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcbiAgICAgICAgcmV0dXJuIGg7XFxuICAgIH07XFxuICAgIHRoaXMuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXggPSBmdW5jdGlvbiAoYmlnSW50ZWdlclZhbHVlKSB7XFxuICAgICAgICB2YXIgaCA9IGJpZ0ludGVnZXJWYWx1ZS50b1N0cmluZygxNik7XFxuICAgICAgICBpZiAoaC5zdWJzdHIoMCwgMSkgIT0gJy0nKSB7XFxuICAgICAgICAgICAgaWYgKGgubGVuZ3RoICUgMiA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFoLm1hdGNoKC9eWzAtN10vKSkge1xcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwMCcgKyBoO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdmFyIGhQb3MgPSBoLnN1YnN0cigxKTtcXG4gICAgICAgICAgICB2YXIgeG9yTGVuID0gaFBvcy5sZW5ndGg7XFxuICAgICAgICAgICAgaWYgKHhvckxlbiAlIDIgPT0gMSkge1xcbiAgICAgICAgICAgICAgICB4b3JMZW4gKz0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmICghaC5tYXRjaCgvXlswLTddLykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhvckxlbiArPSAyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBoTWFzayA9ICcnO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeG9yTGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaE1hc2sgKz0gJ2YnO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgYmlNYXNrID0gbmV3IF9qc2JuX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyKGhNYXNrLCAxNik7XFxuICAgICAgICAgICAgdmFyIGJpTmVnID0gYmlNYXNrLnhvcihiaWdJbnRlZ2VyVmFsdWUpLmFkZChfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlci5PTkUpO1xcbiAgICAgICAgICAgIGggPSBiaU5lZy50b1N0cmluZygxNikucmVwbGFjZSgvXi0vLCAnJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaDtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdldCBQRU0gc3RyaW5nIGZyb20gaGV4YWRlY2ltYWwgZGF0YSBhbmQgaGVhZGVyIHN0cmluZ1xcbiAgICAgKiBAbmFtZSBnZXRQRU1TdHJpbmdGcm9tSGV4XFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhSGV4IGhleGFkZWNpbWFsIHN0cmluZyBvZiBQRU0gYm9keVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGVtSGVhZGVyIFBFTSBoZWFkZXIgc3RyaW5nIChleC4gJ1JTQSBQUklWQVRFIEtFWScpXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUEVNIGZvcm1hdHRlZCBzdHJpbmcgb2YgaW5wdXQgZGF0YVxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBQRU0gc3RyaW5nIHdpdGhcXG4gICAgICogYSBzcGVjaWZpZWQgaGVhZGVyLiBJdHMgbGluZSBicmVhayB3aWxsIGJlIENSTEYoXFxcIlxcXFxyXFxcXG5cXFwiKS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICogdmFyIHBlbSAgPSBLSlVSLmFzbjEuQVNOMVV0aWwuZ2V0UEVNU3RyaW5nRnJvbUhleCgnNjE2MTYxJywgJ1JTQSBQUklWQVRFIEtFWScpO1xcbiAgICAgKiAvLyB2YWx1ZSBvZiBwZW0gd2lsbCBiZTpcXG4gICAgICogLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuICAgICAqIFlXRmhcXG4gICAgICogLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLVxcbiAgICAgKi9cXG4gICAgdGhpcy5nZXRQRU1TdHJpbmdGcm9tSGV4ID0gZnVuY3Rpb24gKGRhdGFIZXgsIHBlbUhlYWRlcikge1xcbiAgICAgICAgcmV0dXJuIGhleHRvcGVtKGRhdGFIZXgsIHBlbUhlYWRlcik7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBnZW5lcmF0ZSBBU04xT2JqZWN0IHNwZWNpZmVkIGJ5IEpTT04gcGFyYW1ldGVyc1xcbiAgICAgKiBAbmFtZSBuZXdPYmplY3RcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0gSlNPTiBwYXJhbWV0ZXIgdG8gZ2VuZXJhdGUgQVNOMU9iamVjdFxcbiAgICAgKiBAcmV0dXJuIHtLSlVSLmFzbjEuQVNOMU9iamVjdH0gZ2VuZXJhdGVkIG9iamVjdFxcbiAgICAgKiBAc2luY2UgYXNuMSAxLjAuM1xcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogZ2VuZXJhdGUgYW55IEFTTjFPYmplY3Qgc3BlY2lmaWVkIGJ5IEpTT04gcGFyYW1cXG4gICAgICogaW5jbHVkaW5nIEFTTi4xIHByaW1pdGl2ZSBvciBzdHJ1Y3R1cmVkLlxcbiAgICAgKiBHZW5lcmFsbHkgJ3BhcmFtJyBjYW4gYmUgZGVzY3JpYmVkIGFzIGZvbGxvd3M6XFxuICAgICAqIDxibG9ja3F1b3RlPlxcbiAgICAgKiB7VFlQRS1PRi1BU05PQko6IEFTTjFPQkotUEFSQU1FVEVSfVxcbiAgICAgKiA8L2Jsb2NrcXVvdGU+XFxuICAgICAqICdUWVBFLU9GLUFTTjFPQkonIGNhbiBiZSBvbmUgb2YgZm9sbG93aW5nIHN5bWJvbHM6XFxuICAgICAqIDx1bD5cXG4gICAgICogPGxpPidib29sJyAtIERFUkJvb2xlYW48L2xpPlxcbiAgICAgKiA8bGk+J2ludCcgLSBERVJJbnRlZ2VyPC9saT5cXG4gICAgICogPGxpPidiaXRzdHInIC0gREVSQml0U3RyaW5nPC9saT5cXG4gICAgICogPGxpPidvY3RzdHInIC0gREVST2N0ZXRTdHJpbmc8L2xpPlxcbiAgICAgKiA8bGk+J251bGwnIC0gREVSTnVsbDwvbGk+XFxuICAgICAqIDxsaT4nb2lkJyAtIERFUk9iamVjdElkZW50aWZpZXI8L2xpPlxcbiAgICAgKiA8bGk+J2VudW0nIC0gREVSRW51bWVyYXRlZDwvbGk+XFxuICAgICAqIDxsaT4ndXRmOHN0cicgLSBERVJVVEY4U3RyaW5nPC9saT5cXG4gICAgICogPGxpPidudW1zdHInIC0gREVSTnVtZXJpY1N0cmluZzwvbGk+XFxuICAgICAqIDxsaT4ncHJuc3RyJyAtIERFUlByaW50YWJsZVN0cmluZzwvbGk+XFxuICAgICAqIDxsaT4ndGVsc3RyJyAtIERFUlRlbGV0ZXhTdHJpbmc8L2xpPlxcbiAgICAgKiA8bGk+J2lhNXN0cicgLSBERVJJQTVTdHJpbmc8L2xpPlxcbiAgICAgKiA8bGk+J3V0Y3RpbWUnIC0gREVSVVRDVGltZTwvbGk+XFxuICAgICAqIDxsaT4nZ2VudGltZScgLSBERVJHZW5lcmFsaXplZFRpbWU8L2xpPlxcbiAgICAgKiA8bGk+J3NlcScgLSBERVJTZXF1ZW5jZTwvbGk+XFxuICAgICAqIDxsaT4nc2V0JyAtIERFUlNldDwvbGk+XFxuICAgICAqIDxsaT4ndGFnJyAtIERFUlRhZ2dlZE9iamVjdDwvbGk+XFxuICAgICAqIDwvdWw+XFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIG5ld09iamVjdCh7J3BybnN0cic6ICdhYWEnfSk7XFxuICAgICAqIG5ld09iamVjdCh7J3NlcSc6IFt7J2ludCc6IDN9LCB7J3BybnN0cic6ICdhYWEnfV19KVxcbiAgICAgKiAvLyBBU04uMSBUYWdnZWQgT2JqZWN0XFxuICAgICAqIG5ld09iamVjdCh7J3RhZyc6IHsndGFnJzogJ2ExJyxcXG4gICAgICogICAgICAgICAgICAgICAgICAgICdleHBsaWNpdCc6IHRydWUsXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAnb2JqJzogeydzZXEnOiBbeydpbnQnOiAzfSwgeydwcm5zdHInOiAnYWFhJ31dfX19KTtcXG4gICAgICogLy8gbW9yZSBzaW1wbGUgcmVwcmVzZW50YXRpb24gb2YgQVNOLjEgVGFnZ2VkIE9iamVjdFxcbiAgICAgKiBuZXdPYmplY3Qoeyd0YWcnOiBbJ2ExJyxcXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRydWUsXFxuICAgICAqICAgICAgICAgICAgICAgICAgICB7J3NlcSc6IFtcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydpbnQnOiAzfSxcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgeydwcm5zdHInOiAnYWFhJ31dfVxcbiAgICAgKiAgICAgICAgICAgICAgICAgICBdfSk7XFxuICAgICAqL1xcbiAgICB0aGlzLm5ld09iamVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xcbiAgICAgICAgdmFyIF9LSlVSID0gS0pVUiwgX0tKVVJfYXNuMSA9IF9LSlVSLmFzbjEsIF9ERVJCb29sZWFuID0gX0tKVVJfYXNuMS5ERVJCb29sZWFuLCBfREVSSW50ZWdlciA9IF9LSlVSX2FzbjEuREVSSW50ZWdlciwgX0RFUkJpdFN0cmluZyA9IF9LSlVSX2FzbjEuREVSQml0U3RyaW5nLCBfREVST2N0ZXRTdHJpbmcgPSBfS0pVUl9hc24xLkRFUk9jdGV0U3RyaW5nLCBfREVSTnVsbCA9IF9LSlVSX2FzbjEuREVSTnVsbCwgX0RFUk9iamVjdElkZW50aWZpZXIgPSBfS0pVUl9hc24xLkRFUk9iamVjdElkZW50aWZpZXIsIF9ERVJFbnVtZXJhdGVkID0gX0tKVVJfYXNuMS5ERVJFbnVtZXJhdGVkLCBfREVSVVRGOFN0cmluZyA9IF9LSlVSX2FzbjEuREVSVVRGOFN0cmluZywgX0RFUk51bWVyaWNTdHJpbmcgPSBfS0pVUl9hc24xLkRFUk51bWVyaWNTdHJpbmcsIF9ERVJQcmludGFibGVTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlByaW50YWJsZVN0cmluZywgX0RFUlRlbGV0ZXhTdHJpbmcgPSBfS0pVUl9hc24xLkRFUlRlbGV0ZXhTdHJpbmcsIF9ERVJJQTVTdHJpbmcgPSBfS0pVUl9hc24xLkRFUklBNVN0cmluZywgX0RFUlVUQ1RpbWUgPSBfS0pVUl9hc24xLkRFUlVUQ1RpbWUsIF9ERVJHZW5lcmFsaXplZFRpbWUgPSBfS0pVUl9hc24xLkRFUkdlbmVyYWxpemVkVGltZSwgX0RFUlNlcXVlbmNlID0gX0tKVVJfYXNuMS5ERVJTZXF1ZW5jZSwgX0RFUlNldCA9IF9LSlVSX2FzbjEuREVSU2V0LCBfREVSVGFnZ2VkT2JqZWN0ID0gX0tKVVJfYXNuMS5ERVJUYWdnZWRPYmplY3QsIF9uZXdPYmplY3QgPSBfS0pVUl9hc24xLkFTTjFVdGlsLm5ld09iamVjdDtcXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW0pO1xcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9IDEpXFxuICAgICAgICAgICAgdGhyb3cgXFxcImtleSBvZiBwYXJhbSBzaGFsbCBiZSBvbmx5IG9uZS5cXFwiO1xcbiAgICAgICAgdmFyIGtleSA9IGtleXNbMF07XFxuICAgICAgICBpZiAoXFxcIjpib29sOmludDpiaXRzdHI6b2N0c3RyOm51bGw6b2lkOmVudW06dXRmOHN0cjpudW1zdHI6cHJuc3RyOnRlbHN0cjppYTVzdHI6dXRjdGltZTpnZW50aW1lOnNlcTpzZXQ6dGFnOlxcXCIuaW5kZXhPZihcXFwiOlxcXCIgKyBrZXkgKyBcXFwiOlxcXCIpID09IC0xKVxcbiAgICAgICAgICAgIHRocm93IFxcXCJ1bmRlZmluZWQga2V5OiBcXFwiICsga2V5O1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwiYm9vbFxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSQm9vbGVhbihwYXJhbVtrZXldKTtcXG4gICAgICAgIGlmIChrZXkgPT0gXFxcImludFxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSSW50ZWdlcihwYXJhbVtrZXldKTtcXG4gICAgICAgIGlmIChrZXkgPT0gXFxcImJpdHN0clxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSQml0U3RyaW5nKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwib2N0c3RyXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJPY3RldFN0cmluZyhwYXJhbVtrZXldKTtcXG4gICAgICAgIGlmIChrZXkgPT0gXFxcIm51bGxcXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUk51bGwocGFyYW1ba2V5XSk7XFxuICAgICAgICBpZiAoa2V5ID09IFxcXCJvaWRcXFwiKVxcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0RFUk9iamVjdElkZW50aWZpZXIocGFyYW1ba2V5XSk7XFxuICAgICAgICBpZiAoa2V5ID09IFxcXCJlbnVtXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJFbnVtZXJhdGVkKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwidXRmOHN0clxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVVRGOFN0cmluZyhwYXJhbVtrZXldKTtcXG4gICAgICAgIGlmIChrZXkgPT0gXFxcIm51bXN0clxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSTnVtZXJpY1N0cmluZyhwYXJhbVtrZXldKTtcXG4gICAgICAgIGlmIChrZXkgPT0gXFxcInBybnN0clxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSUHJpbnRhYmxlU3RyaW5nKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwidGVsc3RyXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUZWxldGV4U3RyaW5nKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwiaWE1c3RyXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJJQTVTdHJpbmcocGFyYW1ba2V5XSk7XFxuICAgICAgICBpZiAoa2V5ID09IFxcXCJ1dGN0aW1lXFxcIilcXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJVVENUaW1lKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwiZ2VudGltZVxcXCIpXFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSR2VuZXJhbGl6ZWRUaW1lKHBhcmFtW2tleV0pO1xcbiAgICAgICAgaWYgKGtleSA9PSBcXFwic2VxXFxcIikge1xcbiAgICAgICAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVtrZXldO1xcbiAgICAgICAgICAgIHZhciBhID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGFzbjFPYmogPSBfbmV3T2JqZWN0KHBhcmFtTGlzdFtpXSk7XFxuICAgICAgICAgICAgICAgIGEucHVzaChhc24xT2JqKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSU2VxdWVuY2UoeyAnYXJyYXknOiBhIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGtleSA9PSBcXFwic2V0XFxcIikge1xcbiAgICAgICAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVtrZXldO1xcbiAgICAgICAgICAgIHZhciBhID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGFzbjFPYmogPSBfbmV3T2JqZWN0KHBhcmFtTGlzdFtpXSk7XFxuICAgICAgICAgICAgICAgIGEucHVzaChhc24xT2JqKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSU2V0KHsgJ2FycmF5JzogYSB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChrZXkgPT0gXFxcInRhZ1xcXCIpIHtcXG4gICAgICAgICAgICB2YXIgdGFnUGFyYW0gPSBwYXJhbVtrZXldO1xcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFnUGFyYW0pID09PSAnW29iamVjdCBBcnJheV0nICYmXFxuICAgICAgICAgICAgICAgIHRhZ1BhcmFtLmxlbmd0aCA9PSAzKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBfbmV3T2JqZWN0KHRhZ1BhcmFtWzJdKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVGFnZ2VkT2JqZWN0KHsgdGFnOiB0YWdQYXJhbVswXSxcXG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiB0YWdQYXJhbVsxXSxcXG4gICAgICAgICAgICAgICAgICAgIG9iajogb2JqIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BhcmFtID0ge307XFxuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS5leHBsaWNpdCAhPT0gdW5kZWZpbmVkKVxcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW0uZXhwbGljaXQgPSB0YWdQYXJhbS5leHBsaWNpdDtcXG4gICAgICAgICAgICAgICAgaWYgKHRhZ1BhcmFtLnRhZyAhPT0gdW5kZWZpbmVkKVxcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW0udGFnID0gdGFnUGFyYW0udGFnO1xcbiAgICAgICAgICAgICAgICBpZiAodGFnUGFyYW0ub2JqID09PSB1bmRlZmluZWQpXFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcXFwib2JqIHNoYWxsIGJlIHNwZWNpZmllZCBmb3IgJ3RhZycuXFxcIjtcXG4gICAgICAgICAgICAgICAgbmV3UGFyYW0ub2JqID0gX25ld09iamVjdCh0YWdQYXJhbS5vYmopO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJUYWdnZWRPYmplY3QobmV3UGFyYW0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdldCBlbmNvZGVkIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04xT2JqZWN0IHNwZWNpZmVkIGJ5IEpTT04gcGFyYW1ldGVyc1xcbiAgICAgKiBAbmFtZSBqc29uVG9BU04xSEVYXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtIEpTT04gcGFyYW1ldGVyIHRvIGdlbmVyYXRlIEFTTjFPYmplY3RcXG4gICAgICogQHJldHVybiBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOMU9iamVjdFxcbiAgICAgKiBAc2luY2UgYXNuMSAxLjAuNFxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogQXMgZm9yIEFTTi4xIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBKU09OIG9iamVjdCxcXG4gICAgICogcGxlYXNlIHNlZSB7QGxpbmsgbmV3T2JqZWN0fS5cXG4gICAgICogQGV4YW1wbGVcXG4gICAgICoganNvblRvQVNOMUhFWCh7J3BybnN0cic6ICdhYWEnfSk7XFxuICAgICAqL1xcbiAgICB0aGlzLmpzb25Ub0FTTjFIRVggPSBmdW5jdGlvbiAocGFyYW0pIHtcXG4gICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5uZXdPYmplY3QocGFyYW0pO1xcbiAgICAgICAgcmV0dXJuIGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xcbiAgICB9O1xcbn07XFxuLyoqXFxuICogZ2V0IGRvdCBub3RlZCBvaWQgbnVtYmVyIHN0cmluZyBmcm9tIGhleGFkZWNpbWFsIHZhbHVlIG9mIE9JRFxcbiAqIEBuYW1lIG9pZEhleFRvSW50XFxuICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxcbiAqIEBmdW5jdGlvblxcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXJcXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRvdCBub3RlZCBzdHJpbmcgb2Ygb2JqZWN0IGlkZW50aWZpZXJcXG4gKiBAc2luY2UganNyc2FzaWduIDQuOC4zIGFzbjEgMS4wLjdcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBUaGlzIHN0YXRpYyBtZXRob2QgY29udmVydHMgZnJvbSBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcXG4gKiBBU04uMSB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciB0byBvaWQgbnVtYmVyIHN0cmluZy5cXG4gKiBAZXhhbXBsZVxcbiAqIEtKVVIuYXNuMS5BU04xVXRpbC5vaWRIZXhUb0ludCgnNTUwNDA2JykgJnJhcnI7IFxcXCIyLjUuNC42XFxcIlxcbiAqL1xcbktKVVIuYXNuMS5BU04xVXRpbC5vaWRIZXhUb0ludCA9IGZ1bmN0aW9uIChoZXgpIHtcXG4gICAgdmFyIHMgPSBcXFwiXFxcIjtcXG4gICAgdmFyIGkwMSA9IHBhcnNlSW50KGhleC5zdWJzdHIoMCwgMiksIDE2KTtcXG4gICAgdmFyIGkwID0gTWF0aC5mbG9vcihpMDEgLyA0MCk7XFxuICAgIHZhciBpMSA9IGkwMSAlIDQwO1xcbiAgICB2YXIgcyA9IGkwICsgXFxcIi5cXFwiICsgaTE7XFxuICAgIHZhciBiaW5idWYgPSBcXFwiXFxcIjtcXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcXG4gICAgICAgIHZhciBiaW4gPSAoXFxcIjAwMDAwMDAwXFxcIiArIHZhbHVlLnRvU3RyaW5nKDIpKS5zbGljZSgtOCk7XFxuICAgICAgICBiaW5idWYgPSBiaW5idWYgKyBiaW4uc3Vic3RyKDEsIDcpO1xcbiAgICAgICAgaWYgKGJpbi5zdWJzdHIoMCwgMSkgPT0gXFxcIjBcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIGJpID0gbmV3IF9qc2JuX2pzYm5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5CaWdJbnRlZ2VyKGJpbmJ1ZiwgMik7XFxuICAgICAgICAgICAgcyA9IHMgKyBcXFwiLlxcXCIgKyBiaS50b1N0cmluZygxMCk7XFxuICAgICAgICAgICAgYmluYnVmID0gXFxcIlxcXCI7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgO1xcbiAgICByZXR1cm4gcztcXG59O1xcbi8qKlxcbiAqIGdldCBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciBmcm9tIGRvdCBub3RlZCBvaWQgdmFsdWVcXG4gKiBAbmFtZSBvaWRJbnRUb0hleFxcbiAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMVV0aWxcXG4gKiBAZnVuY3Rpb25cXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkU3RyaW5nIGRvdCBub3RlZCBzdHJpbmcgb2Ygb2JqZWN0IGlkZW50aWZpZXJcXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHZhbHVlIG9mIG9iamVjdCBpZGVudGlmaWVyXFxuICogQHNpbmNlIGpzcnNhc2lnbiA0LjguMyBhc24xIDEuMC43XFxuICogQGRlc2NyaXB0aW9uXFxuICogVGhpcyBzdGF0aWMgbWV0aG9kIGNvbnZlcnRzIGZyb20gb2JqZWN0IGlkZW50aWZpZXIgdmFsdWUgc3RyaW5nLlxcbiAqIHRvIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdC5cXG4gKiBAZXhhbXBsZVxcbiAqIEtKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleChcXFwiMi41LjQuNlxcXCIpICZyYXJyOyBcXFwiNTUwNDA2XFxcIlxcbiAqL1xcbktKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleCA9IGZ1bmN0aW9uIChvaWRTdHJpbmcpIHtcXG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKVxcbiAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcbiAgICAgICAgcmV0dXJuIGg7XFxuICAgIH07XFxuICAgIHZhciByb2lkdG94ID0gZnVuY3Rpb24gKHJvaWQpIHtcXG4gICAgICAgIHZhciBoID0gJyc7XFxuICAgICAgICB2YXIgYmkgPSBuZXcgX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIocm9pZCwgMTApO1xcbiAgICAgICAgdmFyIGIgPSBiaS50b1N0cmluZygyKTtcXG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xcbiAgICAgICAgaWYgKHBhZExlbiA9PSA3KVxcbiAgICAgICAgICAgIHBhZExlbiA9IDA7XFxuICAgICAgICB2YXIgYlBhZCA9ICcnO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW47IGkrKylcXG4gICAgICAgICAgICBiUGFkICs9ICcwJztcXG4gICAgICAgIGIgPSBiUGFkICsgYjtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGggLSAxOyBpICs9IDcpIHtcXG4gICAgICAgICAgICB2YXIgYjggPSBiLnN1YnN0cihpLCA3KTtcXG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpXFxuICAgICAgICAgICAgICAgIGI4ID0gJzEnICsgYjg7XFxuICAgICAgICAgICAgaCArPSBpdG94KHBhcnNlSW50KGI4LCAyKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaDtcXG4gICAgfTtcXG4gICAgaWYgKCFvaWRTdHJpbmcubWF0Y2goL15bMC05Ll0rJC8pKSB7XFxuICAgICAgICB0aHJvdyBcXFwibWFsZm9ybWVkIG9pZCBzdHJpbmc6IFxcXCIgKyBvaWRTdHJpbmc7XFxuICAgIH1cXG4gICAgdmFyIGggPSAnJztcXG4gICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcXG4gICAgdmFyIGkwID0gcGFyc2VJbnQoYVswXSkgKiA0MCArIHBhcnNlSW50KGFbMV0pO1xcbiAgICBoICs9IGl0b3goaTApO1xcbiAgICBhLnNwbGljZSgwLCAyKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBoICs9IHJvaWR0b3goYVtpXSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGg7XFxufTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vICBBYnN0cmFjdCBBU04uMSBDbGFzc2VzXFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxcbiAqIEBuYW1lIEtKVVIuYXNuMS5BU04xT2JqZWN0XFxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVyIG9iamVjdFxcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNNb2RpZmllZCBmbGFnIHdoZXRoZXIgaW50ZXJuYWwgZGF0YSB3YXMgY2hhbmdlZFxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoVExWIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFZcXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB0YWcoVClcXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaEwgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViBsZW5ndGgoTClcXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFYgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB2YWx1ZShWKVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqL1xcbktKVVIuYXNuMS5BU04xT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgaXNNb2RpZmllZCA9IHRydWU7XFxuICAgIHZhciBoVExWID0gbnVsbDtcXG4gICAgdmFyIGhUID0gJzAwJztcXG4gICAgdmFyIGhMID0gJzAwJztcXG4gICAgdmFyIGhWID0gJyc7XFxuICAgIC8qKlxcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgQVNOLjEgVExWIGxlbmd0aChMKSBieXRlcyBmcm9tIFRMViB2YWx1ZShWKVxcbiAgICAgKiBAbmFtZSBnZXRMZW5ndGhIZXhGcm9tVmFsdWVcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xT2JqZWN0I1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIGxlbmd0aChMKVxcbiAgICAgKi9cXG4gICAgdGhpcy5nZXRMZW5ndGhIZXhGcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaFYgPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgdGhpcy5oViA9PSBudWxsKSB7XFxuICAgICAgICAgICAgdGhyb3cgXFxcInRoaXMuaFYgaXMgbnVsbCBvciB1bmRlZmluZWQuXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLmhWLmxlbmd0aCAlIDIgPT0gMSkge1xcbiAgICAgICAgICAgIHRocm93IFxcXCJ2YWx1ZSBoZXggbXVzdCBiZSBldmVuIGxlbmd0aDogbj1cXFwiICsgaFYubGVuZ3RoICsgXFxcIix2PVxcXCIgKyB0aGlzLmhWO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG4gPSB0aGlzLmhWLmxlbmd0aCAvIDI7XFxuICAgICAgICB2YXIgaE4gPSBuLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgIGlmIChoTi5sZW5ndGggJSAyID09IDEpIHtcXG4gICAgICAgICAgICBoTiA9IFxcXCIwXFxcIiArIGhOO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG4gPCAxMjgpIHtcXG4gICAgICAgICAgICByZXR1cm4gaE47XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgaE5sZW4gPSBoTi5sZW5ndGggLyAyO1xcbiAgICAgICAgICAgIGlmIChoTmxlbiA+IDE1KSB7XFxuICAgICAgICAgICAgICAgIHRocm93IFxcXCJBU04uMSBsZW5ndGggdG9vIGxvbmcgdG8gcmVwcmVzZW50IGJ5IDh4OiBuID0gXFxcIiArIG4udG9TdHJpbmcoMTYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgaGVhZCA9IDEyOCArIGhObGVuO1xcbiAgICAgICAgICAgIHJldHVybiBoZWFkLnRvU3RyaW5nKDE2KSArIGhOO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZ2V0IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgYnl0ZXNcXG4gICAgICogQG5hbWUgZ2V0RW5jb2RlZEhleFxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFPYmplY3QjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFZcXG4gICAgICovXFxuICAgIHRoaXMuZ2V0RW5jb2RlZEhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0aGlzLmhUTFYgPT0gbnVsbCB8fCB0aGlzLmlzTW9kaWZpZWQpIHtcXG4gICAgICAgICAgICB0aGlzLmhWID0gdGhpcy5nZXRGcmVzaFZhbHVlSGV4KCk7XFxuICAgICAgICAgICAgdGhpcy5oTCA9IHRoaXMuZ2V0TGVuZ3RoSGV4RnJvbVZhbHVlKCk7XFxuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVCArIHRoaXMuaEwgKyB0aGlzLmhWO1xcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIC8vYWxlcnQoXFxcImZpcnN0IHRpbWU6IFxcXCIgKyB0aGlzLmhUTFYpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuaFRMVjtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdldCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHZhbHVlKFYpIGJ5dGVzXFxuICAgICAqIEBuYW1lIGdldFZhbHVlSGV4XFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB2YWx1ZShWKSBieXRlc1xcbiAgICAgKi9cXG4gICAgdGhpcy5nZXRWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMuZ2V0RW5jb2RlZEhleCgpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfTtcXG59O1xcbi8vID09IEJFR0lOIERFUkFic3RyYWN0U3RyaW5nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbi8qKlxcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJpbmcgY2xhc3Nlc1xcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RyaW5nIGNsYXNzZXNcXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzIGludGVybmFsIHN0cmluZyBvZiB2YWx1ZVxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XFxuICogQGRlc2NyaXB0aW9uXFxuICogPGJyLz5cXG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXFxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuICogPHVsPlxcbiAqIDxsaT5zdHIgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBzdHJpbmc8L2xpPlxcbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxcbiAqIDwvdWw+XFxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXFxuICovXFxuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgICB2YXIgcyA9IG51bGw7XFxuICAgIHZhciBoViA9IG51bGw7XFxuICAgIC8qKlxcbiAgICAgKiBnZXQgc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxcbiAgICAgKiBAbmFtZSBnZXRTdHJpbmdcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxcbiAgICAgKi9cXG4gICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgc3RyaW5nXFxuICAgICAqIEBuYW1lIHNldFN0cmluZ1xcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1MgdmFsdWUgYnkgYSBzdHJpbmcgdG8gc2V0XFxuICAgICAqL1xcbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uIChuZXdTKSB7XFxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMucyA9IG5ld1M7XFxuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmdcXG4gICAgICogQG5hbWUgc2V0U3RyaW5nSGV4XFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nIHZhbHVlIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHNldFxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRTdHJpbmdIZXggPSBmdW5jdGlvbiAobmV3SGV4U3RyaW5nKSB7XFxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMucyA9IG51bGw7XFxuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xcbiAgICB9O1xcbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcXG4gICAgfTtcXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ3N0ciddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zWydzdHInXSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nSGV4KHBhcmFtc1snaGV4J10pO1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcXG4vLyA9PSBFTkQgICBERVJBYnN0cmFjdFN0cmluZyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFRpbWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4vKipcXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWQvVVRDVGltZSBjbGFzc1xcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcXG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkL1VUQ1RpbWUgY2xhc3NcXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJzEzMDQzMDIzNTk1OVonfSlcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXFxuICovXFxuS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICAgIHZhciBzID0gbnVsbDtcXG4gICAgdmFyIGRhdGUgPSBudWxsO1xcbiAgICAvLyAtLS0gUFJJVkFURSBNRVRIT0RTIC0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIHRoaXMubG9jYWxEYXRlVG9VVEMgPSBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgdXRjID0gZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xcbiAgICAgICAgdmFyIHV0Y0RhdGUgPSBuZXcgRGF0ZSh1dGMpO1xcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGU7XFxuICAgIH07XFxuICAgIC8qXFxuICAgICAqIGZvcm1hdCBkYXRlIHN0cmluZyBieSBEYXRhIG9iamVjdFxcbiAgICAgKiBAbmFtZSBmb3JtYXREYXRlXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQWJzdHJhY3RUaW1lO1xcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3RcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3V0Yycgb3IgJ2dlbidcXG4gICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoTWlsbGlzIGZsYWcgZm9yIHdpdGggbWlsbGlzZWN0aW9ucyBvciBub3RcXG4gICAgICogQGRlc2NyaXB0aW9uXFxuICAgICAqICd3aXRoTWlsbGlzJyBmbGFnIGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXFxuICAgICAqL1xcbiAgICB0aGlzLmZvcm1hdERhdGUgPSBmdW5jdGlvbiAoZGF0ZU9iamVjdCwgdHlwZSwgd2l0aE1pbGxpcykge1xcbiAgICAgICAgdmFyIHBhZCA9IHRoaXMuemVyb1BhZGRpbmc7XFxuICAgICAgICB2YXIgZCA9IHRoaXMubG9jYWxEYXRlVG9VVEMoZGF0ZU9iamVjdCk7XFxuICAgICAgICB2YXIgeWVhciA9IFN0cmluZyhkLmdldEZ1bGxZZWFyKCkpO1xcbiAgICAgICAgaWYgKHR5cGUgPT0gJ3V0YycpXFxuICAgICAgICAgICAgeWVhciA9IHllYXIuc3Vic3RyKDIsIDIpO1xcbiAgICAgICAgdmFyIG1vbnRoID0gcGFkKFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKSwgMik7XFxuICAgICAgICB2YXIgZGF5ID0gcGFkKFN0cmluZyhkLmdldERhdGUoKSksIDIpO1xcbiAgICAgICAgdmFyIGhvdXIgPSBwYWQoU3RyaW5nKGQuZ2V0SG91cnMoKSksIDIpO1xcbiAgICAgICAgdmFyIG1pbiA9IHBhZChTdHJpbmcoZC5nZXRNaW51dGVzKCkpLCAyKTtcXG4gICAgICAgIHZhciBzZWMgPSBwYWQoU3RyaW5nKGQuZ2V0U2Vjb25kcygpKSwgMik7XFxuICAgICAgICB2YXIgcyA9IHllYXIgKyBtb250aCArIGRheSArIGhvdXIgKyBtaW4gKyBzZWM7XFxuICAgICAgICBpZiAod2l0aE1pbGxpcyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHZhciBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xcbiAgICAgICAgICAgIGlmIChtaWxsaXMgIT0gMCkge1xcbiAgICAgICAgICAgICAgICB2YXIgc01pbGxpcyA9IHBhZChTdHJpbmcobWlsbGlzKSwgMyk7XFxuICAgICAgICAgICAgICAgIHNNaWxsaXMgPSBzTWlsbGlzLnJlcGxhY2UoL1swXSskLywgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICBzID0gcyArIFxcXCIuXFxcIiArIHNNaWxsaXM7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHMgKyBcXFwiWlxcXCI7XFxuICAgIH07XFxuICAgIHRoaXMuemVyb1BhZGRpbmcgPSBmdW5jdGlvbiAocywgbGVuKSB7XFxuICAgICAgICBpZiAocy5sZW5ndGggPj0gbGVuKVxcbiAgICAgICAgICAgIHJldHVybiBzO1xcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShsZW4gLSBzLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHM7XFxuICAgIH07XFxuICAgIC8vIC0tLSBQVUJMSUMgTUVUSE9EUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvKipcXG4gICAgICogZ2V0IHN0cmluZyB2YWx1ZSBvZiB0aGlzIHN0cmluZyBvYmplY3RcXG4gICAgICogQG5hbWUgZ2V0U3RyaW5nXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgdmFsdWUgb2YgdGhpcyB0aW1lIG9iamVjdFxcbiAgICAgKi9cXG4gICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgc3RyaW5nXFxuICAgICAqIEBuYW1lIHNldFN0cmluZ1xcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdTIHZhbHVlIGJ5IGEgc3RyaW5nIHRvIHNldCBzdWNoIGxpa2UgXFxcIjEzMDQzMDIzNTk1OVpcXFwiXFxuICAgICAqL1xcbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uIChuZXdTKSB7XFxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMucyA9IG5ld1M7XFxuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KG5ld1MpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcXG4gICAgICogQG5hbWUgc2V0QnlEYXRlVmFsdWVcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHllYXIgeWVhciBvZiBkYXRlIChleC4gMjAxMylcXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtb250aCBtb250aCBvZiBkYXRlIGJldHdlZW4gMSBhbmQgMTIgKGV4LiAxMilcXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkYXkgZGF5IG9mIG1vbnRoXFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaG91ciBob3VycyBvZiBkYXRlXFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbWluIG1pbnV0ZXMgb2YgZGF0ZVxcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNlYyBzZWNvbmRzIG9mIGRhdGVcXG4gICAgICovXFxuICAgIHRoaXMuc2V0QnlEYXRlVmFsdWUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcXG4gICAgICAgIHZhciBkYXRlT2JqZWN0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKSk7XFxuICAgICAgICB0aGlzLnNldEJ5RGF0ZShkYXRlT2JqZWN0KTtcXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XFxuLy8gPT0gRU5EICAgREVSQWJzdHJhY3RUaW1lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gPT0gQkVHSU4gREVSQWJzdHJhY3RTdHJ1Y3R1cmVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLyoqXFxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cnVjdHVyZWQgY2xhc3NcXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXFxuICogQGNsYXNzIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmVkIGNsYXNzXFxuICogQHByb3BlcnR5IHtBcnJheX0gYXNuMUFycmF5IGludGVybmFsIGFycmF5IG9mIEFTTjFPYmplY3RcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXFxuICovXFxuS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gICAgdmFyIGFzbjFBcnJheSA9IG51bGw7XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgYXJyYXkgb2YgQVNOMU9iamVjdFxcbiAgICAgKiBAbmFtZSBzZXRCeUFTTjFPYmplY3RBcnJheVxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFzbjFPYmplY3RBcnJheSBhcnJheSBvZiBBU04xT2JqZWN0IHRvIHNldFxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRCeUFTTjFPYmplY3RBcnJheSA9IGZ1bmN0aW9uIChhc24xT2JqZWN0QXJyYXkpIHtcXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBhc24xT2JqZWN0QXJyYXk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBhcHBlbmQgYW4gQVNOMU9iamVjdCB0byBpbnRlcm5hbCBhcnJheVxcbiAgICAgKiBAbmFtZSBhcHBlbmRBU04xT2JqZWN0XFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IHRvIGFkZFxcbiAgICAgKi9cXG4gICAgdGhpcy5hcHBlbmRBU04xT2JqZWN0ID0gZnVuY3Rpb24gKGFzbjFPYmplY3QpIHtcXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5hc24xQXJyYXkucHVzaChhc24xT2JqZWN0KTtcXG4gICAgfTtcXG4gICAgdGhpcy5hc24xQXJyYXkgPSBuZXcgQXJyYXkoKTtcXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydhcnJheSddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBwYXJhbXNbJ2FycmF5J107XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vICBBU04uMSBPYmplY3QgQ2xhc3Nlc1xcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEJvb2xlYW5cXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQm9vbGVhblxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEJvb2xlYW5cXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXFxuICovXFxuS0pVUi5hc24xLkRFUkJvb2xlYW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJCb29sZWFuLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIwMVxcXCI7XFxuICAgIHRoaXMuaFRMViA9IFxcXCIwMTAxZmZcXFwiO1xcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkJvb2xlYW4sIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJJbnRlZ2VyXFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgSW50ZWdlclxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XFxuICogQGRlc2NyaXB0aW9uXFxuICogPGJyLz5cXG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXFxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuICogPHVsPlxcbiAqIDxsaT5pbnQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgaW50ZWdlciB2YWx1ZTwvbGk+XFxuICogPGxpPmJpZ2ludCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBCaWdJbnRlZ2VyIG9iamVjdDwvbGk+XFxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cXG4gKi9cXG5LSlVSLmFzbjEuREVSSW50ZWdlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUkludGVnZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgICB0aGlzLmhUID0gXFxcIjAyXFxcIjtcXG4gICAgLyoqXFxuICAgICAqIHNldCB2YWx1ZSBieSBUb20gV3UncyBCaWdJbnRlZ2VyIG9iamVjdFxcbiAgICAgKiBAbmFtZSBzZXRCeUJpZ0ludGVnZXJcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtCaWdJbnRlZ2VyfSBiaWdJbnRlZ2VyVmFsdWUgdG8gc2V0XFxuICAgICAqL1xcbiAgICB0aGlzLnNldEJ5QmlnSW50ZWdlciA9IGZ1bmN0aW9uIChiaWdJbnRlZ2VyVmFsdWUpIHtcXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5oViA9IEtKVVIuYXNuMS5BU04xVXRpbC5iaWdJbnRUb01pblR3b3NDb21wbGVtZW50c0hleChiaWdJbnRlZ2VyVmFsdWUpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcXG4gICAgICogQG5hbWUgc2V0QnlJbnRlZ2VyXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlclxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbnRlZ2VyIHZhbHVlIHRvIHNldFxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbiAoaW50VmFsdWUpIHtcXG4gICAgICAgIHZhciBiaSA9IG5ldyBfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XFxuICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihiaSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXIjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcXG4gICAgICogQGRlc2NyaXB0aW9uXFxuICAgICAqIDxici8+XFxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXFxuICAgICAqIHR3bydzIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24uXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcigxMjMpO1xcbiAgICAgKiBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeydpbnQnOiAxMjN9KTtcXG4gICAgICogbmV3IEtKVVIuYXNuMS5ERVJJbnRlZ2VyKHsnaGV4JzogJzFmYWQnfSk7XFxuICAgICAqL1xcbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24gKG5ld0hleFN0cmluZykge1xcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snYmlnaW50J10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihwYXJhbXNbJ2JpZ2ludCddKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2ludCddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXNbJ2hleCddKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkludGVnZXIsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlZCBCaXRTdHJpbmcgcHJpbWl0aXZlXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUkJpdFN0cmluZ1xcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZWQgQml0U3RyaW5nIHByaW1pdGl2ZVxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XFxuICogQGRlc2NyaXB0aW9uXFxuICogPGJyLz5cXG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXFxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuICogPHVsPlxcbiAqIDxsaT5iaW4gLSBzcGVjaWZ5IGJpbmFyeSBzdHJpbmcgKGV4LiAnMTAxMTEnKTwvbGk+XFxuICogPGxpPmFycmF5IC0gc3BlY2lmeSBhcnJheSBvZiBib29sZWFuIChleC4gW3RydWUsZmFsc2UsdHJ1ZSx0cnVlXSk8L2xpPlxcbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSB2YWx1ZShWKSBpbmNsdWRpbmcgdW51c2VkIGJpdHM8L2xpPlxcbiAqIDxsaT5vYmogLSBzcGVjaWZ5IHtAbGluayBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0fVxcbiAqIGFyZ3VtZW50IGZvciBcXFwiQml0U3RyaW5nIGVuY2Fwc3VsYXRlc1xcXCIgc3RydWN0dXJlLjwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cXG4gKiBOT1RFMjogJ29iaicgcGFyYW1ldGVyIGhhdmUgYmVlbiBzdXBwb3J0ZWQgc2luY2VcXG4gKiBhc24xIDEuMC4xMSwganNyc2FzaWduIDYuMS4xICgyMDE2LVNlcC0yNSkuPGJyLz5cXG4gKiBAZXhhbXBsZVxcbiAqIC8vIGRlZmF1bHQgY29uc3RydWN0b3JcXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcXG4gKiAvLyBpbml0aWFsaXplIHdpdGggYmluYXJ5IHN0cmluZ1xcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7YmluOiBcXFwiMTAxMVxcXCJ9KTtcXG4gKiAvLyBpbml0aWFsaXplIHdpdGggYm9vbGVhbiBhcnJheVxcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7YXJyYXk6IFt0cnVlLGZhbHNlLHRydWUsdHJ1ZV19KTtcXG4gKiAvLyBpbml0aWFsaXplIHdpdGggaGV4YWRlY2ltYWwgc3RyaW5nICgwNCBpcyB1bnVzZWQgYml0cylcXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7aGV4OiBcXFwiMDRiYWMwXFxcIn0pO1xcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBBU04xVXRpbC5uZXdPYmplY3QgYXJndW1lbnQgZm9yIGVuY2Fwc3VsYXRlZFxcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7b2JqOiB7c2VxOiBbe2ludDogM30sIHtwcm5zdHI6ICdhYWEnfV19fSk7XFxuICogLy8gYWJvdmUgZ2VuZXJhdGVzIGEgQVNOLjEgZGF0YSBsaWtlIHRoaXM6XFxuICogLy8gQklUIFNUUklORywgZW5jYXBzdWxhdGVzIHtcXG4gKiAvLyAgIFNFUVVFTkNFIHtcXG4gKiAvLyAgICAgSU5URUdFUiAzXFxuICogLy8gICAgIFByaW50YWJsZVN0cmluZyAnYWFhJ1xcbiAqIC8vICAgICB9XFxuICogLy8gICB9XFxuICovXFxuS0pVUi5hc24xLkRFUkJpdFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMub2JqICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgdmFyIG8gPSBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0KHBhcmFtcy5vYmopO1xcbiAgICAgICAgcGFyYW1zLmhleCA9IFxcXCIwMFxcXCIgKyBvLmdldEVuY29kZWRIZXgoKTtcXG4gICAgfVxcbiAgICBLSlVSLmFzbjEuREVSQml0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIwM1xcXCI7XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5jbHVkaW5nIHVudXNlZCBiaXRzXFxuICAgICAqIEBuYW1lIHNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0c1xcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzXFxuICAgICAqL1xcbiAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyA9IGZ1bmN0aW9uIChuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzKSB7XFxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmdJbmNsdWRpbmdVbnVzZWRCaXRzO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IEFTTi4xIHZhbHVlKFYpIGJ5IHVudXNlZCBiaXQgYW5kIGhleGFkZWNpbWFsIHN0cmluZyBvZiB2YWx1ZVxcbiAgICAgKiBAbmFtZSBzZXRVbnVzZWRCaXRzQW5kSGV4VmFsdWVcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHVudXNlZEJpdHNcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhWYWx1ZVxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRVbnVzZWRCaXRzQW5kSGV4VmFsdWUgPSBmdW5jdGlvbiAodW51c2VkQml0cywgaFZhbHVlKSB7XFxuICAgICAgICBpZiAodW51c2VkQml0cyA8IDAgfHwgNyA8IHVudXNlZEJpdHMpIHtcXG4gICAgICAgICAgICB0aHJvdyBcXFwidW51c2VkIGJpdHMgc2hhbGwgYmUgZnJvbSAwIHRvIDc6IHUgPSBcXFwiICsgdW51c2VkQml0cztcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBoVW51c2VkQml0cyA9IFxcXCIwXFxcIiArIHVudXNlZEJpdHM7XFxuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuaFYgPSBoVW51c2VkQml0cyArIGhWYWx1ZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHNldCBBU04uMSBERVIgQml0U3RyaW5nIGJ5IGJpbmFyeSBzdHJpbmc8YnIvPlxcbiAgICAgKiBAbmFtZSBzZXRCeUJpbmFyeVN0cmluZ1xcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiaW5hcnlTdHJpbmcgYmluYXJ5IHZhbHVlIHN0cmluZyAoaS5lLiAnMTAxMTEnKVxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogSXRzIHVudXNlZCBiaXRzIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IGxlbmd0aCBvZlxcbiAgICAgKiAnYmluYXJ5VmFsdWUnLiA8YnIvPlxcbiAgICAgKiBOT1RFOiBUcmFpbGluZyB6ZXJvcyAnMCcgd2lsbCBiZSBpZ25vcmVkLlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcXG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShcXFwiMDEwMTFcXFwiKTtcXG4gICAgICovXFxuICAgIHRoaXMuc2V0QnlCaW5hcnlTdHJpbmcgPSBmdW5jdGlvbiAoYmluYXJ5U3RyaW5nKSB7XFxuICAgICAgICBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmcucmVwbGFjZSgvMCskLywgJycpO1xcbiAgICAgICAgdmFyIHVudXNlZEJpdHMgPSA4IC0gYmluYXJ5U3RyaW5nLmxlbmd0aCAlIDg7XFxuICAgICAgICBpZiAodW51c2VkQml0cyA9PSA4KVxcbiAgICAgICAgICAgIHVudXNlZEJpdHMgPSAwO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdW51c2VkQml0czsgaSsrKSB7XFxuICAgICAgICAgICAgYmluYXJ5U3RyaW5nICs9ICcwJztcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBoID0gJyc7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGggLSAxOyBpICs9IDgpIHtcXG4gICAgICAgICAgICB2YXIgYiA9IGJpbmFyeVN0cmluZy5zdWJzdHIoaSwgOCk7XFxuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludChiLCAyKS50b1N0cmluZygxNik7XFxuICAgICAgICAgICAgaWYgKHgubGVuZ3RoID09IDEpXFxuICAgICAgICAgICAgICAgIHggPSAnMCcgKyB4O1xcbiAgICAgICAgICAgIGggKz0geDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5oViA9ICcwJyArIHVudXNlZEJpdHMgKyBoO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IEFTTi4xIFRMViB2YWx1ZShWKSBieSBhbiBhcnJheSBvZiBib29sZWFuPGJyLz5cXG4gICAgICogQG5hbWUgc2V0QnlCb29sZWFuQXJyYXlcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBib29sZWFuQXJyYXkgYXJyYXkgb2YgYm9vbGVhbiAoZXguIFt0cnVlLCBmYWxzZSwgdHJ1ZV0pXFxuICAgICAqIEBkZXNjcmlwdGlvblxcbiAgICAgKiBOT1RFOiBUcmFpbGluZyBmYWxzZXMgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBBU04uMSBERVIgT2JqZWN0LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcXG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShbZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlXSk7XFxuICAgICAqL1xcbiAgICB0aGlzLnNldEJ5Qm9vbGVhbkFycmF5ID0gZnVuY3Rpb24gKGJvb2xlYW5BcnJheSkge1xcbiAgICAgICAgdmFyIHMgPSAnJztcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhbkFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKGJvb2xlYW5BcnJheVtpXSA9PSB0cnVlKSB7XFxuICAgICAgICAgICAgICAgIHMgKz0gJzEnO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcyArPSAnMCc7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhzKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdlbmVyYXRlIGFuIGFycmF5IG9mIGZhbHNlcyB3aXRoIHNwZWNpZmllZCBsZW5ndGg8YnIvPlxcbiAgICAgKiBAbmFtZSBuZXdGYWxzZUFycmF5XFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG5MZW5ndGggbGVuZ3RoIG9mIGFycmF5IHRvIGdlbmVyYXRlXFxuICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBib29sZWFuIGZhbHNlc1xcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIG1heSBiZSB1c2VmdWwgdG8gaW5pdGlhbGl6ZSBib29sZWFuIGFycmF5LlxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcXG4gICAgICogby5uZXdGYWxzZUFycmF5KDMpICZyYXJyOyBbZmFsc2UsIGZhbHNlLCBmYWxzZV1cXG4gICAgICovXFxuICAgIHRoaXMubmV3RmFsc2VBcnJheSA9IGZ1bmN0aW9uIChuTGVuZ3RoKSB7XFxuICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShuTGVuZ3RoKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYVtpXSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgIH07XFxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xcbiAgICB9O1xcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXFxcInN0cmluZ1xcXCIgJiYgcGFyYW1zLnRvTG93ZXJDYXNlKCkubWF0Y2goL15bMC05YS1mXSskLykpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyhwYXJhbXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyhwYXJhbXNbJ2hleCddKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2JpbiddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyhwYXJhbXNbJ2JpbiddKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2FycmF5J10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEJ5Qm9vbGVhbkFycmF5KHBhcmFtc1snYXJyYXknXSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgT2N0ZXRTdHJpbmc8YnIvPlxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZ1xcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE9jdGV0U3RyaW5nXFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIEFTTi4xIE9jdGV0U3RyaW5nIHNpbXBsZSB0eXBlLjxici8+XFxuICogU3VwcG9ydGVkIFxcXCJwYXJhbXNcXFwiIGF0dHJpYnV0ZXMgYXJlOlxcbiAqIDx1bD5cXG4gKiA8bGk+c3RyIC0gdG8gc2V0IGEgc3RyaW5nIGFzIGEgdmFsdWU8L2xpPlxcbiAqIDxsaT5oZXggLSB0byBzZXQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgYXMgYSB2YWx1ZTwvbGk+XFxuICogPGxpPm9iaiAtIHRvIHNldCBhIGVuY2Fwc3VsYXRlZCBBU04uMSB2YWx1ZSBieSBKU09OIG9iamVjdFxcbiAqIHdoaWNoIGlzIGRlZmluZWQgaW4ge0BsaW5rIEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3R9PC9saT5cXG4gKiA8L3VsPlxcbiAqIE5PVEU6IEEgcGFyYW1ldGVyICdvYmonIGhhdmUgYmVlbiBzdXBwb3J0ZWRcXG4gKiBmb3IgXFxcIk9DVEVUIFNUUklORywgZW5jYXBzdWxhdGVzXFxcIiBzdHJ1Y3R1cmUuXFxuICogc2luY2UgYXNuMSAxLjAuMTEsIGpzcnNhc2lnbiA2LjEuMSAoMjAxNi1TZXAtMjUpLlxcbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xcbiAqIEBleGFtcGxlXFxuICogLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKCk7XFxuICogLy8gaW5pdGlhbGl6ZSB3aXRoIHN0cmluZ1xcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtzdHI6IFxcXCJhYWFcXFwifSk7XFxuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGhleGFkZWNpbWFsIHN0cmluZ1xcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtoZXg6IFxcXCI2MTYxNjFcXFwifSk7XFxuICogLy8gaW5pdGlhbGl6ZSB3aXRoIEFTTjFVdGlsLm5ld09iamVjdCBhcmd1bWVudFxcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKHtvYmo6IHtzZXE6IFt7aW50OiAzfSwge3BybnN0cjogJ2FhYSd9XX19KTtcXG4gKiAvLyBhYm92ZSBnZW5lcmF0ZXMgYSBBU04uMSBkYXRhIGxpa2UgdGhpczpcXG4gKiAvLyBPQ1RFVCBTVFJJTkcsIGVuY2Fwc3VsYXRlcyB7XFxuICogLy8gICBTRVFVRU5DRSB7XFxuICogLy8gICAgIElOVEVHRVIgM1xcbiAqIC8vICAgICBQcmludGFibGVTdHJpbmcgJ2FhYSdcXG4gKiAvLyAgICAgfVxcbiAqIC8vICAgfVxcbiAqL1xcbktKVVIuYXNuMS5ERVJPY3RldFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJhbXMub2JqICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgdmFyIG8gPSBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0KHBhcmFtcy5vYmopO1xcbiAgICAgICAgcGFyYW1zLmhleCA9IG8uZ2V0RW5jb2RlZEhleCgpO1xcbiAgICB9XFxuICAgIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIwNFxcXCI7XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSTnVsbFxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE51bGxcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXFxuICovXFxuS0pVUi5hc24xLkRFUk51bGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJOdWxsLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIwNVxcXCI7XFxuICAgIHRoaXMuaFRMViA9IFxcXCIwNTAwXFxcIjtcXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdWxsLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllclxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnb2lkJzogJzIuNS40LjUnfSlcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIDxici8+XFxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxcbiAqIDx1bD5cXG4gKiA8bGk+b2lkIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgb2lkIHN0cmluZyAoZXguIDIuNS40LjEzKTwvbGk+XFxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cXG4gKi9cXG5LSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgdmFyIGl0b3ggPSBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgdmFyIGggPSBpLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgIGlmIChoLmxlbmd0aCA9PSAxKVxcbiAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcbiAgICAgICAgcmV0dXJuIGg7XFxuICAgIH07XFxuICAgIHZhciByb2lkdG94ID0gZnVuY3Rpb24gKHJvaWQpIHtcXG4gICAgICAgIHZhciBoID0gJyc7XFxuICAgICAgICB2YXIgYmkgPSBuZXcgX2pzYm5fanNibl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkJpZ0ludGVnZXIocm9pZCwgMTApO1xcbiAgICAgICAgdmFyIGIgPSBiaS50b1N0cmluZygyKTtcXG4gICAgICAgIHZhciBwYWRMZW4gPSA3IC0gYi5sZW5ndGggJSA3O1xcbiAgICAgICAgaWYgKHBhZExlbiA9PSA3KVxcbiAgICAgICAgICAgIHBhZExlbiA9IDA7XFxuICAgICAgICB2YXIgYlBhZCA9ICcnO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW47IGkrKylcXG4gICAgICAgICAgICBiUGFkICs9ICcwJztcXG4gICAgICAgIGIgPSBiUGFkICsgYjtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGggLSAxOyBpICs9IDcpIHtcXG4gICAgICAgICAgICB2YXIgYjggPSBiLnN1YnN0cihpLCA3KTtcXG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpXFxuICAgICAgICAgICAgICAgIGI4ID0gJzEnICsgYjg7XFxuICAgICAgICAgICAgaCArPSBpdG94KHBhcnNlSW50KGI4LCAyKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaDtcXG4gICAgfTtcXG4gICAgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgICB0aGlzLmhUID0gXFxcIjA2XFxcIjtcXG4gICAgLyoqXFxuICAgICAqIHNldCB2YWx1ZSBieSBhIGhleGFkZWNpbWFsIHN0cmluZ1xcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nIGhleGFkZWNpbWFsIHZhbHVlIG9mIE9JRCBieXRlc1xcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRWYWx1ZUhleCA9IGZ1bmN0aW9uIChuZXdIZXhTdHJpbmcpIHtcXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcXG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBPSUQgc3RyaW5nPGJyLz5cXG4gICAgICogQG5hbWUgc2V0VmFsdWVPaWRTdHJpbmdcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9pZFN0cmluZyBPSUQgc3RyaW5nIChleC4gMi41LjQuMTMpXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoKTtcXG4gICAgICogby5zZXRWYWx1ZU9pZFN0cmluZyhcXFwiMi41LjQuMTNcXFwiKTtcXG4gICAgICovXFxuICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcgPSBmdW5jdGlvbiAob2lkU3RyaW5nKSB7XFxuICAgICAgICBpZiAoIW9pZFN0cmluZy5tYXRjaCgvXlswLTkuXSskLykpIHtcXG4gICAgICAgICAgICB0aHJvdyBcXFwibWFsZm9ybWVkIG9pZCBzdHJpbmc6IFxcXCIgKyBvaWRTdHJpbmc7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgaCA9ICcnO1xcbiAgICAgICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcXG4gICAgICAgIHZhciBpMCA9IHBhcnNlSW50KGFbMF0pICogNDAgKyBwYXJzZUludChhWzFdKTtcXG4gICAgICAgIGggKz0gaXRveChpMCk7XFxuICAgICAgICBhLnNwbGljZSgwLCAyKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGggKz0gcm9pZHRveChhW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcXG4gICAgICAgIHRoaXMuaFYgPSBoO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgT0lEIG5hbWVcXG4gICAgICogQG5hbWUgc2V0VmFsdWVOYW1lXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvaWROYW1lIE9JRCBuYW1lIChleC4gJ3NlcnZlckF1dGgnKVxcbiAgICAgKiBAc2luY2UgMS4wLjFcXG4gICAgICogQGRlc2NyaXB0aW9uXFxuICAgICAqIE9JRCBuYW1lIHNoYWxsIGJlIGRlZmluZWQgaW4gJ0tKVVIuYXNuMS54NTA5Lk9JRC5uYW1lMm9pZExpc3QnLlxcbiAgICAgKiBPdGhlcndpc2UgcmFpc2UgZXJyb3IuXFxuICAgICAqIEBleGFtcGxlXFxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoKTtcXG4gICAgICogby5zZXRWYWx1ZU5hbWUoXFxcInNlcnZlckF1dGhcXFwiKTtcXG4gICAgICovXFxuICAgIHRoaXMuc2V0VmFsdWVOYW1lID0gZnVuY3Rpb24gKG9pZE5hbWUpIHtcXG4gICAgICAgIHZhciBvaWQgPSBLSlVSLmFzbjEueDUwOS5PSUQubmFtZTJvaWQob2lkTmFtZSk7XFxuICAgICAgICBpZiAob2lkICE9PSAnJykge1xcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcob2lkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRocm93IFxcXCJERVJPYmplY3RJZGVudGlmaWVyIG9pZE5hbWUgdW5kZWZpbmVkOiBcXFwiICsgb2lkTmFtZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKHBhcmFtcy5tYXRjaCgvXlswLTJdLlswLTkuXSskLykpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU9pZFN0cmluZyhwYXJhbXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZU5hbWUocGFyYW1zKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChwYXJhbXMub2lkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nKHBhcmFtcy5vaWQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmhleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXMuaGV4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlTmFtZShwYXJhbXMubmFtZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSRW51bWVyYXRlZFxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEVudW1lcmF0ZWRcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIDxici8+XFxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxcbiAqIDx1bD5cXG4gKiA8bGk+aW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGludGVnZXIgdmFsdWU8L2xpPlxcbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxcbiAqIDwvdWw+XFxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXFxuICogQGV4YW1wbGVcXG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoMTIzKTtcXG4gKiBuZXcgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQoe2ludDogMTIzfSk7XFxuICogbmV3IEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkKHtoZXg6ICcxZmFkJ30pO1xcbiAqL1xcbktKVVIuYXNuMS5ERVJFbnVtZXJhdGVkID0gZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICBLSlVSLmFzbjEuREVSRW51bWVyYXRlZC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiMGFcXFwiO1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IFRvbSBXdSdzIEJpZ0ludGVnZXIgb2JqZWN0XFxuICAgICAqIEBuYW1lIHNldEJ5QmlnSW50ZWdlclxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IGJpZ0ludGVnZXJWYWx1ZSB0byBzZXRcXG4gICAgICovXFxuICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyID0gZnVuY3Rpb24gKGJpZ0ludGVnZXJWYWx1ZSkge1xcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcXG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XFxuICAgICAgICB0aGlzLmhWID0gS0pVUi5hc24xLkFTTjFVdGlsLmJpZ0ludFRvTWluVHdvc0NvbXBsZW1lbnRzSGV4KGJpZ0ludGVnZXJWYWx1ZSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxcbiAgICAgKiBAbmFtZSBzZXRCeUludGVnZXJcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbnRlZ2VyIHZhbHVlIHRvIHNldFxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRCeUludGVnZXIgPSBmdW5jdGlvbiAoaW50VmFsdWUpIHtcXG4gICAgICAgIHZhciBiaSA9IG5ldyBfanNibl9qc2JuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uQmlnSW50ZWdlcihTdHJpbmcoaW50VmFsdWUpLCAxMCk7XFxuICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihiaSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgaW50ZWdlciB2YWx1ZVxcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGludGVnZXIgdmFsdWVcXG4gICAgICogQGRlc2NyaXB0aW9uXFxuICAgICAqIDxici8+XFxuICAgICAqIE5PVEU6IFZhbHVlIHNoYWxsIGJlIHJlcHJlc2VudGVkIGJ5IG1pbmltdW0gb2N0ZXQgbGVuZ3RoIG9mXFxuICAgICAqIHR3bydzIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24uXFxuICAgICAqL1xcbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24gKG5ld0hleFN0cmluZykge1xcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXNbJ2ludCddKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KHBhcmFtc1snaGV4J10pO1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSRW51bWVyYXRlZCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuLyoqXFxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBVVEY4U3RyaW5nXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlVURjhTdHJpbmdcXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBVVEY4U3RyaW5nXFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcXG4gKi9cXG5LSlVSLmFzbjEuREVSVVRGOFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUlVURjhTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiMGNcXFwiO1xcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlVURjhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZ1xcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIE51bWVyaWNTdHJpbmdcXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xcbiAqL1xcbktKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIxMlxcXCI7XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgUHJpbnRhYmxlU3RyaW5nXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZ1xcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFByaW50YWJsZVN0cmluZ1xcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXFxuICogQGRlc2NyaXB0aW9uXFxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXFxuICovXFxuS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIxM1xcXCI7XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuLyoqXFxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBUZWxldGV4U3RyaW5nXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmdcXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBUZWxldGV4U3RyaW5nXFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcXG4gKi9cXG5LSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiMTRcXFwiO1xcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIElBNVN0cmluZ1xcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmdcXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBJQTVTdHJpbmdcXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xcbiAqIEBkZXNjcmlwdGlvblxcbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xcbiAqL1xcbktKVVIuYXNuMS5ERVJJQTVTdHJpbmcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiMTZcXFwiO1xcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUklBNVN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJVVENUaW1lXFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgVVRDVGltZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMTMwNDMwMjM1OTU5Wid9KVxcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiA8YnIvPlxcbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcXG4gKiA8dWw+XFxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZyAoZXguJzEzMDQzMDIzNTk1OVonKTwvbGk+XFxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XFxuICogPGxpPmRhdGUgLSBzcGVjaWZ5IERhdGUgb2JqZWN0LjwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cXG4gKiA8aDQ+RVhBTVBMRVM8L2g0PlxcbiAqIEBleGFtcGxlXFxuICogZDEgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoKTtcXG4gKiBkMS5zZXRTdHJpbmcoJzEzMDQzMDEyNTk1OVonKTtcXG4gKlxcbiAqIGQyID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKHsnc3RyJzogJzEzMDQzMDEyNTk1OVonfSk7XFxuICogZDMgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoeydkYXRlJzogbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDAsIDAsIDAsIDApKX0pO1xcbiAqIGQ0ID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCcxMzA0MzAxMjU5NTlaJyk7XFxuICovXFxuS0pVUi5hc24xLkRFUlVUQ1RpbWUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJVVENUaW1lLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xcbiAgICB0aGlzLmhUID0gXFxcIjE3XFxcIjtcXG4gICAgLyoqXFxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0PGJyLz5cXG4gICAgICogQG5hbWUgc2V0QnlEYXRlXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSVVRDVGltZSNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZU9iamVjdCBEYXRlIG9iamVjdCB0byBzZXQgQVNOLjEgdmFsdWUoVilcXG4gICAgICogQGV4YW1wbGVcXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgpO1xcbiAgICAgKiBvLnNldEJ5RGF0ZShuZXcgRGF0ZShcXFwiMjAxNi8xMi8zMVxcXCIpKTtcXG4gICAgICovXFxuICAgIHRoaXMuc2V0QnlEYXRlID0gZnVuY3Rpb24gKGRhdGVPYmplY3QpIHtcXG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XFxuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZU9iamVjdDtcXG4gICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICd1dGMnKTtcXG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGUgPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgdHlwZW9mIHRoaXMucyA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XFxuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ3V0YycpO1xcbiAgICAgICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xcbiAgICB9O1xcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmIChwYXJhbXMuc3RyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMuc3RyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXFxcInN0cmluZ1xcXCIgJiYgcGFyYW1zLm1hdGNoKC9eWzAtOV17MTJ9WiQvKSkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuaGV4ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZ0hleChwYXJhbXMuaGV4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5kYXRlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldEJ5RGF0ZShwYXJhbXMuZGF0ZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJVVENUaW1lLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lKTtcXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8qKlxcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWRUaW1lXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZVxcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkVGltZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMjAxMzA0MzAyMzU5NTlaJ30pXFxuICogQHByb3BlcnR5IHtCb29sZWFufSB3aXRoTWlsbGlzIGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgb3Igbm90XFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIDxici8+XFxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxcbiAqIDx1bD5cXG4gKiA8bGk+c3RyIC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgc3RyaW5nIChleC4nMjAxMzA0MzAyMzU5NTlaJyk8L2xpPlxcbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxcbiAqIDxsaT5kYXRlIC0gc3BlY2lmeSBEYXRlIG9iamVjdC48L2xpPlxcbiAqIDxsaT5taWxsaXMgLSBzcGVjaWZ5IGZsYWcgdG8gc2hvdyBtaWxsaXNlY29uZHMgKGZyb20gMS4wLjYpPC9saT5cXG4gKiA8L3VsPlxcbiAqIE5PVEUxOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cXG4gKiBOT1RFMjogJ3dpdGhNaWxsaXMnIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXFxuICovXFxuS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIxOFxcXCI7XFxuICAgIHRoaXMud2l0aE1pbGxpcyA9IGZhbHNlO1xcbiAgICAvKipcXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcXG4gICAgICogQG5hbWUgc2V0QnlEYXRlXFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lI1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0IERhdGUgb2JqZWN0IHRvIHNldCBBU04uMSB2YWx1ZShWKVxcbiAgICAgKiBAZXhhbXBsZVxcbiAgICAgKiBXaGVuIHlvdSBzcGVjaWZ5IFVUQyB0aW1lLCB1c2UgJ0RhdGUuVVRDJyBtZXRob2QgbGlrZSB0aGlzOjxici8+XFxuICAgICAqIG8xID0gbmV3IERFUlVUQ1RpbWUoKTtcXG4gICAgICogbzEuc2V0QnlEYXRlKGRhdGUpO1xcbiAgICAgKlxcbiAgICAgKiBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMjAxNSwgMCwgMzEsIDIzLCA1OSwgNTksIDApKTsgIzIwMTVKQU4zMSAyMzo1OTo1OVxcbiAgICAgKi9cXG4gICAgdGhpcy5zZXRCeURhdGUgPSBmdW5jdGlvbiAoZGF0ZU9iamVjdCkge1xcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcXG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XFxuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlT2JqZWN0O1xcbiAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XFxuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XFxuICAgIH07XFxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0aGlzLmRhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XFxuICAgICAgICAgICAgdGhpcy5zID0gdGhpcy5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgJ2dlbicsIHRoaXMud2l0aE1pbGxpcyk7XFxuICAgICAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgaWYgKHBhcmFtcy5zdHIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcy5zdHIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcXFwic3RyaW5nXFxcIiAmJiBwYXJhbXMubWF0Y2goL15bMC05XXsxNH1aJC8pKSB7XFxuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nSGV4KHBhcmFtcy5oZXgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmRhdGUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRoaXMuc2V0QnlEYXRlKHBhcmFtcy5kYXRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXJhbXMubWlsbGlzID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgdGhpcy53aXRoTWlsbGlzID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNlcXVlbmNlXFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlNlcXVlbmNlXFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgU2VxdWVuY2VcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXFxuICogQGRlc2NyaXB0aW9uXFxuICogPGJyLz5cXG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXFxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuICogPHVsPlxcbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cXG4gKi9cXG5LSlVSLmFzbjEuREVSU2VxdWVuY2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gICAgdGhpcy5oVCA9IFxcXCIzMFxcXCI7XFxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBoID0gJyc7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXNuMUFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIGFzbjFPYmogPSB0aGlzLmFzbjFBcnJheVtpXTtcXG4gICAgICAgICAgICBoICs9IGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5oViA9IGg7XFxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcXG4gICAgfTtcXG59O1xcbl95YWhvb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNldFxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJTZXRcXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBTZXRcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXFxuICogQGRlc2NyaXB0aW9uXFxuICogPGJyLz5cXG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXFxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuICogPHVsPlxcbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XFxuICogPGxpPnNvcnRmbGFnIC0gZmxhZyBmb3Igc29ydCAoZGVmYXVsdDogdHJ1ZSkuIEFTTi4xIEJFUiBpcyBub3Qgc29ydGVkIGluICdTRVQgT0YnLjwvbGk+XFxuICogPC91bD5cXG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cXG4gKiBOT1RFMjogc29ydGZsYWcgaXMgc3VwcG9ydGVkIHNpbmNlIDEuMC41LlxcbiAqL1xcbktKVVIuYXNuMS5ERVJTZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIEtKVVIuYXNuMS5ERVJTZXQuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiMzFcXFwiO1xcbiAgICB0aGlzLnNvcnRGbGFnID0gdHJ1ZTsgLy8gaXRlbSBzaGFsbCBiZSBzb3J0ZWQgb25seSBpbiBBU04uMSBERVJcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hc24xQXJyYXkubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICB2YXIgYXNuMU9iaiA9IHRoaXMuYXNuMUFycmF5W2ldO1xcbiAgICAgICAgICAgIGEucHVzaChhc24xT2JqLmdldEVuY29kZWRIZXgoKSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5zb3J0RmxhZyA9PSB0cnVlKVxcbiAgICAgICAgICAgIGEuc29ydCgpO1xcbiAgICAgICAgdGhpcy5oViA9IGEuam9pbignJyk7XFxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcXG4gICAgfTtcXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnNvcnRmbGFnICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmXFxuICAgICAgICAgICAgcGFyYW1zLnNvcnRmbGFnID09IGZhbHNlKVxcbiAgICAgICAgICAgIHRoaXMuc29ydEZsYWcgPSBmYWxzZTtcXG4gICAgfVxcbn07XFxuX3lhaG9vX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlNldCwgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCk7XFxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vKipcXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFRhZ2dlZE9iamVjdFxcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3RcXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBUYWdnZWRPYmplY3RcXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIDxici8+XFxuICogUGFyYW1ldGVyICd0YWdOb05leCcgaXMgQVNOLjEgdGFnKFQpIHZhbHVlIGZvciB0aGlzIG9iamVjdC5cXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGZpbmQgJ1sxXScgdGFnIGluIGEgQVNOLjEgZHVtcCxcXG4gKiAndGFnTm9IZXgnIHdpbGwgYmUgJ2ExJy5cXG4gKiA8YnIvPlxcbiAqIEFzIGZvciBvcHRpb25hbCBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSAqQU5ZKiBvZlxcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxcbiAqIDx1bD5cXG4gKiA8bGk+ZXhwbGljaXQgLSBzcGVjaWZ5IHRydWUgaWYgdGhpcyBpcyBleHBsaWNpdCB0YWcgb3RoZXJ3aXNlIGZhbHNlXFxuICogICAgIChkZWZhdWx0IGlzICd0cnVlJykuPC9saT5cXG4gKiA8bGk+dGFnIC0gc3BlY2lmeSB0YWcgKGRlZmF1bHQgaXMgJ2EwJyB3aGljaCBtZWFucyBbMF0pPC9saT5cXG4gKiA8bGk+b2JqIC0gc3BlY2lmeSBBU04xT2JqZWN0IHdoaWNoIGlzIHRhZ2dlZDwvbGk+XFxuICogPC91bD5cXG4gKiBAZXhhbXBsZVxcbiAqIGQxID0gbmV3IEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nKHsnc3RyJzonYSd9KTtcXG4gKiBkMiA9IG5ldyBLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0KHsnb2JqJzogZDF9KTtcXG4gKiBoZXggPSBkMi5nZXRFbmNvZGVkSGV4KCk7XFxuICovXFxuS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICAgIHRoaXMuaFQgPSBcXFwiYTBcXFwiO1xcbiAgICB0aGlzLmhWID0gJyc7XFxuICAgIHRoaXMuaXNFeHBsaWNpdCA9IHRydWU7XFxuICAgIHRoaXMuYXNuMU9iamVjdCA9IG51bGw7XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdmFsdWUgYnkgYW4gQVNOMU9iamVjdFxcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QjXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRXhwbGljaXRGbGFnIGZsYWcgZm9yIGV4cGxpY2l0L2ltcGxpY2l0IHRhZ1xcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRhZ05vSGV4IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSB0YWdcXG4gICAgICogQHBhcmFtIHtBU04xT2JqZWN0fSBhc24xT2JqZWN0IEFTTi4xIHRvIGVuY2Fwc3VsYXRlXFxuICAgICAqL1xcbiAgICB0aGlzLnNldEFTTjFPYmplY3QgPSBmdW5jdGlvbiAoaXNFeHBsaWNpdEZsYWcsIHRhZ05vSGV4LCBhc24xT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmhUID0gdGFnTm9IZXg7XFxuICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSBpc0V4cGxpY2l0RmxhZztcXG4gICAgICAgIHRoaXMuYXNuMU9iamVjdCA9IGFzbjFPYmplY3Q7XFxuICAgICAgICBpZiAodGhpcy5pc0V4cGxpY2l0KSB7XFxuICAgICAgICAgICAgdGhpcy5oViA9IHRoaXMuYXNuMU9iamVjdC5nZXRFbmNvZGVkSGV4KCk7XFxuICAgICAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcXG4gICAgICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5oViA9IG51bGw7XFxuICAgICAgICAgICAgdGhpcy5oVExWID0gYXNuMU9iamVjdC5nZXRFbmNvZGVkSGV4KCk7XFxuICAgICAgICAgICAgdGhpcy5oVExWID0gdGhpcy5oVExWLnJlcGxhY2UoL14uLi8sIHRhZ05vSGV4KTtcXG4gICAgICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XFxuICAgIH07XFxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1sndGFnJ10gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLmhUID0gcGFyYW1zWyd0YWcnXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydleHBsaWNpdCddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gcGFyYW1zWydleHBsaWNpdCddO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ29iaiddICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5hc24xT2JqZWN0ID0gcGFyYW1zWydvYmonXTtcXG4gICAgICAgICAgICB0aGlzLnNldEFTTjFPYmplY3QodGhpcy5pc0V4cGxpY2l0LCB0aGlzLmhULCB0aGlzLmFzbjFPYmplY3QpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufTtcXG5feWFob29fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0LCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9qc3JzYXNpZ24vYXNuMS0xLjAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2xpYi9saWIvanNyc2FzaWduL3lhaG9vLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9saWIvbGliL2pzcnNhc2lnbi95YWhvby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJZQUhPT1xcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFlBSE9PKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIVxcbkNvcHlyaWdodCAoYykgMjAxMSwgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5Db2RlIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZTpcXG5odHRwOi8vZGV2ZWxvcGVyLnlhaG9vLmNvbS95dWkvbGljZW5zZS5odG1sXFxudmVyc2lvbjogMi45LjBcXG4qL1xcbnZhciBZQUhPTyA9IHt9O1xcbllBSE9PLmxhbmcgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBVdGlsaXR5IHRvIHNldCB1cCB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvXFxuICAgICAqIHN1cHBvcnQgYW4gaW5oZXJpdGFuY2Ugc3RyYXRlZ3kgdGhhdCBjYW4gY2hhaW4gY29uc3RydWN0b3JzIGFuZCBtZXRob2RzLlxcbiAgICAgKiBTdGF0aWMgbWVtYmVycyB3aWxsIG5vdCBiZSBpbmhlcml0ZWQuXFxuICAgICAqXFxuICAgICAqIEBtZXRob2QgZXh0ZW5kXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViYyAgIHRoZSBvYmplY3QgdG8gbW9kaWZ5XFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyYyB0aGUgb2JqZWN0IHRvIGluaGVyaXRcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAgYWRkaXRpb25hbCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gYWRkIHRvIHRoZVxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNsYXNzIHByb3RvdHlwZS4gIFRoZXNlIHdpbGwgb3ZlcnJpZGUgdGhlXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcgaXRlbXMgb2J0YWluZWQgZnJvbSB0aGUgc3VwZXJjbGFzc1xcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHByZXNlbnQuXFxuICAgICAqL1xcbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzdWJjLCBzdXBlcmMsIG92ZXJyaWRlcykge1xcbiAgICAgICAgaWYgKCFzdXBlcmMgfHwgIXN1YmMpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIllBSE9PLmxhbmcuZXh0ZW5kIGZhaWxlZCwgcGxlYXNlIGNoZWNrIHRoYXQgXFxcIiArXFxuICAgICAgICAgICAgICAgIFxcXCJhbGwgZGVwZW5kZW5jaWVzIGFyZSBpbmNsdWRlZC5cXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkgeyB9O1xcbiAgICAgICAgRi5wcm90b3R5cGUgPSBzdXBlcmMucHJvdG90eXBlO1xcbiAgICAgICAgc3ViYy5wcm90b3R5cGUgPSBuZXcgRigpO1xcbiAgICAgICAgc3ViYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJjO1xcbiAgICAgICAgc3ViYy5zdXBlcmNsYXNzID0gc3VwZXJjLnByb3RvdHlwZTtcXG4gICAgICAgIGlmIChzdXBlcmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcXG4gICAgICAgICAgICBzdXBlcmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3VwZXJjO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xcbiAgICAgICAgICAgIHZhciBpO1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBvdmVycmlkZXMpIHtcXG4gICAgICAgICAgICAgICAgc3ViYy5wcm90b3R5cGVbaV0gPSBvdmVycmlkZXNbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8qXFxuICAgICAgICAgICAgICogSUUgd2lsbCBub3QgZW51bWVyYXRlIG5hdGl2ZSBmdW5jdGlvbnMgaW4gYSBkZXJpdmVkIG9iamVjdCBldmVuIGlmIHRoZVxcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIHdhcyBvdmVycmlkZGVuLiAgVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHNwZWNpZmljIGZ1bmN0aW9uc1xcbiAgICAgICAgICAgICAqIHdlIGNhcmUgYWJvdXQgb24gdGhlIE9iamVjdCBwcm90b3R5cGUuXFxuICAgICAgICAgICAgICogQHByb3BlcnR5IF9JRUVudW1GaXhcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByICB0aGUgb2JqZWN0IHRvIHJlY2VpdmUgdGhlIGF1Z21lbnRhdGlvblxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHMgIHRoZSBvYmplY3QgdGhhdCBzdXBwbGllcyB0aGUgcHJvcGVydGllcyB0byBhdWdtZW50XFxuICAgICAgICAgICAgICogQHN0YXRpY1xcbiAgICAgICAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgdmFyIF9JRUVudW1GaXggPSBmdW5jdGlvbiAoKSB7IH0sIEFERCA9IFtcXFwidG9TdHJpbmdcXFwiLCBcXFwidmFsdWVPZlxcXCJdO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGlmICgvTVNJRS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xcbiAgICAgICAgICAgICAgICAgICAgX0lFRW51bUZpeCA9IGZ1bmN0aW9uIChyLCBzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IEFERC5sZW5ndGg7IGkgPSBpICsgMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5hbWUgPSBBRERbaV0sIGYgPSBzW2ZuYW1lXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYgIT0gT2JqZWN0LnByb3RvdHlwZVtmbmFtZV0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbZm5hbWVdID0gZjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7IH1cXG4gICAgICAgICAgICA7XFxuICAgICAgICAgICAgX0lFRW51bUZpeChzdWJjLnByb3RvdHlwZSwgb3ZlcnJpZGVzKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vSlNFbmNyeXB0Ly4vbGliL2xpYi9qc3JzYXNpZ24veWFob28uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXFxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxcblxcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG4oZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgIH1cXG59ICgpKVxcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XFxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcXG4gICAgICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG59XFxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcblxcbn1cXG52YXIgcXVldWUgPSBbXTtcXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcXG52YXIgY3VycmVudFF1ZXVlO1xcbnZhciBxdWV1ZUluZGV4ID0gLTE7XFxuXFxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgfVxcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBkcmFpblF1ZXVlKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcXG4gICAgaWYgKGRyYWluaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XFxuICAgIGRyYWluaW5nID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgd2hpbGUobGVuKSB7XFxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcXG4gICAgICAgIHF1ZXVlID0gW107XFxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG59XFxuXFxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcXG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XFxuICAgIH1cXG59O1xcblxcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcXG4gICAgdGhpcy5mdW4gPSBmdW47XFxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcXG59XFxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcXG59O1xcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XFxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcXG5wcm9jZXNzLmVudiA9IHt9O1xcbnByb2Nlc3MuYXJndiA9IFtdO1xcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBub29wKCkge31cXG5cXG5wcm9jZXNzLm9uID0gbm9vcDtcXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLm9uY2UgPSBub29wO1xcbnByb2Nlc3Mub2ZmID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XFxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcXG5cXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9KU0VuY3J5cHQvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9saWIvaW5kZXguanNcIik7XG4vKioqKioqLyBcdF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsencrypt/bin/jsencrypt.js\n");

/***/ })

};
;